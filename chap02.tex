\chapter{Revisão Bibliográfica}\label{bibliografia}

A modelagem de robôs de acordo com suas principais funcionalidades e o
desenvolvimento de novas arquiteturas são a base no estudo de autonomia e
controle de missão de robôs móveis. Dessa forma, arquitetura robótica e controle
de missão são conceitos relacionados e, portanto, o cerne desta pesquisa
bibliográfica.

Neste capítulo, são apresentados os fundamentos teóricos necessários para o
entendimento desta dissertação. O objetivo deste levantamento bibliográfico é
apresentar alguns dos principais trabalhos e pesquisas científicos sobre
arquiteturas e sistemas de controle de missão de robôs móveis. Por fim,
o leitor é direcionado para os ambientes de software desenvolvidos para robôs
autônomos (\textit{Robotic Development Environments} - RDEs).

\section{Conceitos}\label{conceitos}
 
Faz-se necessário a definição de alguns conceitos para o entendimento desta
dissertação e para a fase de implementação da arquitetura. 

O conceito de arquitetura %do grego arkhétékhton, do ingles architecture, do
% frances architecture
para robôs é definido de diferentes formas na
literatura. Em \cite{arkin1998behavior}, arquitetura de robô é
relacionada com arquitetura de software, em uma adaptação à
arquitetura de computadores de \cite{stone1980introduction}, e definida como:
arquitetura de robô é a disciplina dedicada ao projeto de robôs altamente
específicos e individuais a partir de uma coleção de blocos comuns de softwares.
Em \cite{mataric1992behavior}, a definição aborda sistemas de controle: uma
arquitetura fornece uma maneira principal de organizar um
sistema de controle, contudo, a arquitetura também impõe restrições sobre a
forma como o problema de controle pode ser resolvido. Já
em \cite{brooks1986robust}, o autor tenta associar a arquitetura de software
com os componentes de hardware (processadores) para compor a arquitetura
robótica.

O sistema robótico é composto por diversos elementos de hardware e
software que são interdependentes e necessários para o funcionamento do sistema.
No desenvolvimento de uma arquitetura robótica, são considerados os aspectos
físicos, lógicos e a aplicabilidade do robô, portanto entende-se que:

\begin{defn} 
Uma \textbf{arquitetura robótica} descreve
uma maneira de se construir o controle inteligente do robô, os módulos do sistema, como estes
módulos interagem entre si e seus elementos de hardware associados, visando sua
aplicação. Os elementos de hardware e a aplicação assumem um papel de grande
importância durante o desenvolvimento dessas arquiteturas, por exemplo como um
fator limitador.
\end{defn}

Uma definição equivalente de \textbf{arquitetura robótica}, porém mais objetiva
é:

\begin{defn}
Uma \textbf{arquitetura robótica} é uma arquitetura que
pode ser avaliada pelos critérios de Arkin: \textbf{Suporte a paralelismo},
\textbf{\textit{Hardware targetability}}, \textbf{\textit{Niche targetability}}, \textbf{Suporte a modularidade},
\textbf{Robustez}, \textbf{Tempo de desenvolvimento}, \textbf{Flexibilidade em
tempo de execução} e \textbf{Desempenho em executar tarefas} (detalhes na
seção~\ref{avametodologia}).
\end{defn}

De acordo com \cite{siegwart2004autonomous}, os componentes básicos de uma
arquitetura para robôs são classificados em três grupos: \textit{Percepção}, que
envolve as atividades de interpretação e integração dos sensores;
\textit{Planejamento} de tarefas, sincronização,
e o monitoramento da execução de todas as atividades do robô; e
\textit{Atuação}, que envolve as atividades de execução dos movimentos, ações do robô e controle
dos atuadores.

As três primeiras seções desta pesquisa bibliográfica abordam os paradigmas da
robótica, isto é, as três arquiteturas de operação de um sistema robótico:
paradigma hierárquico/deliberativo (SPA - \emph{Sense, Plan and Act}); paradigma
reativo; e paradigmo híbrido deliberativo/reativo. As seções apresentam e
exemplificam as arquiteturas pela ótica de diversos autores, e são
comparadas e analisadas.

O controle de missão (\textit{Mission Control System} - MCS) ou planejamento de
missão (\textit{Mission Planning}) ou planejamento de tarefas (\textit{Task Planning})
de robôs faz parte da arquitetura robótica, e pode ser desenvolvido para os
três tipos de arquiteturas. Em \cite{fryxell1996navigation}, o conceito é bem
introduzido como: controle de missão é um sistema que permite ao operador
definir as missões de um veículo em linguagem de alto nível; provê ferramentas adequadas para converter planos em
Programas de Missões que podem ser verificados e executados em tempo real; e
permite ao operador saber o estado da missão enquanto esta é executada, e
modificá-la se for necessário. Em \cite{brumitt1996dynamic}, o conceito de
planejamento de missão é ampliado para múltiplos robôs: planejamento de missão
é o processo de determinar o que cada robô deve fazer para alcançar, de uma
maneira conjunta, os objetivos da missão, em um ambiente dinâmico.

Neste trabalho, entende-se como controle de missão de sistemas robóticos:

\begin{defn}
O controle de missão de robôs é o componente da arquitetura
robótica que permite ao operador definir as missões de um veículo,
exerce o papel de traduzir os comandos de missão do usuário ao robô, provê
feedback ao operador (\textit{execution monitoring}), e contém as diretivas do
robô. 
\end{defn}

O controle de missão faz parte da arquitetura robótica, portanto
as seções que seguem buscam, em cada arquitetura, destacar de forma
exemplificada alguns controles de missão.

O sistema robótico DORIS é um robô móvel com aplicação de inspeção em um
ambiente dinâmico.
Apresenta missões semelhantes a um AUV, apesar de sua dinâmica ser mais simplificada, já que este se move ao longo de um trilho.
Entretanto, como a aplicação (inspeção) é igual, os hardwares são equivalentes
por ser um robô móvel com vários sensores, e alguns desafios são comuns. É de
se esperar que a arquitetura robótica possa apresentar muitas semelhanças. Desta
forma, durante a apresentação das arquiteturas, será sempre destacada uma
arquitetura de AUV ou UGV de aplicação semelhante.

\section{Paradigma hierárquico/deliberativo}
Em meados do século XX, foram realizados os primeiros estudos de robôs
autônomos, juntamente com o aparecimento da Inteligência Artificial (IA). Em um sistema
robótico, a IA clássica consiste em um modelo centralizado que coleta
informações usando sensores, cria um modelo do ambiente, planeja o próximo
movimento e executa a ação. São sistemas do tipo \emph{Sense, Plan and
act} (SPA) ou \emph{top-down} (hierárquico), como na decomposição tradicional
(Figura~\ref{hierarquica}).

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/Hierarchical.png}
\caption{Paradigma hierárquico tradicional.}
\label{hierarquica}
\end{figure}

De acordo com Marvin Minsky, uma máquina (robô) deveria tender a criar, por si
só, um modelo abstrato do ambiente em que está inserido (define-se
\emph{mundo}).
Caso fosse dada uma tarefa, o robô poderia, primeiramente, explorar soluções
dentro de seu modelo abstrato e, então, experimentá-las externamente. Seria como realizar uma simulação interna
e, caso funcionasse, executá-la.

\subsection{Robôs deliberativos}
Entre 1966 e 1972, Charles Rosen e Nils Nisson da Universidade de Stanford
criaram o Shakey, primeiro robô móvel autônomo (Figura~\ref{SHAKEY_1}). Foi
desenvolvida uma inteligência artificial chamada
STRIPS (\textit{problem solver}). Este sistema é um planejador de trajetórias
que armazena as informações do ambiente (mapas e obstáculos) de maneira
simbólica, e, se dada uma tarefa de deslocamento (\textit{goto}), é realizada uma busca lógica pelo sistema. 

Em 1977, começou a ser desenvolvido o projeto HILARE (Figura~\ref{hilare}), no
Laboratoire d'Automatique et d'Analyse des Systèmes (LAAS), Toulouse, França.
O robô possuía sensores como câmera, ultrassom e laser para medir
distância, sendo possível atualizar o seu mundo com acurácia. Seu mundo era
representado por modelos geométricos e um modelo relacional que expressava a
conectividade dos quartos e corredores (simbólico) \cite{norelis1989control}.

Também em 1977, o Stanford Cart foi criado por Moravec para navegação e desvio
de obstáculos \cite{moravec1977towards}. Os obstáculos eram identificados pelo
robô durante a operação e representados em seu mundo interno como
esferas. O robô possuía uma segunda representação do mundo simbólica por
grafos.

Em 1969, Victor Scheinman, Universidade de Stanford
\cite{scheinman1969design}, inventou o primeiro manipulador robótico
totalmente elétrico de seis elos e com solução completa e integrada de
cinemática inversa. Isto é, dado um ponto qualquer pertencente ao espaço de
trabalho do manipulador, este calcula o ângulo das juntas de forma que o
efetuador alcance o ponto especificado. Isso permitiu que o manipulador
percorresse trajetórias arbitrárias. Até os dias atuais, 2015, é ampla a
utilização de manipuladores industriais. A sofisticação destes sistemas já
possibilita que estes armazenem todo o conhecimento do mundo e executem tarefas
autônomas (Figura~\ref{manipulador}).

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/SHAKEY_1.png}
\caption{Shakey robot}
\label{SHAKEY_1}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/HILARE.jpg}
\caption{HILARE}
\label{hilare}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/MANIPULADOR.jpg}
\caption{Manipulador robótico atual}
\label{manipulador}
\end{figure}

\subsection{Arquiteturas deliberativas}
As arquiteturas deliberativas são sistemas hierárquicos com a lógica
\textit{SPA}. São utilizados em sistemas robóticos até hoje, quando a aplicação
favorece seu uso e o poder computacional não é uma restrição.
Destacam-se os modelos de Albus, NASREM, o \emph{Intelligent Mobile
Robot System}, e o MARIUS (AUV).

\subsubsection{Modelo de Albus}

Albus foi o pioneiro e mais influente autor de teorias em arquiteturas
deliberativas, \cite{albus1991outline}. Sua grande contribuição foi a
formalização e definição de diversos termos amplamente utilizados em automação e controle. Dentre outros, destaca-se o
teorema de que há quatro sistemas que compõem a inteligência: processamento de
sensores, modelo do mundo, geração de comportamentos, e julgamento de valor. 

\begin{itemize}
  \item Atuadores: as saídas de um sistema inteligente são produzidas por
  atuadores, como mover, posicionar braços, pernas, mãos, olhos e etc.
  Analogamente, os ``atuadores'' da natureza naturais são os músculos e as
  glândulas, já os atuadores de máquinas são motores, pistões e válvulas.
  \item Sensores: são as entradas de um sistema inteligente, como sensores de
  força, torque, posição, velocidade, vibração, acústico, gases, temperatura e
  muitos outros. Monitoram o mundo e o estado interno do sistema, e provêem
  dados ao sistema de processamento sensorial.
  \item Processamento sensorial: sistema que compara novas observações com a
  expectativa interna do modelo do mundo. Integra e armazena as diferenças e
  semelhanças encontradas, a fim de reconhecer padrões, objetos e relações no
  mundo.
  \item Modelo do mundo: é a melhor estimativa que o sistema inteligente possui
  do mundo, e atualizado pelo processamento sensorial. É um banco de dados com
  todo o conhecimento do mundo e contém uma capacidade de simulação que gera expectativas e predições. O modelo do mundo
  pode prover informações do passado, presente e prever estados futuros.
  Os dados são importantes para: o gerador de comportamentos escolher o plano
  adequado para execução das ações; o processamento sensorial fazer correlações,
  comparação de modelos, e reconhecimento de objetos, estados e eventos; e o
  sistema de julgamento de valor computar valores de custo, benefício, risco,
  incerteza, importância e outros.
  \item Julgamento de valor: este é o sistema que determina o que é bom ou ruim,
  importante ou trivial, certo ou improvável. Computa custos, riscos e
  benefícios de situações observadas e atividades planejadas.
  \item Gerador de comportamentos: elemento que seleciona objetivos e planos,
  executa e monitora ações, e modifica planos existentes quando alguma situação
  do mundo exigir. Tarefas são decompostas em subtarefas, e subtarefas são
  sequências de objetivos. A ordem lógica de funcionamento é: o gerador de
  comportamentos cria planos, o modelo do mundo predita o resultado do plano, e
  o julgamento de valor avalia os resultados. O gerador de comportamento
  seleciona o plano com a avaliação mais alta.
\end{itemize}

As relações entre os elementos do sistema inteligente estão representados na
Figura~\ref{albus}.  Esses elementos e suas relações possibilitaram a criação de
diversas arquiteturas.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/albus.pdf}
\caption{Arquitetura de Albus para sistemas deliberativos.}
\label{albus}
\end{figure}

Vale ressaltar que, nesta arquitetura, o \textit{gerador de comportamentos} faz
o papel do controle de missão, porém não de maneira completa, já que a
interação com o usuário ainda é precária.

\subsubsection{NASREM}
O NASREM \cite{albus1989nasa} foi uma arquitetura utilizada pela
NASA e possuía uma arquitetura com seis níveis de
funcionalidade (Figura~\ref{nasrem}):

\begin{enumerate}
  \item Servo: provê o controle dos atuadores do robô (posição, velocidade e
  etc).
  \item Primitiva: determina as primitivas de movimento para gerar trajetórias
  suaves.
  \item Movimento elementar: define e planeja trajetórias livres de colisões.
  \item Tarefa: converte ações desejadas de um objeto em sequências de
  movimentos elementares.
  \item Compartimento de serviços: converte ações de grupos de objetos em
  tarefas de um objeto.
  \item Missão: decompõe o plano de missão em alto nível em compartimento de
  serviços.
\end{enumerate}

Vale ressaltar que, no modelo NASREM, o operador tem acesso a qualquer nível
hierárquico do robô e pode tomar o controle do robô para si, além de poder
substituir as entradas de sensores, modelo do mundo e outros. Dessa forma, o
nível de autonomia do robô pode ser desenvolvido de forma incremental.

A arquitetura hierárquica proposta em NASREM permite modularidade e propõe uma
metodologia de software.  
 
\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/NASREM.pdf}
\caption{Arquitetura NASREM.}
\label{nasrem}
\end{figure}

\subsubsection{\textit{Intelligent Mobile Robot System}}
Em 1991, Saridis \cite{wang1991petri} cria o \emph{Intelligent Mobile
Robot System} (IMRS) baseado na teoria de inteligência hierárquica de controle
\cite{saridis1988analytical}. Saridis utiliza redes de Petri (PNT) como módulos
básicos da arquitetura para traduzir os comandos gerados pelo nível de
organização em algo compreensível para o nível de execução.

O IMRS possui a seguinte arquitetura (Figura~\ref{Saridis_1}):
\begin{itemize}
  \item Nível organizacional (organizador de tarefas): gera tarefas de
  movimentação de alto nível.
  \item Nível de coordenação: funciona como uma interface entre o nível
  organizacional e o de execução. O nível é composto por um remetente e alguns
  coordenadores. O remetente recebe o plano da tarefa do organizador, decompõe a
  tarefa em ações de controle e remete aos coordenadores. Os coordenadores
  traduzem os comandos de controle em instruções de operação e transmite ao
  nível de execução.
  \item Nível de execução: executa a instrução proveniente do nível de
  coordenação e reporta seus resultados a ele.
\end{itemize}

% O nível de coordenação do IMRS é composto por um remetente
% (\emph{Dispatcher}) e três coordenadores: sistema de visão (VS), desvio de
% obstáculo e controle de rastreamento (OATC), e planejamento de trajetórias (PP).
% Com o modelo de redes de Petri não é possível implementar o esquema de linguagem de
% decisão para descrever a tradução de tarefas entre remetente e coordenadores.
% Portanto, os \emph{Petri Net Transducers} (PNTs) foram introduzidos como
% tradutores de linguagem (protocolo): $PNT = (N,\Sigma,
% \Delta, \sigma, \mu, F)$. Onde:
% \begin{itemize}
% 	\item A rede de Petri $N=(P,T,I,O)$, $P$ lugares, $T$
% transições, função de entrada $I$, função de saída $O$, é o controle da
% tradução;
% 	\item $\mu$ é o estado inicial de $N$;
% 	\item $\Sigma$ é o alfabeto de entrada, representa tarefas de entradas;
% 	\item $\Delta$ é o alfabeto de saída, representa tarefas de saída; 
% 	\item $\sigma$ especifica, para uma dada tarefa de entrada, as transições em
% $N$ e as subtarefas de saída que podem ser usadas na tarefa;
% 	\item $F$ é o estado final. Indica o fim da tradução da tarefa;
% \end{itemize}    
% 
% Os quatro PNT's são combinados para realizarem a tradução de tarefas no Nível
% de Coordenação: remetente, sistema de visão, desvio de obstáculo
% e controle de rastreamento, e planejamento de trajetórias. 

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/SARIDIS_1.pdf}
\caption{Arquitetura de Saridis}
\label{Saridis_1}
\end{figure}

A modelagem do sistema utilizando redes de Petri proporcionou algumas
funcionalidades essenciais em uma arquitetura robótica, destacam-se: a
capacidade de executar duas tarefas simultaneamente (por exemplo, movimentação e planejamento de
trajetórias); e o \emph{Input Semaphore}, que impede um processo de ser
executado até outro ser finalizado.
  
Saridis salienta os benefícios das PNT:
\begin{itemize}
  \item Redes de Petri podem ser usadas como módulos básicos para sistemas de
  controle de missão de robôs móveis.
  \item A comunicação e conexão de módulos são eficientes entre redes de Petri.
  \item Controle e mecanismo de comunicação para coordenação de tarefas de um
  robô móvel podem ser realizados com redes de Petri.
\end{itemize} 

A arquitetura de Saridis é uma contribuição importante por criar um nível
organizacional, separando o nível do desenvolvedor de baixo nível e um
nível de alto nível para um operador (usuário). Além disso, as redes de Petri
assumem um importante papel como módulo básico de controle para seu sistema
IMRS. As redes de Petri foram originalmente introduzidas para descrever as
comunicações de máquinas de estados finitos (FSMs), possibilitando flexibilidade
e robustez. É provado que redes de Petri são uma excelente ferramenta para
modelagem de sistemas, sobretudo quando envolvem tarefas conflitantes ou
simultâneas \cite{murata1989petri}.

\subsubsection{MARIUS}
Em 1996, Silva et al. \cite{oliveira1996design} (Institute for Systems and
Robotics, Lisboa) projetaram, desenvolveram e testaram um sistema de controle de missão para o
MARIUS, robô autônomo submarino. %O trabalho de Silva introduz novos e
% importantes conceitos chave para o MCS: Tarefa do Sistema (\emph{System Task}), Primitiva do
% Veículo (\emph{Vechicle Primitive}), Procedimento de Missão (\emph{Mission Procedure})
% e Programa de Missão (\emph{Mission Program}). Além disso, a arquitetura do
% veículo, por ser um AUV, possui sistemas e interconexões
% semelhantes ao robô DORIS, estudo desta dissertação.
% 
% \textbf{Tarefa do Sistema} (ST): é a especificação paramétrica de uma classe
% de algoritmos ou processos que implementam uma funcionalidade básica em um robô.
% Requer a implementação de dois módulos: \textit{i}) um \emph{módulo Funcional}
% que contém um determinado algoritmo e processo, e transfere dados com outras
% Tarefas do Sistema e dispositivos físicos; \textit{ii}) um \emph{módulo
% Comando}, máquina de estado finito, que recebe comandos externos, produz
% mensagens de saída, e controla a seleção de algoritmos, processos, e caminhos
% dos dados para/de módulos Funcionais.

A arquitetura do MARIUS é descrita abaixo, Figura~\ref{SILVA_1}:
\begin{itemize}
  \item \emph{Vehicle Support System} (VSS) - Controla a distribuição de energia
  aos hardwares instalados no veículo, monitora consumo de energia e detecta
  falhas de hardware, podendo enviar comandos de emergência.
  \item \emph{Actuator Control System} (ACS) - Controla a velocidade de rotação
  dos propulsores e posição dos ailerions e lemes. Os \emph{Set Points} dos
  atuadores são dados pelo \emph{Vehicle Guidance and Control System} (VGCS) e
  os dados dos atuadores são transmitidos para o \emph{Mission Control System}.
  \item \emph{Navigation System} (NS) - Estima posição linear e velocidade do
  veículo, orientação e velocidade angular. O sistema funde informações do
  \emph{Positioning System} (\emph{Long Baseline unit}) e \emph{Motion Sensor
  Integration System}, o qual inclui diversos sensores. As saídas do NS são
  entradas do VGCS, e enviadas ao MCS.
  \item \emph{Vehicle Guidance and Control System} (VGCS) - Recebe como entrada
  as trajetórias de referência pelo MCS, e os dados de navegação do NS. Suas
  saídas são \emph{Set Points} para velocidade de rotação e outros atuadores do
  ACS, tal que o veículo siga a trajetória desejada mesmo com incertezas e
  distúrbios.
  \item \emph{Communication System} (COMS) - Controla o link bidirecional usado
  pelo operador para passar missões ao MCS, e pelo veículo para passar o estado
  de missão ou estados do veículo.
  \item \emph{Environmental Inspection System} (EIS) - Coleta dados do ambiente
  com diversos sensores (inclusive câmeras), como temperatura, pressão, pH. É
  controlado pelo MCS.
  \item \emph{Data Logging System} (DLS) - Adquiri e armazena dados do veículo.
  \item \emph{Mission Control System} (MCS) - Sequencia e sincroniza a execução
  das tarefas básicas do veículo para uma determinada missão e provê a
  recuperação em caso de falhas.
\end{itemize}

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/SILVA_1.pdf}
\caption{Arquitetura do Veículo MARIUS}
\label{SILVA_1}
\end{figure}

Silva desenvolveu os softwares CORAL e ATOL para implementação das VPs e STs em
redes de Petri de forma que um usuário final, como um operador, pudesse
facilmente criar seus MPs.   


\subsection{Análise crítica}
A abordagem deliberativa simula, de certa forma, o processo de planejamento e
tomada de decisão do ser humano. Há um núcleo (cérebro) que
processa todos os dados sensorias e armazena o mundo, isto é, o ambiente em que
o robô está inserido, de maneira simbólica, geométrica ou outros tipos de
mapeamento. Além disso, o núcleo planeja todas as ações para uma determinada
tarefa, consultando sua ideia de mundo intensivamente. Há, também, sensores que
enviam suas novas informações periodicamente para o núcleo, (órgãos receptivos:
visão, olfato, e etc), atualizando o mundo. E há atuadores (músculos)
necessários para a realização das tarefas (Figura~\ref{brain}).

É fácil observar que a arquitetura deliberativa é dependente do
modelo de mundo armazenado e suas atualizações periódicas. Portanto, a
utilização da abordagem deliberativa em ambientes extremamente dinâmicos pode ser muito
custosa devido às atualizações e ao replanejamento. Além disso, a arquitetura
SPA dificulta a criação de sistemas em tempo real eficientes.
Dessa forma, robôs móveis em ambientes muito dinâmicos, como o carro autônomo da
Google (Figura~\ref{googlecar}), não são aplicações favoráveis para esta
arquitetura.

O controle de missão é presente em arquiteturas deliberativas, mas de maneira
primitiva, normalmente possuindo apenas as funcionalidades de: quebrar as
missões em tarefas menores que o robô possa executar, gerenciar as tarefas, e
monitoramento interno. Entretanto, não desenvolve uma interface com o
usuário, a possibilidade de alteração de tarefas em tempo de
execução, e feedback ao operador em tempo real.

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/brain.jpg}
\caption{Comparativo da arquitetura deliberativa com o ser humano.}
\label{brain}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/googlecar.jpg}
\caption{Projeto da empresa Google 2011 - para o desenvolvimento de um carro
autônomo.}
\label{googlecar}
\end{figure}

\section{Paradigma reativo}

Sistemas de arquitetura reativa também são chamados de sistemas baseados em
comportamentos. Os robôs são programados para agir através de ativação de uma
coleção de comportamentos primitivos de baixo nível. De acordo com
\cite{arkin1995reactive}, as principais características de sistemas puramente
reativos são:

\begin{itemize}
  \item Comportamentos são como elementos construtivos: são um par sensor-motor,
  onde o sensor provê informação necessária para o motor executar uma ação
  reativa, como desvio de obstáculo, atrair-se a objetivos, escapar de
  predadores e etc.
  \item Não há criação ou manutenção precisa do modelo do mundo. Os sistemas
  reagem ao estímulo do mundo, extremamente útil para mundos dinâmicos e
  hostis.
  \item Comportamentos de animais são normalmente utilizados para modelar esses
  sistemas.
\end{itemize}

Controle reativo é uma técnica que une percepção e ação,
tipicamente no contexto de comportamentos motores, para produzir respostas
robóticas, em tempo real, em mundos dinâmicos.

Em 1986, um dos primeiros estudos em sistemas reativos foi desenvolvido por
Rodney Brooks \cite{brooks1986robust}. Este estudo é a base para diversos
trabalhos atuais que envolvem robôs reativos móveis. Os desafios de
robôs autônomos apontados por Brooks e que ainda ilustram os problemas da
atualidade são: \emph{múltiplos objetivos}, \emph{múltiplos sensores},
\emph{robustez} e \emph{extensibilidade}. De acordo com Brooks, esses desafios
não são suportados pela arquitetura tradicional (paradigma hierárquico).

Os múltiplos objetivos de robôs móveis podem:
\begin{itemize}
  \item Ser conflitantes: por exemplo, um robô pode estar tentando alcançar um
  determinado ponto no espaço, porém evitando obstáculos locais.
  \item Ter relações de prioridade: por exemplo, um robô que inspeciona trilhos
  de trêm deve sair dos trilhos ao ouvir o sinal de um trêm chegando, mesmo se estiver
  finalizando a operação.
  \item Ser denpendentes: objetivos de \emph{alto nível} englobam diversos
  objetivos de \emph{baixo nível}. No caso do exemplo acima, o robô que sai do
  trilho para evitar o trêm deve se manter equilibrado para não cair. Artigos
  recentes, como em \cite{fryxell1996navigation} separam esses objetivos em
  \emph{tarefas} (objetivos de \emph{alto nível}) e \emph{primitivas do veículo}.
\end{itemize}

Robôs são normalmente providos de múltiplos sensores e suas diversas
informações podem ser redundantes, conflitantes ou complementares,
podendo ser utilizadas para uma mesma tarefa do robô.
Por exemplo, \textit{encoders} para odometria e câmeras fixas ao robô
podem ser utilizados para localização, de forma que se complementem.
Os sensores podem apresentar erros ou resultados conflitantes, portanto a fusão
da informação de múltiplos sensores, a determinação de seus graus de
confiabilidade e em quais tarefas devem ser considerados são decisões que o
robô deve saber fazer.

Um robô deve ser robusto, isto é, em caso de falha de um sensor, o robô
deve se adaptar e utilizar os outros sensores que ainda funcionam para realizar as
tarefas. Ou em caso de alterações no ambiente, o robô deve ser
capaz de cumprir determinadas funções essenciais.

A extensibilidade constitui em acrescentar mais sensores e,
portanto, aumentar a capacidade do robô, sendo possível a execução de novas
tarefas. Porém, esta afirmação é normalmente criticada por alguns autores já que
existe um limite imposto pelo processamento do robô, já que um novo hardware
(sensor) é adicionado, mas o processamento (computador) não é substituído e sua
capacidade não é aumentada.

Brooks propõe um dos primeiros sistemas baseados em comportamentos, uma
arquitetura que tem como objetivo descentralizar a tomada de decisão de um
modelo central, como pode ser visto na Figura~\ref{BROOKS_1}. O autor comenta
que essa decomposição conduz a uma arquitetura radicalmente diferente para robôs
móveis, em estratégias de implementação a nível de hardware e com grandes
vantagens em robustez, desenvolvimento e teste.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_1.pdf}
\caption{Arquitetura para sistema de controle de robôs móveis por Brooks}
\label{BROOKS_1}
\end{figure}

\subsection{Robôs reativos}
Antes mesmo de Brooks, ou seja, antes da formalização de toda a teoria em
sistemas reativos, simples robôs eram criados na lógica de controle reativo e de
comportamentos. Em 1953, por exemplo, Grey Walter \cite{holland1997grey}
desenvolveu uma ``tartaruga'' elétrica capaz de se movimentar pelo ambiente,
evitando luz intensa (``ameaças'') e atraída por certos objetivos. Vale
observar a característica de perceber baixo nível de bateria e procurar
uma estação de recarga, comportamento que se sobrepõe aos outros. Os
comportamentos são simples: dirigir-se para luz fraca; fugir de luz forte; e
evitar obstáculos. Não há representação abstrata do mundo (Figura~\ref{turtle}).

Em 1984, veículos simples e puramente reativos com os pares clássicos
sensor-motor foram desenvolvidos pelo psicologista Braitenberg
\cite{braitenberg1986vehicles}, a fim de simular sentimentos, como covardia,
agressividade e outros (Figura~\ref{Braitenberg}). 

Em 2002 até os dias atuais, o robô Roomba da empresa iRobot ganha destaque
comercial e executa uma simples tarefa doméstica: limpar o chão. Em sua arquitetura, o robô
Roomba possui apenas algumas funções reativas, como esquivar-se e locomover-se,
e não possui o modelo do mundo \cite{tribelhorn2007evaluating}
(Figura~\ref{roomba}).

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/turtle.jpg}
\caption{A tartaruga de Grey Walter.}
\label{turtle}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/Braitenberg.jpg}
\caption{Veículos de Braitenberg.}
\label{Braitenberg}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/roomba.jpg}
\caption{Robô comercial Roomba da iRobot.}
\label{roomba}
\end{figure}

\subsection{Arquiteturas reativas}\label{reativa}
As arquiteturas reativas foram formalmente introduzidas em 1986 por
Roodney Brooks. O roboticista, futuro fundador da empresa iRobot, vivenciou uma
época de processadores lentos e de alto custo, dificultando o uso de diversos
sensores e a armazenagem do modelo do mundo no robô. Simulações de tarefas,
atualizações do mundo e análise de sensores como câmeras eram extremamente
complexas para robôs e impossíveis de serem executadas em tempo real. Brooks
vislumbrou como solução o processamento paralelo, evitar o uso de um modelo do
mundo e criar módulos puramente reativos, pares sensor-motor, que juntos compõem
o robô. 

Arquiteturas reativas utilizam informações locais
do meio, obtidas pelos sensores do robô. Estas são simplificadamente tratadas,
de forma que a ação ao estímulo é tomada rapidamente e, assim, os robôs reativos
podem responder de forma mais rápida às variações do ambiente. A arquitetura
define como a informação é mapeada em uma ação e como é feita a coordenação dos
pares estímulo-ação (comportamentos reativos).

De acordo com Arkin \cite{arkin1998behavior}, há duas classes predominantes
para a função de coordenação: competitiva e cooperativa.

Um conflito ocorre quando dois ou mais comportamentos estão ativos ao mesmo
tempo e possuem respostas diferentes. Nesse caso, a coordenação de forma
competitiva entra em ação, escolhendo um dos comportamentos para a ação final do
robô. A prioridade de um comportamento sobre os demais pode ser definida
explicitamente em uma hierarquia entre os comportamentos, ou pode haver uma
votação por uma ação, ou outros métodos. Um exemplo de sistema reativo com
coordenação do tipo competitiva é o desenvolvido por Brooks, a arquitetura de
subsunção.

Na função cooperativa, a ação do robô é a fusão das respostas de todos os
comportamentos ativos. A arquitetura reativa esquema motor de Arkin é um exemplo
claro deste tipo de coordenação, onde cada comportamento influencia o movimento
do robô por meio de um vetor de força artificial e a ação resultante é
determinada pela soma vetorial de todos os vetores de força.


\subsubsection{Arquitetura de subsunção}\label{brooks}
A arquitetura de subsunção é, neste trabalho, destacada e exemplificada, já que
sua lógica será essencial para a implementação da arquitetura da DORIS.

Na Figura~\ref{BROOKS_1}, Brooks define \emph{Níveis de competência} (iniciando
pelo nível zero), que são classes de comportamentos desejados para o robô sobre
todos os ambientes que ele pode encontrar. As classes definidas por Brooks são:
\begin{enumerate}
\setcounter{enumi}{-1}
  \item Evitar contato com objetos (estacionários ou móveis);
  \item Vaguear sem rumo e sem bater em objetos;
  \item Explorar o ambiente utilizando sensores, definir lugares alcançáveis, e
  seguir rumo em suas direções;
  \item Construir um mini-mapa do ambiente e planejar trajetórias de um lugar
  para outro;
  \item Observar mudanças no ambiente;
  \item Raciocinar sobre o ambiente em termos de objetos identificáveis e
  realizar tarefas relacionadas a certos objetos;
  \item Formular e executar planos que envolvam mudar o estado do ambiente como
  desejado;
  \item Raciocinar sobre o comportamento de objetos no ambiente e modificar
  planos quando necessário;
\end{enumerate}

Cada nível de competência inclui, como subconjunto, os
níveis de competência anteriores.

Após a decomposição na nova arquitetura, Brooks define as \emph{Camadas de
Controle}, correspondentes a cada nível de competência. A ideia dessa abordagem
é adicionar camadas de controle a níveis de competências superiores sem precisar
alterar a camada do nível inferior. Inicia-se, portanto, com a camada de
controle para o nível zero de competência, esta será testada e não mais
alterada. Após, é criada a camanda de nível 1, capaz de examinar os dados
da camada de nível 0 e injetar dados nas interfaces internas deste nível,
suprimindo seu trânsito de dados (Figura~\ref{BROOKS_2}).

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_2.pdf}
\caption{Camadas de controle de Brooks}
\label{BROOKS_2}
\end{figure}

A camada de controle nível zero deve garantir que o robô não entre em contato
com outros objetos, estacionários ou móveis. Portanto, o robô deve desviar de
objetos que se aproximam ou parar se houver um objeto fixo em sua trajetória. A
camada de controle nível 1, combinada a camada de controle nível 0, permite que
o robô vagueie sem colisões. A Figura~\ref{BROOKS_4} mostra o sistema de
controle aumentado pelo nível da camada 1.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_4.pdf}
\caption{Nível 0 e 1 de controle do sistema}
\label{BROOKS_4}
\end{figure}

A estrutura das camadas de controle foram construídas por um conjunto de
pequenos processadores que enviam mensagens uns para os outros. Cada processador
é uma máquina de estado finito. A nova arquitetura e essa nova estrutura de
camadas com eventos discretos foram a base de diversos sistemas de controle de
missão da atualidade. 

A nova arquitetura de Brooks é robusta, permite interações dinâmicas, é flexível
para integrar novas funcionalidades, em camadas superiores, e fácil para
implementar e debugar.
Brooks ainda associa sistemas de eventos discretos no controle de robôs autônomos,
utilizando como módulos básicos máquinas de estados finitos (FSM - \emph{Finite
State Machine}). FSMs não podem ser concorrentes e não possuem mecanismos de
resolver conflitos (a conexão de diversas FSM's não é uma FSM), logo a solução
encontrada por Brooks foi acrescentar inibidores e supressores em suas FSM, chamando-as AFSM (\emph{Augmented Finite State Machine} ou máquina de
estado finito aumentada, Figura~\ref{afsm}). Porém, o modelo hierárquico dos
níveis cria uma certa inflexibilidade nos níveis inferiores.

\begin{figure}[!ht]
\centering
\includegraphics[width=.6\columnwidth]{figs/afsm.jpg}
\caption{Módulo básico da arquitetura de subsunção (AFSM).}
\label{afsm}
\end{figure}

Apesar dos pontos positivos, a arquitetura apresenta problemas com escala e contextualização
(\textit{situatedness}). 

O problema com escalamento é resultado das interconexões, que
podem crescer de maneira fatorial em relação ao número de comportamentos. 
A contextualização é um problema de sistemas de subsunção, onde subsistemas são
incluídos em um sistema mais amplo. Todos os comportamentos estão operando
ao mesmo tempo e anulando as saídas de outros comportamentos, de forma que
apenas uma é a saída do veículo. Portanto, há computação ineficiente.

Apenas em 1996, Bellingham e Consi \cite{bellingham1994second}
propuseram um controle por camadas (\emph{Layered Control}) a fim de resolver o
problema de escala. Há um módulo de processamento de sensores que
disponibiliza os dados aos comportamentos, resolvendo o problema de
interconexões, já que antes as camadas superiores deveriam se conectar às
inferiores para obter os dados dos sensores. Porém, Bellingham não resolveu o
problema utilizando uma arquitetura do tipo subsunção: as camadas são associadas
com um número de prioridade, de forma que saídas conflitantes são resolvidas
com esse número. Esta solução pode gerar uma certa inflexibilidade, visto que a adição de um novo comportamento pode alterar toda a estrutura de
prioridades previamente estabelecida.

A solução para o problema de contextualização só foi resolvido em 2000 por
Bennet \cite{bennett2000behavior}. No \emph{State Configured Layered Control} (SCLC),
múltiplos conjuntos de comportamentos simples são escolhidos de uma biblioteca
de comportamentos e são executados em cada fase da missão. A vantagem é o
número reduzido de comportamentos executados ao mesmo tempo. Esta é
uma estratégia comum em arquiteturas de controle híbrido. 

\paragraph{O AUV Eric}
Desenvolvido pelo Key Center Robotics Laboratory, University of Technology,
Sydney \cite{boswell1994using}, o AUV Eric segue a arquitetura de subsunção
desenvolvida por Brooks com alguns avanços. Foram desenvolvidos três níveis de
competência, que descrevem a capacidade do sistema: nível de preservação, nível
de exploração e nível de socialização. O nível de preservação realiza o desvio
de obstáculos, a exploração executa navegação de alto nível, e a socialização
habilita o comportamento de seguir objetos.

\subsubsection{Arquitetura Esquema Motor}\label{motorscheme}
Em 1987, Arkin \cite{arkin1987aura} utiliza a teoria de esquemas (psicologia)
proposta por \cite{arbib1992schema} para desenvolver sua função de coordenação
cooperativa para sistemas reativos, chamado de Esquema Motor. Neste sistema, as
respostas dos comportamentos aos estímulos são representadas por vetores
(magnitude e orientação) e a coordenação é alcançada pela adição dos vetores,
produzindo um vetor resultante. Não há hierarquia pré-definida entre
comportamentos, todos os comportamentos ativos contribuem
para a saída do sistema com sua resposta individual (vetor) e ganho
associado. O ganho do vetor (ou peso) é um parâmetro para dar flexibilidade,
possibilidade de aprendizado e adaptação do robô caso este não seja fixo.


Em uma tarefa de navegação, é fácil imaginar como funciona o método do Esquema
Motor. São definidos alguns esquemas motor (comportamentos), como mover-se em
direção ao objetivo, evitar obstáculos, desviar, escapar, e outros, e cada
comportamento responde com um vetor que representa velocidade (magnitude) e
direção (orientação) que o robô deve seguir. A soma dos vetores resulta
na direção e velocidade final do robô. Ao perceber um obstáculo, por
exemplo, os vetores do comportamento \textit{desvio de obstáculos} possuem
magnitude superior aos outros e orientação para fora do obstáculo (vetor de
repulsão), de forma que o robô executa o desvio, em vez de colidir.

Assim como a arquitetura de subsunção, no Esquema Motor, os esquemas agem de
maneira distribuída, paralela e são modulares. O sistema apresenta vantagem em
relação à arquitetura de camadas por sua dinâmica, já que os esquemas podem ser instanciados e desinstanciados a
qualquer momento, e é de fácil reconfiguração. Apesar do importante e atraente
resultado em tarefas de navegação, os esquemas motores dominaram apenas esse
nicho da robótica e, mesmo neste nicho, outras tarefas normalmente não são
executadas com esta arquitetura, como as tarefas que envolvem resolver
conflitos da percepção (processamento de sensores).

\subsection{Análise crítica}
Se a abordagem deliberativa simulava o processo de planejamento e tomada de
decisão do ser humano, os sistemas de arquitetura reativa simulam outra
importante função da medula espinhal, pertencente ao nosso sistema nervoso
central: o circuito reflexivo, ou arco reflexo. O reflexo é uma resposta
involuntária rápida, consciente ou não, originado de um estímulo externo e
realizado antes mesmo de o cérebro tomar conhecimento do estímulo periférico.

Dessa forma, não há planejamento, não há modelo de mundo, apenas uma reação ao
estímulo. Esse comportamento é extremamente importante e necessário para a
sobrevivência do ser humano. Por exemplo, quando encostamos a mão em
uma panela quente, temos a reação imediata de retirar a mão sem intervenção do
cérebro, sem replanejamento, cujo processamento levaria tempo suficiente para
causar danos severos. É fácil, portanto, perceber que tais comportamentos são
necessários também a robôs.

Robôs simples, como por exemplo um robô para limpar trilhos de trêm, ou robôs
para limpar o chão, podem ter o custo reduzido e executar extraordinariamente
bem suas tarefas sem a necessidade de planejamento e modelos complexos do mundo.
Durante a execução de sua tarefa, um robô limpador de trilhos só precisa saber
que é necessário sair do trilho ao avistar um trêm, logo basta um par
estímulo-motor e uma supressão de tarefa (no caso, a tarefa de continuar
limpando o trilho). Os grandes motivadores do aparecimento da
arquitetura reativa foram as aplicações simples para alguns robôs e a baixa
capacidade dos processadores da época.

Não é comum, na literatura, encontrarmos controle de missão em arquiteturas
reativas e é comum alguns autores se referirem a esses robôs como
\textit{non-taskable systems}, isto é, sistemas sem atribuição de
tarefas. Não há interface com o usuário, mas sim com o programador, que deve
alterar comportamentos a fim de gerar uma nova tarefa ou aplicação.

A Tabela~\ref{comparativa} mostra a comparação das arquiteturas analisadas até
agora.

\begin{table}[!ht]
\centering
\caption{Tabela comparativa de arquitetura deliberativa e reativa}
\label{comparativa}
\begin{tabular}{ll}
\hline
\multicolumn{1}{|l|}{Arquiteturas deliberativas}                                                   & \multicolumn{1}{l|}{Arquiteturas reativas}                                                            \\ \hline
Modelo interno do ambiente completo e preciso                                              
& Informações sensoriais locais                                                                         \\
Planejamento                                                                                       & \begin{tabular}[c]{@{}l@{}}Ações pré-definidas às informações \\ sensoriais\end{tabular}              \\
\begin{tabular}[c]{@{}l@{}}Maior flexibilidade na definição de \\ tarefas e objetivos\end{tabular} & \begin{tabular}[c]{@{}l@{}}Sistemas mais dedicados às tarefas \\ e problemas específicos\end{tabular} \\
\begin{tabular}[c]{@{}l@{}}Resposta lenta às mudanças no \\ ambiente\end{tabular}                  & \begin{tabular}[c]{@{}l@{}}Resposta rápida às mudanças do \\ ambiente\end{tabular}                   
\end{tabular}
\end{table}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/brain2.jpg}
\caption{Analogia de sistemas reativos com o ser humano.}
\label{brain2}
\end{figure}

\section{Paradigma híbrido ou deliberativo/reativo}

Arquiteturas deliberativas e reativas apresentam vantagens e
desvantagens e que muitas vezes se opõe. Por exemplo, é muito ineficiente
utilizar uma arquitetura deliberativa em um ambiente extremamente dinâmico,
assim como é ineficiente utilizar arquitetura reativa em uma linha de montagem
(manipuladores industriais). É natural pensar que integrando, de alguma forma,
as duas arquiteturas, formando uma arquitetura híbrida, será possível absorver
as vantagens de ambas.

Atualmente, os robôs com arquitetura híbrida predominam. Em muitas
aplicações de robôs móveis mais complexas, fica claro que formas de conhecimento
do mundo na arquitetura robótica permitem que a navegação dos robôs seja mais
flexível, eficiente e geral. A arquitetura híbrida tenta combinar os
métodos simbólicos da IA e seu uso de representação abstrata do modelo do mundo,
mas mantem o objetivo de prover robustez, resposta em tempo real e flexibilidade
dos sistemas puramente reativos. Arquiteturas híbridas podem permitir a
reconfiguração de controles reativos baseado no conhecimento do mundo através da
sua capacidade de raciocinar sobre os componentes comportamentais subjacentes.

O principal problema no paradigma híbrido é como desenvolver uma
metodologia unificada de arquiteturas que garanta um sistema capaz de executar
planos de uma maneira robusta, como a arquitetura reativa, e, ao mesmo tempo,
ter um entendimento de alto nível da natureza do mundo e um modelo da intenção
do usuário, como a arquitetura deliberativa.  

\subsection{Robôs híbridos}
Entre 1986 e 1987 \cite{arkin1989mobile}, Arkin foi o primeiro a criar uma
arquitetura híbrida e implementá-la em um robô. O objetivo do robô era
reconhecer o ambiente de trabalho, planejar uma trajetória e navegar até o ponto desejado,
evitando obstáculos estáticos e móveis (Figura~\ref{george}).

Em 1996, o AUV com arquitetura híbrida Phoenix, desenvolvido em Naval
Post-graduated School, Monterey, foi testado em Moss Landing
California \cite{brutzman1996nps}, Figura~\ref{phoenix}.  

Desde 2003 com o Spirit até os dias atuais com Opportunity e Curiosity
(Figura~\ref{curiosity}), a NASA vem desenvolvendo robôs de alta tecnologia,
com hardware e software de alto nível.

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/georgerobot.jpg}
\caption{Robô George.}
\label{george}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/phoenix.jpeg}
\caption{O AUV Phoenix.}
\label{phoenix}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/curiosity.jpg}
\caption{Robô Curiosity, o robô da NASA explorador do planeta Marte.}
\label{curiosity}
\end{figure}

\subsection{Arquitetura híbrida}\label{hibrida}
Em \cite{arkin1998behavior}, Arkin aponta quatro possíveis estratégias para o
projeto de arquiteturas híbridas:

\begin{itemize}
  \item \textbf{Seleção}: a deliberação é vista como um configurador. O
  planejador determina a composição de comportamentos e parâmetros usados durante a
  execução. O planejador pode reconfigurá-los quando necessário devido às falhas
  no sistema.
  \item \textbf{Conselho}: a deliberação é vista como um aconselhador. O
  planejador sugere mudanças que o controle reativo pode ou não usar.
  \item \textbf{Adaptação}: a deliberação é vista como um adaptador. O
  planejador continuamente altera os componentes reativos ativos de acordo com as mudanças
  nas condições do mundo e requisitos de tarefas.
  \item \textbf{Adiamento}: a deliberação é vista como um recurso para ser usado
  em último caso. Neste caso, os planos só são elaborados quando necessários.
\end{itemize}

Em \cite{murphy2000introduction}, Murphy afirma que apesar de arquiteturas
híbridas variarem em como a função deliberativa (o planejador) atua no sistema,
os componentes implementados em uma arquitetura híbrida são semelhantes,
possuindo geralmente os seguintes módulos:

\begin{itemize}
  \item Sequenciador: agente que gera o conjunto de comportamentos a serem
  usados para completar uma subtarefa, e determina qualquer sequência e
  condições de ativação. A sequência é normalmente representada como uma rede de
  dependências ou FSMs, mas o sequenciador gera essa estrutura ou dinamicamente a adapta.
  \item Gerenciador de recursos: agente que aloca recursos aos comportamentos.
  Este agente está diretamente ligado aos sensores do robô, podendo verificar
  qual o sensor é mais adequado para cada situação do robô. 
  \item Cartógrafo: agente responsável por criar, armazenar e atualizar o mapa,
  os modelos do mundo.
  \item Planejador de missão ou controle de missão: agente que interage com o
  usuário, traduz a mensagem do usuário para os termos do robô, e constrói um plano de missão. Por
  exemplo, um robô ``assistente'' poderia receber o comando ``Robô, traga um
  xícara com café''. O planejador de missão interpreta o comando e subdivide
  nas missões: procurar uma xícara, servir café (supondo que este já esteja
  pronto) e, levá-la ao usuário.
  \item Monitor de desempenho e solucionador de problemas: é o agente que
  permite ao robô perceber se está progredindo no cumprimento de sua tarefa.
\end{itemize}

Neste trabalho, são destacadas as arquitetura híbridas: Autonomous Robot
Architecture (AuRA), AUV Phoenix, CLARAty e Stanley.

\subsubsection{AuRA}

A Autonomous Robot Architecture (AuRA) foi a primeira arquitetura
híbrida, desenvolvida em 1986 por Arkin \cite{arkin1987aura}. De acordo com
Murphy \cite{murphy2000introduction}, AuRA pertence ao estilo de arquitetura híbrida \textit{administradora}
(\textit{Managerial}), reconhecida por sua decomposição similar a um
gerenciamento de negócios. Há agentes superiores que realizam planejamento em
alto nível e passam o plano a subordinados, os quais refinam os planos e coletam
os recursos, e, então, estes são passados ao último nível de agentes, os
comportamentos reativos. De acordo com Arkin, AuRA é um projeto de arquitetura
com estratégia de Seleção.

AuRA é composto por cinco subsistemas, dos quais dois pertencem à porção
deliberativa: Planejador (1) e Cartógrafo (2), o terceiro é um subsistema de
sensores (3), quarto é subsistema de gerenciador de comportamentos (4)
(gerenciador esquema motor) e o último subsistema de controle homeostático (5).

O Planejador (1) é responsável pela missão e
o planejamento de tarefas. É subdividido em três componentes: planejador da
missão, navegador e piloto, e seus módulos são executados sequencialmente,
tornando-se mais específicos e detalhados.
A lógica é hierárquica: o planejador de missão envia trechos da missão ao
navegador, o qual envia trechos de trajetória para o piloto, que determina ações
ao controlador de baixo nível. O planejador de missão também funciona como
interface ao usuário. A utilização do mapa interno do robô por cada módulo é
diferente, enquanto o planejador usa o mapa global, o piloto recebe informações
locais. Vale observar que, quando o modelo do mundo é atualizado, muitas vezes
não há necessidade de o planejador atualizar toda a missão e recomeçar o ciclo
de planejamento, o piloto pode recalcular a trajetória local. 
% Por exemplo, o
% navegador recebe as tarefas: ``vá até a montanha até a torre d'água, siga o
% caminho até o acampamento'', e o piloto recebe a primeira subtarefa ``vá até a
% montanha ae a torre d'água'' e as informações necessárias para gerar os
% comportamentos.

O Cartógrafo (2) encapsula todo o mapa e tem a funcionalidade de receber mapas a
priori (operador pode fornecer um mapa inicial). Os três componentes do
planejador interagem com o Cartógrafo para obter a trajetória a ser seguida,
quebrada em segmentos.

O subsistema do AuRA que gerencia comportamentos (4) utiliza a arquitetura
reativa esquema motor. O esquema motor, como visto na Subseção
\ref{motorscheme}, representa cada ação em campos potenciais (vetores) e a resposta do sistema é a
soma dos vetores. 

O controle homeostático (5), quinto subsistema, assume um papel intermediário
entre os sistemas deliberativo e reativo. Sua função é modificar a relação entre
comportamentos, modificando os ganhos dos vetores (Subseção \ref{motorscheme}).
Considere o seguinte exemplo, para melhor entendimento deste subsistema: um
veículo (robô), operando no planeta Marte em um ambiente rochoso, têm como
tarefa remover fisicamente amostras de rochas de várias localidades pelo planeta
e levá-las a um veículo de retorno, o qual tem uma data fixa de lançamento. O
robô é provido com ganhos padrões em seus comportamentos, os quais produzem uma
execução conservadora da operação, por exemplo garantindo que o robô esteja
sempre 2 metros de distância dos obstáculos em seu caminho. No começo da missão,
a execução conservadora parece razoável, mas agora considere próximo à data
limite de decolagem do veículo de retorno: se o robô estiver próximo ao veículo
de decolagem, ele deveria cortar caminhos, reduzindo sua margem de evitar
obstáculos para realizar a entrega, sacrificando sua própria existência pela
missão.

AuRA poderia integrar o controle homeostático à parte deliberativa da
arquitetura, mas foi motivado pela biologia a colocá-lo em outra área, chamada
de subconsciente, a qual, em animais, modifica sempre a área consciente em
resposta a necessidades internas. A Figura~\ref{aura} mostra os cinco
subsistemas da arquitetura AuRA. A Tabela~\ref{auratable} resume a arquitetura.


\begin{table}[!ht]
\centering
\caption{Classificação dos sistemas de AuRA de acordo com os componentes básicos
de uma arquitetura híbrida de Murphy}
\label{auratable}
\begin{tabular}{|l|l|}
\hline
Sequenciador            & Navegador, Piloto                       \\ \hline
Gerenciador de recursos & Gerenciador esquema Motor               \\ \hline
Cartógrafo              & Cartógrafo                              \\ \hline
Planejador de missão    & Planejador de Missão                    \\ \hline
Monitor de desempenho   & Piloto, Navegador, Planejador de missão \\ \hline
\end{tabular}
\end{table}


\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/aura2.pdf}
\caption{Arquitetura AuRA.}
\label{aura}
\end{figure}  

\subsubsection{Arquitetura de três camadas}\label{3t}
De acordo com Murphy, esta arquitetura pertence ao estilo Estado-hierárquico por
ser organizado em três camadas baseadas no estado de conhecimento: Planejador,
Executivo e Funcional. A arquitetura de três camadas é a mais aplicada em robôs
de grande complexidade , como AUVs e robôs do desafio DARPA (GRACE e Stanley).
Para melhor entendimento das funções das três camadas, será utilizado o exemplo
empregado em \cite{kortenkamp2008robotic}: considere um robô de entregas em
escritório, operando em um ambiente conhecido (mapeado).

O Planejador é uma camada composta pelo planejador de missão e o
cartógrafo. O planejador de missão gera objetivos e planos estratégicos, e
os repassa para a camada intermediária, chamada Executivo. O cartógrafo é
responsável por armazenar e atualizar o modelo do mundo, além de poder prover
diferentes modelos para as diferentes funções do robô, a fim de otimizar a
execução. 
 
No exemplo do robô de escritório, o Planejador analisa as
entregas do dia, pode verificar os recursos do robô, atualiza o mapa,
pode determinar as melhores rotas de entrega e agendamento, pode estimar quando
o robô deve se recarregar, e replaneja quando necessário, por exemplo, quando
um escritório estiver fechado, o robô deve alterar o agendamento para realizar
a entrega mais tarde.

A camada Executivo utiliza técnicas de planejamento reativo para selecionar um
conjunto de comportamentos de uma biblioteca de comportamentos, e desenvolve uma
rede de tarefa (\textit{task network}) especificando a sequência de execução
para os comportamentos a um subobjetivo particular. De acordo com Murphy, o Executivo
seria a camada responsável por sequenciar e monitorar o desempenho de uma
arquitetura híbrida. Ele é responsável por traduzir os planos de alto nível da
camada Planejador em comportamentos de baixo nível, chamando estes na hora
apropriada. É possível que a camada Executivo aloque e monitore os recursos,
substituindo esta função do Planejador.

No exemplo do robô de escritório, uma tarefa de alto nível seria entregar uma
carta a um escritório. O executivo deveria decompor esta tarefa em subtarefas,
deve usar um planejador de trajetórias geométrico para determinar a sequência de
corredores ao qual deve passar e interseções que deve virar, anunciar que a
pessoa tem uma carta e monitorar se a pessoa pegou a carta. Se a pessoa não
receber a carta depois de um determinado tempo, uma falha deve ser acionada, e
uma ação de recuperação deve ser tomada, como anunciar novamente à pessoa ou
notificar o Planejador a reagendar a entrega.

Os comportamentos selecionados para uma tarefa pelo Executivo formam a camada
Funcional. Esta camada é o nível mais baixo nesta arquitetura, conectando
diretamente sensores e atuadores. É neste nível que a teoria de controle
tradicional reside, como a implementação de controles PID, filtros de Kalman,
etc.

No exemplo do robô de escritório, alguns comportamentos possíveis para o robô
são: 1) mover a uma determinada localização, evitando obstáculos; 2) mover por
um corredor, evitando obstáculos; 3) achar uma porta; 4) achar maçaneta da
porta; 5) agarrar a maçaneta da porta; 6) girar maçaneta da porta; 7) atravessar
porta; 8) determinar localização; 9) achar número do escritório; 10) anunciar
entrega. Estes comportamentos combinam sensores (visão, distância por
infravermelho, e outros) a atuadores (motores das rodas, motores do manipulador
e outros).

A Tabela~\ref{3Ttable} resume os componentes desta arquitetura
híbrida.

\begin{table}[!ht]
\centering
\caption{Resumo da arquitetura de três camadas}
\label{3Ttable}
\begin{tabular}{|l|l|}
\hline
Sequenciador            & Executor                       \\ \hline
Gerenciador de recursos & Executor               \\ \hline
Cartógrafo              & Planejador                              \\ \hline
Planejador de missão    & Planejador                    \\ \hline
Monitor de desempenho   & Planejador \\ \hline
\end{tabular}
\end{table}

\paragraph{AUV Phoenix}
A arquitetura do AUV Phoenix foi destacada por ser um AUV e, portanto, ser uma
aplicação semelhante ao robô em destaque desta dissertação. São famosas
as arquiteturas Atlantis \cite{gat1991reliable}, sua evolução CLARAty
\cite{volpe2001claraty}, ambas desenvolvidas pela NASA, e o robô Stanley
(Stanford).

Em 1996, Healey \cite{healey1996autonomous}, California, aplicou técnicas de
controle híbrido em seu trabalho de desenvolvimento do AUV Phoenix.  Healey
propos uma arquitetura de software híbrida com três níveis organizacionais e
hierárquicos. Há um aumento de inteligência entre as camadas, do reflexivo,
ao procedural, para o deliberativo Figura~\ref{HEALEY_1}:

\begin{itemize}
  \item \textbf{Estratégico (planejador)}: utiliza Prolog como linguagem de
  controle de missão. Desenvolve os comandos que levam o veículo a executar determinada
  missão.
  \item \textbf{Tático (executivo)}: funções na linguagem C que faz interface
  com os predicados de Prolog e retorna variáveis booleanas (\emph{true,
  false}). Este nível funciona de maneira assíncrona e retém os dados da missão, além de se comunicar com o
  nível de execução.
  \item \textbf{Funcional}: controlador em tempo real do veículo, usando
  mensagens assíncronas. Opera os atuadores do veículo. 
\end{itemize}

O controle híbrido será responsável tanto pela movimentação do veículo, contínuo
e síncrono, quanto pela sequência lógica das fases das missões, eventos discreto
com transições assíncronas. A arquitetura incorpora detecção de erros e
procedimentos de recuperação. O módulo reativo é desenvolvido pela arquitetura
de subsunção.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/HEALEY_1.pdf}
\caption{Arquitetura do Robô Phoenix de Healey}
\label{HEALEY_1}
\end{figure}

\paragraph{Stanley}
Em 2006, Sebastian Thrun \cite{montemerlo2006winning} ganhou o desafio DARPA, em
uma competição de veículos autônomos organizada pelo governo dos Estados Unidos
a fim de promover o desenvolvimento na área de direção autônoma.

O robô Stanley foi desenvolvido pela Stanford University. É um veículo
(Volkswagen Touareg R5) Fora de estrada (\textit{Off Road}) autônomo de alta
velocidade, que ganhou o desafio de se locomover pela acidentada região do
deserto Mojave por mais de 132 milhas sem a interferência de um ser humano. Em
grande parte, o desafio DARPA é uma competição de software, pois um motorista
equipado com um carro apropriado consegue atravessar o deserto sem muitas
dificuldades.

O software desenvolvido é capaz de adquirir dados de sensores, construir modelos
do mundo e tomar decisões de direção a uma velocidade de 60 km/h. Neste robô,
foi utilizada a arquitetura híbrida de três camadas, como em Atlantis
(Figura~\ref{stanley})

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/stanley.jpg}
\caption{Arquitetura do Robô Stanley}
\label{stanley}
\end{figure}

\paragraph{CLARAty}
Em 2001, Volpe \cite{volpe2001claraty} desenvolve uma arquitetura híbrida de
duas camadas: Coupled Layer Autonomous Robot Architecture (CLARAty), como uma
evolução da arquitetura Atlantis, arquitetura de três camadas. De acordo com
Volpe, a arquitetura de três camadas apresenta algumas desvantagens: 

\begin{itemize}
  \item As responsabilidades e tamanho de cada nível é subjetivo ao criador da
  arquitetura. Portanto, há arquiteturas em que a camada funcional é dominante,
  outras em que a camada de planejamento domina.
  \item O acesso entre a mais alta camada da hierarquia (planejador) à camada de
  nível inferior (funcional) é restrita. Apesar de isso ser desejado durante
  execução, isto separa o planejador de informações da funcionalidade do sistema
  durante o planejamento. Uma consequência é que planejadores normalmente
  carregam seus modelos do sistema, que não são derivados (sentido de classe
  derivada, em programação como C++) diretamente do nível Funcional. Esta
  repetição de modelos pode gerar certas inconsistências. %TODO mostrar como
  % ocorre no DORIS
  \item Cada camada pode ter sua própria hierarquia com granularidade variada. A
  camada funcional é composta por vários subsistemas aninhados, o executivo tem
  árvores lógicas para coordená-los, e o planejador tem diversas linhas de tempo
  e horizontes.
\end{itemize}

De acordo com Volpe, a estrutura CLARAty tem duas vantagens principais:
representação explícita da granularidade das camadas (em uma representação 3D);
e a mistura das técnicas declarativas e processuais para a tomada de decisões.
%(figura~\ref{claraty}).

A camada funcional é uma interface com todo o sistema de hardware e suas
capacidades. É um software orientado a objeto, obtendo assim modularidade de
hardware, e estruturação apropriada de software para usar
as propriedades de herança, característica extremamente importante para o nível
funcional.

% \begin{figure}[!ht]
% \centering
% \includegraphics[width=.5\columnwidth]{figs/claraty.jpg}
% \caption{Arquitetura CLARAty}
% \label{claraty}
% \end{figure}

\subsection{Análise crítica} 
Continuando a analogia de robôs com o funcionamento de animais e,
especificamente o ser humano, a arquitetura híbrida visa juntar as duas
abordagens anteriores, deliberativa e reativa, e de forma inteligente
aproveitar as vantagens de ambas as arquiteturas e aproximar cada vez
mais o funcionamento das máquinas com o homem. Nesta arquitetura final, está
presente tanto o planejamento exercido pelo cérebro, quanto a camada reflexiva
da medula, buscando tornar o robô uma entidade completa (Figura~\ref{brain3}).

A grande dificuldade está em como será realizada essa fusão de arquiteturas,
qual será a maneira ótima e que garanta essas vantagens. A abordagem híbrida
evolui a cada ano e novos sistemas, como robôs aeroespaciais e carros
com direção autônoma, provam que esta arquitetura é eficiente.

A arquitetura híbrida é modular, pois é
dividida em camadas, as quais são subdivididas em módulos. O escopo de aplicação
é enorme se comparada às outras arquiteturas, como já foi apontado: 
veículo aeroespacial, carros autônomos, AUV e outras, e como é
possível particionar a arquitetura, pode-se utilizar apenas a área
deliberativa ou a reativa e englobar o escopo das duas arquiteturas anteriores.
Além disso, a arquitetura híbrida provê robustez, já que apresenta monitor de
desempenho e é capaz de adaptação e reconfiguração.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/brain3.jpg}
\caption{Analogia de sistemas reativos com o ser humano.}
\label{brain3}
\end{figure}


\section{Robotic Development Environments}

A tecnologia em robótica e o número de aplicações de robôs autônomos aumentaram
muito nos últimos anos, exigindo o desenvolvimento de softwares robustos, de
alta performance, de fácil uso e com possibilidade de simular modelos robóticos,
sensores e controle em ambientes virtuais. De acordo com
\cite{staranowicz2011survey}, os ambientes de desenvolvimento em robótica
evoluíram devido à emergente interação entre robôs e seres humanos, o que exige
grande robustez e simulação prévia, como em aplicações médicas, assistência em
ambientes nocivos, e outros. Dessa forma, a comunidade robótica reconheceu a
necessidade do desenvolvimento de softwares abertos para simulação e interface
em robótica.

As arquiteturas híbridas são, normalmente, decompostas em camadas, isto fica
explícito, por exemplo, na arquitetura de três camadas. Há linguagens e
softwares que visam ajudar na implementação de cada camada. Em seguida, são
abordados os softwares e linguagens para cada camada, analisando os
principais ambientes de desenvolvimento atuais, destacando vantagens e
desvantagens, e justificando a escolha do autor. 

\subsection{Camada Funcional}

Os componentes da arquitetura necessitam se comunicar entre si,
trocar dados e enviar comandos. A forma de comunicação entre componentes,
comumente chamada \textit{middleware}, é o cerne no desenvolvimento de uma RDE,
e é uma das mais importantes e restritivas decisões no projeto de uma
arquitetura robótica. De acordo com \cite{kortenkamp2008robotic}, durante o
desenvolvimento de arquiteturas, a grande maioria dos problemas e a maior parte
do tempo gasto em depuração (\textit{debugging}) está ligado à comunicação
entre os componentes. Há basicamente dois estilos de comunicação:
cliente-servidor (\textit{client-server}) e editor-subscritor
(\textit{publish-subscriber}).

Em um protocolo de comunicação cliente-servidor, componentes
falam diretamente com outros componentes. As vantagens deste protocolo são:
definição prévia da interface; e é uma abordagem distribuída para comunicação,
já que não há um módulo central que distribui os dados. Uma desvantagem deste
protocolo é o \textit{overhead}, que é significativo se muitos componentes
precisam de uma mesma informação.

Em um protocolo de comunicação \textit{publish-subscriber} (ou
\textit{broadcast}), um componente publica dados e qualquer outro componente
pode subscrever (ouvir) a esse dado. Normalmente, há um processo central que
roteia os dados entre \textit{publish} e \textit{subscriber}. Em uma arquitetura
típica, um componente pode publicar e subscrever a vários tipos de informações.
As vantagens desse protocolo de comunicação são: simplicidade e pouco
\textit{overhead}; ideal quando não se sabe quantos componentes diferentes
necessitarão dos dados (como em muitas interfaces); componentes não ficam
sobrecarregados em caso de múltiplos pedidos de um mesmo dado. Suas principais
desvantagens são: difícil de \textit{debug}, pois normalemente a sintaxe da
mensagem está escondida em uma simples \textit{string} (uma \textit{lista}
pode ser enviado como \textit{string} e o componente subscritor retraduz);
utilização de um servidor central que distribui as mensagens (recebe dos
\textit{publishers} e envia aos \textit{subscribers}), o que pode criar um único
ponto de falha e sobrecarga.

A utilização do protocolo de comuicação tipo \textit{publish-subscriber} já
aparecia em arquiteturas robóticas antes de Brooks. Em 1983, Elfes
\cite{elfes1983distributed} idealiza uma arquitetura em módulos e controle
distribuído a fim de atingir efetividade em processamento paralelo,
flexibilidade de interação com os diversos sensores, distribuir capacidades de
decisão e flexibilidade de expansão e modificação do sistema. O sistema de
comunicação entre módulos era centralizado e chamado de \textit{Blackboard}.

Em \cite{staranowicz2011survey} e \cite{kramer2007development}, foram realizadas
compilações de RDEs da camada Funcional, apontando suas vantagens, desvantagens,
aplicações e os tipos de comunicação. Neste trabalho, são destacados os dois
sistemas abertos mais populares: Player e ROS, e, por fim, é justificado a
escolha por ROS como o RDE da DORIS.

\subsubsection{Player}
Em 2001, Player/Stage \cite{gerkey2003player} foi projetado para ser uma
interface de programação, não um ambiente de desenvolvimento, focando em
programação de dispositivos (drivers) e sensores, em vez de robôs. Em Player, os
dispositivos são independentes entre si e são registrados em um servidor,
podendo ser acessados por clientes (programas de controle). Cada cliente usa uma
conexão com o servidor para transferência de dados, possibilitando operações
concorrentes. Múltiplos clientes podem subscrever a um mesmo dispositivo e podem
enviar comandos simultaneamente, porém não há fila, logo comandos antigos são
descartados. Stage, a segunda parte do software, é um simulador de dispositivo.

O objetivo de Player é a separação de interface e função. O fato de servidores
se comunicarem via soquete TCP/IP possibilita que clientes possam ser escritos
em qualquer linguagem de programação que possua esse suporte, por
exemplo Python, C++, Java e outros. Clientes podem operar em qualquer host que
possua conexão, possibilitando independência de localização.

\subsubsection{Robot Operating System - ROS}\label{ros}

ROS é um software aberto que provê camada de abstração de hardware (CAH -
hardware abstraction), controle baixo nível de dispositivos, mensagens entre
processos TCP/IP ou UDP, e gerenciamento de pacotes. Dentre todas, a mais
importante característica de ROS é a presença de uma grande comunidade de pesquisadores que
contribui para a expansão do software, que é possível, principalmente, pela
repositório disponível no website ROS. 

ROS, como o próprio autor \cite{quigley2009ros} salienta, não é um sistema
operacional (SO) no sentido tradicional de gerenciador de processos e
agendamento, mas apresenta algumas ferramentas semelhantes, como
mensagens entre processos. De acordo com o autor, a filosofia por trás do
desenvolvimento deo ROS pode ser resumida nos seguintes pontos:

\begin{itemize}
  \item Arquitetura de rede ponto-a-ponto (\textit{peer-to-peer}).
  \item Tools.
  \item Multi linguagens de programação.
  \item \textit{Thin}.
  \item Gratuito e aberto.
\end{itemize}

Um sistema desenvolvido em ROS é capaz de possuir diversos processos, em
diferentes hosts, conectados por uma topologia ponto-a-ponto, em tempo de
execução. Uma topologia com servidor central começa a se tornar problemática se
computadores são conectados por uma rede heterogênea. ROS necessita de um
mecanismo de busca para permitir que processos se encontrem em tempo de
execução, chamado \textit{service} ou \textit{master}. 

O sistema se comporta de maneira semelhante ao Player em relação à conexão por
soquete TCP/IP, possibilitando o uso de múltiplas
linguagens, como Python, C++, Octave e LISP.

Em ROS, pequenas \textit{tools} são usadas para construir e
executar os componentes, em vez de um grande monolítico ambiente de
desenvolvimento. As \textit{tools} realizam diversas tarefas, como navegar pela
árvore de código, obter e definir parâmetros, visualizar a conexão
ponto-a-ponto, medir a largura de banda utilizada, representar graficamente
dados, gerar automaticamente documentações, e outros.

A ideologia \textit{thin} de ROS é possibilitar que códigos, como drivers e
algoritmos, possam ser reutilizados em outros \textit{middlewares}, fora de ROS.
Alguns exemplos são algoritmos de visão de OpenCV, e algoritmos de planejamento
de trajetórias do OpenRAVE.

Os elementos fundamentais de ROS são nós, mensagens, tópicos e serviços.

Nós são processos ou módulos de software no código de controle, por exemplo um
nó \textit{camera} poderia processar todos os dados visuais. Os nós podem se
comunicar com outros nós por simples mensagens (de tipos \textit{integer},
\textit{floating point}, \textit{boolean}, \textit{strings} etc), que são
enviadas a um ou múltiplos tópicos (tipo \textit{strings}). Um nó interessado em
certo tipo de mensagem deverá subscrever ao tópico apropriado.
Pode haver múltiplos publicadores e subscritores concorrentes a um mesmo tópico.

Apesar de o modelo de comunicação do tipo editor-subscritor ser flexível,
sua rotina de \textit{broadcast} não é apropriada para transações síncronas.
Para trocas de mensagens síncronas em ROS, utiliza-se serviço (também
tipo \textit{string}) um par de mensagens: um para pedido, outro para resposta, análogo à URI de um web service.
A figura~\ref{roscomm} mostra os tipos de comunicação do sistema ROS.

\begin{figure}[!ht]
\centering
\includegraphics[width=.6\columnwidth]{figs/roscomm.jpg}
\caption{Tipos de comunicação so sistema ROS.}
\label{roscomm}
\end{figure}

A figura~\ref{rosarchitecture} é um resumo de todas as características
discutidas acima, mostrando como funciona o ambiente de desenvolvimento ROS. Há
um computador na base, rodando nós de ROS, e um computador embarcado no robô,
também rodando nós de ROS. Os componentes no robô são drivers que se comunicam
com os diversos hardwares do robô (sensores e atuadores), algoritmos para
processamento (de imagens e outros), e controladores dos atuadores do robô
(controle PID e outros). Na base, componentes mostram os status do robô para o
usuário e exercem a função de visualização. Está sendo representada tanto a comunicação tipo
\textit{service} (servidor-cliente), quanto a comunicação
editor-subscritor (\textit{broadcast}.

\begin{figure}[!ht]
\centering
\includegraphics[width=.8\columnwidth]{figs/rosarchitecture.png}
\caption{Arquitetura do ambiente de desenvolvimento ROS.}
\label{rosarchitecture}
\end{figure} 

As vanatagens da utilização de ROS no desenvolvimento de sistemas robóticos são
diversas, como comentado em \cite{dastani2013programming}. ROS é amplamente
utilizado como \textit{framework} para a camada funcional de uma arquitetura
híbrida. É um sistema flexível e que possui um repositório crescente de pacotes
de software no estado da arte. Esses pacotes fazem interface com diversos
hardwares robóticos, e algoritmos que realizam diferentes tarefas do robô, como
SLAM, processamento de imagem e etc. O acesso a este repositório facilita e
agiliza a prototipagem e o desenvolvimento de complexos sistemas robóticos.
Os módulos da camada funcional, nós de ROS, podem ser programados
em diferentes linguagens, como Python, C++ e Java. Os módulos podem ser
iniciados, interrompidos e reiniciados em tempo de execução, e se comunicam
entre si numa rede \textit{peer-to-peer}. Há duas formas de
comunicação entre módulos: o estilo síncrono servidor-cliente e o
assíncrono \textit{publisher-subscriber}. Além disso, ROS suporta simuladores
robóticos como Stage, Gazebo, MORSE e OpenRAVE.

\subsection{Camada Executivo}

Como já definido na subseção~\ref{3t}, a camada Executivo
usa técnicas de planejamento reativo para selecionar os comportamentos (nós, ou
componentes, em uma linguagem ROS) que entrarão em execução de uma biblioteca de
componentes existentes. Ela sequencia a execução dos componentes para a realização de um certo objetivo, monitora o
desempenho, traduz os planos de alto nível da camada Planejador em
tarefas, executando-os apropriadamente. Na arquitetura
implementada, a camada Executivo também aloca e monitora os recursos
(gerenciamento de recursos). 

Como já comentado na subseção~\ref{brooks}, apesar de possuírem inúmeras
vantagens, a arquitetura reativa possui problemas de \emph{situatedness} e
escala, os quais a camada Executivo deve se preocupar em resolver.

O problema de escala ocorre devido ao número de interconexões de uma arquitetura
reativa, o qual aumenta exponencialmente em relação ao aumento de
comportamentos.
Isto ocorre, pois um comportamento obtem os dados de outros através de
interconexões (um comportamento de nível 1 necessita estar interconectado a
outros de nível 0 para obter os seus dados). Este problema já havia sido
resolvido por uma arquitetura com comunicação do tipo \textit{blackboard} \cite{elfes1983distributed}, onde os dados dos sensores são
disponibilizados a todo os componentes, pois há um componente central que
armazena os dados e envia a todos que necessitam. Em ROS, a comunicação de
estilo \emph{publish-subscriber} resolve o problema, sem a necessidade de
implementação extra, já que todos os componentes podem ``ouvir'' os dados
publicados por outro componentes.

Alguns comportamentos devem ser executados apenas em situações específicas, não
durante todo o funcionamento do robô. O problema de \emph{situatedness} é a
execução de todos os comportamentos ao mesmo tempo, mesmo quando estes não são
necessários. Apesar de estarem sendo executados, não são percebidos na saída
do robô, pois estão sendo suprimidos por comportamentos de nível superior
(subsunção). O comportamento \emph{desvio de obstáculos}, por exemplo,
só faz sentido quando o robô está em movimento, e o comportamento \emph{toque
com manipulador} só fará sentido quando o robô está próximo de um equipamento. 

Outro problema da arquitetura de subsunção é a \emph{ciência da falha}
(\textit{cognizant failure}), isto é, comportamentos não sabem quando seus
processos estão em falha e continuam a execução sem resultados promissores. A
camada Executivo deve reportar a falha à camada Planejador (\textit{execution
monitoring}), e suspender sua execução (\textit{error recovery}).


O Sequenciador da camada Executivo é, normalmente, um controlador hierárquico de
máquinas de estados ou Redes de Petri \cite{peterson1981petri}. Algumas
linguagens foram desenvolvidas para ajudar programadores na implementação desta
camada: \textit{Reactive Action Packages} (RPAs) \cite{firby1987investigation},
\textit{Procedural Reasoning System} (PRS) \cite{georgeff1989decision},
\textit{Execution Support Language} (ESL) \cite{gat1997esl}, \textit{Task
Description Language} (TDL) \cite{simmons1998task}, \textit{Plan Execution
Interchange Language} (PLEXIL) \cite{verma2005plan}. Como a camada
Funcional foi desenvolvida em ROS, o autor optou por analisar camadas
Executivo integradas ao sistema ROS: Petri Net Plans (PNP)
\cite{ziparo2006petri}, e SMACH \cite{bohren2010smach}.

Todas as linguagens mencionadas provêem suporte à decomposição hierárquica de
tarefas e subtarefas, capacidades de expressar condicionais e iterações, e
suportam restrições temporais seriais ou paralelas entre tarefas (por exemplo,
tarefa B deve começar após 10s do término da tarefa A - serial). Com exceção de
PLEXIL, todas suportam recursividade de tarefas. Com exceção de TDL, as
linguagens provêem suporte explícito para codificação de pré e pós-condições de
tarefas e para especificação de critério de sucesso. ESL, PLEXIL e SMACH
suportam sinalização de eventos (avisam quando há transição de tarefas). ESL,
TDL, PNP e SMACH suportam terminação de tarefas baseado na ocorrência de eventos
(por exemplo, quando a tarefa B termina, A deve começar). As linguagens RAPs,
PRS e ESL incluem uma base de dados simbólica (modelo do mundo) que se conecta
aos sensores diretamente ou à camada Funcional, a fim de manter um modelo
síncrono do mundo. 

As linguagens lidam de maneira diferente em relação a monitoramento de execução
e recuperação de erros. ESL, TDL, SMACH e PNPs provêem monitoramento explícito
de tarefas, verificam erros com registros (como feito nas linguagens C++ e
Java), e suportam procedimentos de ``limpeza'', quando as tarefas são terminadas. RAPs e PLEXIL
retornam valores para indicar falha, e não possuem verificação de erros. PRS
suporta monitoramento da execução, mas não verificação de erros. ESL e PRS
provêem a noção de recursos compartilhados e gerenciamento de recursos.

Detalha-se, em seguida, as camadas Executivo integradas ao sistema ROS.

\subsubsection{Petri Net Plans (PNP)}

Petri Net Plans \cite{ziparo2011petri} é uma linguagem baseada em Redes de
Petri (\textit{Petri Nets} - PN), desenvolvida em 2006 com integração ao sistema
ROS. A linguagem permite o projeto de comportamentos intuitivos e eficientes
para multi-robôs. Suas principais características são a
possibilidade de concorrência e interrupção de tarefas, análise de planos
baseado em ferramentas padrão de PN, e o desenvolvimento de comportamentos de
maneira distribuída para multi-robôs garantindo coordenação e colaboração. O
autor do sistema comenta que PNP é a primeira abordagem sistemática e
metodológica para projetar planos baseados em PNs.

A grande vantagem da metodologia de projeto da camada Executivo em PNP é
a exploração das técnicas e ferramentas de análise de planos das PN. PNP é
introduzido como um subconjunto de PNs, baseando-se em primitivas de modelagem
de linguagens de ação inspirada por Situation Calculus \cite{mccarthy1969some},
como ConGolog \cite{de2000congolog}. A linguagem resultante é mais expressiva
que a maioria das abordagens na literatura, permitindo formas complexas de
sensoriamento, laços, interrupções, concorrência, coordenação e cooperação.
Comparando-se  com sistemas baseados em máquinas de estados (FSM), as PNs são
geralmente exponencialmente mais compactas, já que, por exemplo, uma PN finita
pode representar uma FSM infinita.

Dentre as diversas aplicações realizadas com PNP, destacam-se: um robô com rodas
usado para busca e missões de resgate; e quatro robôs AIBO utilizados para o
futebol de robôs.

Apesar das inúmeras vantagens, a linguagem ainda não foi utilizada em robôs
que exijam robustez. Além disso, a interface com ROS não é perfeitamente
estável, e ainda não é possível executar PNs em paralelo. A construção das
PNs ainda requer software externo independente (JARP).
 
\subsubsection{SMACH}\label{smach}

Em 2011, Bohren testa SMACH, camada Executivo, no robô PR2, integrado
ao sistema ROS~\cite{bohren2011towards}. PR2 é um robô planejado a executar uma
tarefa com grande repetição e robustez, em um ambiente bem definido, numa
aplicação que requer interação com o ser humano, e que há métricas de sucesso ou
falha: servir bebidas (isto é, localizar, manusear e entregar). O sistema é
completamente autônomo e integrou capacidades como: identificação dinâmica de
obstáculos, identificação de geladeiras, tipos de bebidas, e faces humanas.
Componentes de planejamento incluem: navegação, planejamento de movimentos
(\textit{Motion Planning}) para manipulador com objetivo e restrições de
trajetória, e módulos de \textit{grasping} (segurar objetos).

Há três tipos de componentes na arquitetura do PR2: 
\begin{itemize}
  \item \textit{subsistemas de propósito geral}: contêm códigos que não são
  específicos à aplicação e podem ser usados por outras. Exemplos: controle de
  \textit{grasping} de manipulador, controle de trajetória de manipulador,
  cinemática inversa de manipulador, controle de força e velocidade de
  manipulador, planejamento de trajetória não-holonômico, planejamento de
  trajetória holonômico, sensor laser, sensor das juntas do manipulador, sensor
  de áudio, e etc.
  \item \textit{código de aplicação específica}: representa a coleção de
processamento de dados de sensores e ações de alto nível que são particulares à
aplicação. Exemplo: camada Executivo, abrir porta, pegar bebida, fechar porta,
entregar bebidas, detecção de rostos, e outros.
  \item \textit{interface de usuário}. Exemplo: visualizador SMACH, RViz
  (visualizador integrado ao ROS), interface Web, e outros.
\end{itemize}

O PR2 utiliza um novo \textit{framework} de camada Executivo, o qual permite a
implementação de sequência de tarefas ``bem definidas'', isto é, a operação
nominal, modos de falha e sequências de recuperação de falhas podem ser
descritas explicitamente. O novo \textit{framework} é uma biblioteca
independente de ROS, desenvolvida em Python, chamada SMACH. SMACH provê
estruturas para geração procedural de programas baseados em máquinas de estado
concorrentes em hierarquia. Além disso, apesar de ser uma biblioteca
independente de ROS, provê módulos de integração como mensagens, tópicos e ações
\textit{actionlibs} de ROS.

SMACH pode ser usado para a construção e execução hierárquica de máquinas de
estado concorrentes (o formalismo pode ser encontrado em \textit{statecharts}
\cite{harel1987statecharts}). 

A) Características do SMACH

As características do sistema SMACH são aqui detalhadas, já que a implementação
da arquitetura da DORIS também utiliza SMACH como parte de sua camada
Executivo.

1) \textit{Structures} (Estruturas): há duas interfaces primárias definidas por
SMACH:

\begin{itemize}
  \item \textbf{\textit{State}} (Estado): uma interface para um objeto
  representando um \textit{state of execution} (estado de execução) com um conjunto potencial de
  \textit{outcomes} (resultados). \textit{States} só necessitam definir uma
  única função \textit{execute}, que o bloqueia até retornar um \textit{outcome}
  para aquele \textit{state}. \textit{Outcomes} de \textit{states} podem ser
  pensados como uma ``interface'' para um dado \textit{state} e devem ser
  definidos durante a construção. Um \textit{outcome} exemplo de um estado
  seria: \textit{succeeded} (sucesso), \textit{aborted} (abortado) ou
  \textit{preempted} (colocado em espera devido a nova tarefa).
  \item \textbf{\textit{Container}}: uma interface para um objeto representando
  uma coleção de um ou mais \textit{states}. \textit{Containers} definem
  diferentes políticas de execução baseadas em seus \textit{states} filhos e
  \textit{outcomes}.
\end{itemize}

O SMACH \textit{container} mais simples é o \textit{StateMachine} (Máquina de
Estado). Uma máquina de estado SMACH pode ser entendida como diagramas de fluxo
de estados, onde nós são estados em execução (o robô fazendo algo) e arestas
representam transições de um estado para outro via um \textit{outcome}. Estes
\textit{containers} podem ser compostos hierarquicamente e podem ter seus
próprios \textit{outcomes}. 

SMACH também provê um \textit{container} simples do
tipo \textit{split-join} (dividir-juntar), o \textit{Concurrence} (Concorrente).
Diferente do \textit{StateMachine}, que executa um \textit{state} por vez em
série, o \textit{Concurrence} executa mais de um \textit{state} simultaneamente.
Os \textit{outcomes} de um \textit{Concurrence} podem ser definidos em sua
construção. O \textit{Concurrence} padrão do SMACH só termina quando todos os
seus filhos terminam, mas isso pode ser configurado.

2) \textit{User Data} (dados do usuário): os planos construídos em SMACH
possuem certas capacidades não disponíveis em máquinas de estados
finitos formais. Cada \textit{container} SMACH tem um dicionário de escopo local
de dados de usuário que pode ser acessado por seus estados filho. Estados podem
armazenar e carregar dados desta estrutura em tempo de execução. Como os
\textit{outcomes}, estas entradas e saídas podem ser consideradas parte da
interface para um estado e devem ser declarados durante a construção.
\textit{Containers} podem, também, possuir entradas e saídas chave
(\textit{input and output keys}), a fim de mover dados entre escopos.

Apesar de esta característica deixar a análise dos estados mais complexa, ela
deixa o sistema muito poderoso. Ela permite que dados sejam passados entre
estados consecutivos, e, além disso, os dados podem ser acumulados por vários
estados de forma que estejam disponíveis, no futuro, a um ramo durante a
execução. Isto significa que um estado ``completo'' de uma árvore SMACH, em um
determinado momento, é a união dos estados ativos do nível de execução em cada
\textit{container} e os conteúdos de dicionários do \textit{user data} em cada
\textit{container}. A figura~\ref{container} mostra um \textit{container}
exemplo do SMACH, chamado \textit{SM\_TOP}, que possui dois estados \textit{FOO}
e \textit{BAR}, tal que as entradas do \textit{container SM\_TOP}
(\textit{input keys}) são recebidas pelo estado \textit{FOO}, os dados de saída
de \textit{FOO} são entradas do estado \textit{BAR} e os dados de saída de
\textit{BAR} são os dados de saída do \textit{container SM\_TOP}.

\begin{figure}[!ht]
\centering
\includegraphics[width=.8\columnwidth]{figs/container.png}
\caption{Container \textit{SM\_TOP} que possui dois estados e transições de
dados.}
\label{container}
\end{figure}

B) Prototipagem e visualizador

SMACH foi projetado para permitir prototipagem rápida e intuitiva de aplicações
robóticas. A biblioteca de interface SMACH-ROS provê a visualização, em tempo de
execução, dos planos criados em SMACH, o SMACH Viewer. O visualizador SMACH
renderiza a estrutura dos planos, realça os estados sendo executados em tempo real, e lista
os conteúdos do dicionário de dados para um dado \textit{container}. Esta
ferramenta permite ao desenvolvedor:
\begin{itemize}
  \item Descobrir pontos de falha e rapidamente adicionar novos estados que
  possam estimar a natureza da falha ou para recuperação.
  \item O SMACH Viewer é suficientemente intuitivo, de forma que o programador
  rapidamente encontra erros.
  \item A estrutura é bastante modular, logo os processos que são executados no
  robô podem ser divididos para múltiplos programadoress sem conflito.
  \item SMACH pode ser executado a partir de qualquer ponto do plano
  sem alteração no código.
  \item SMACH possui propagação de \textit{preemption}, isto significa que
  um pedido de cancelamento vindo do nível superior da árvore de execução atua
  no estado ativo e propaga a ação de cancelamento por todos os estados da
  folha, cancelando tarefas concorrentes de maneira segura.
\end{itemize}

C) Padrões de projeto (\textit{Design Patterns})

Padrão de projeto é uma solução geral reutilizável para um problema que ocorre
com frequência dentro de um determinado contexto no projeto de software. Uma
camada Executivo pode usar o \textbf{Sequenciador} hierárquico de máquinas de
estados do SMACH para estruturar um plano, mas este \textit{framework} não é uma
camada Executivo completa, pois há outras responsabilidades desta camada
(seção~\ref{3t}). SMACH utiliza padrões de projeto de ROS para suprir a
responsabilidade de monitoramento de execução.

1) Coordenação de dados: os estados em SMACH podem ser ações do tipo
\textit{actionlibs}, implementadas no ambiente ROS. Esse tipo de ação recebe uma
mensagem objetivo e retorna mensagens de resultados e status
(\textit{succeeded, aborted e preempted}).

2) \textit{Preemption} mútua e monitoramento de tópicos: \textit{containers}
concorrentes podem ter diversas políticas de terminação definidas como funções
de terminação. Um padrão de projeto é o \textit{preemption} mútuo de duas
tarefas concorrentes, útil quando o término de uma ação deveria causar o término
de outra.

D) Aplicações

Além da demonstração de desempenho na utilização de SMACH em PR2
\cite{bohren2011towards}, há outros sistemas que já fazem uso desta camada
Executivo. A dissertação de mestrado \cite{Kolbe2013} implementa
uma camada Planejador em cima de SMACH. O \textit{Deutsches
Forschungszentrum für Künstliche Intelligenz} (DFKI), um dos maiores institutos
sem fins lucrativos de pesquisa no campo de inovação de tecnologia de software e
robótica baseado em métodos de inteligência artificial, desenvolveu um robô
móvel autônomo de dois braços, AILA \cite{lemburg2011aila}, que usa SMACH como
camada de nível Executivo. E já há outros sistemas que se baseiam na filosofia
SMACH, como em \cite{wachsmuth2012tobi}.

\subsection{Camada Planejador}

Na subseção~\ref{3t}, o Planejador é definido como uma camada composta pelo
planejador de missão e o cartógrafo. A camada determina as
atividades do robô de longo prazo baseada em objetivos de alto nível. Enquanto a camada Funcional
possui responsabilidades de com o aqui e agora, e a camada Executivo
com o que acabou de acontecer e o que deve acontecer depois, a camada Planejador
olha para o futuro. Nesta subseção, aborda-se as RDEs voltadas para a camada
Planejador, como elas funcionam internamente, e destaca-se o Rapyuta, uma
camada Planejador visionária que está sendo integrada ao ambiente ROS.

De acordo com \cite{kortenkamp2008robotic}, as duas abordagens mais comuns são o
planejador de rede de tarefas hierárquicas (\textit{hierarchical task net} - HTN) e o planejador/agendador. Os HTN, como o
O-Plan (\textit{The open planning architecture}\cite{currie1991plan}) e
o SHOP (\textit{simple hierarchical ordered planner})\cite{nau1999shop},
decompõem tarefas em subtarefas de uma maneira similar às camadas Executivo. A
diferença é que os HTN operam em um alto nível de abstração, usam a
informação dos recursos disponíveis, e
possuem métodos de lidar com conflitos entre tarefas (tarefas que necessitam do
mesmo recurso, ou uma tarefa negando uma pré-condição necessária por outra tarefa). A base de conhecimento do robô é o
arquivo (dicionário) de tarefas.

O planejador/agendador, como em \cite{chien2000using} e
\cite{muscettola1998remote}, são úteis em aplicações onde tempo e recursos são
limitados. A camada Planejador cria planos de alto nível que agenda quando
tarefas devem ocorrer, mas tipicamente deixa ao Executivo a responsabilidade de
determinar exatamente como alcançar os objetivos. Planejador/agendador organizam
as tarefas e os recursos do robô cronologicamente e com prazos a fim de evitar
conflitos (motores, energia, comunicação e outros). A base de conhecimento do
robô inclui os objetivos das tarefas, os recursos necessários, suas durações, e
restrições entre tarefas.

\subsubsection{Rapyuta} 

Rapyuta é a \textit{RoboEarth Cloud Engine}, uma
Plataforma como serviço (\textit{Platform-as-a-Service} - PaaS) de código
aberto, serviço de hospedagem e implementação de hardware e software, usado para
prover aplicações por meio da internet e projetado especificamente para
aplicações robóticas. A grande motivação é o número cada vez maior de robôs
saindo do ambiente industrial para o ambiente doméstico e praticando tarefas
caseiras (como servir bebidas, dobrar toalhas e outras). Algumas tarefas
domésticas, no entanto, exigem grande poder computacional, e os computadores
embarcados cada vez consomem mais bateria, restringindo a mobilidade do robô,
reduzindo tempo de operação e aumentando os custos. A computação interna do
robô pode ser reduzida se algumas computações que não exijam tempo real puderem
ser realizadas na núvem, como planejamento de segurar objetos (\textit{grasp
planning}), mapeamento, e navegação.

Rapyuta é um projeto que busca resolver os desafios de construir uma plataforma
robótica em núvem. O \textit{framework} é baseado em um modelo de computação
elástico \cite{hu2012cloud} que aloca dinamicamente ambientes de computação
segura para robôs. Esses ambientes de computação são interconectados, permitindo
que robôs compartilhem dispositivos e informações entre si, tornando Rapyuta uma
plataforma para multi-robôs. Além disso, os ambientes de computação provêem
acesso com banda larga ao RoboEarth, repositório de conhecimento, permitindo que
robôs tenham conhecimento da experiência de outros robôs. Os robôs podem
submeter e pegar dados do repositório RoboEarth, e ainda processar
planejamentos dentro da ferramenta.

Rapyuta é compatível com ROS, o que permite a execução de todos os pacotes de
código aberto disponíveis em ROS.
