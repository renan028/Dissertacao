\chapter{Revisão Bibliográfica}

A modelagem de robôs de acordo com suas principais funcionalidades e o
desenvolvimento de novas arquiteturas são o âmago no estudo de
controle de missão de robôs móveis. Dessa forma, arquitetura robótica e controle
de missão são conceitos relacionados, e, portanto, o cerne desta pesquisa
bibliográfica.

Neste capítulo, são apresentados os fundamentos teóricos necessários para o
entendimento desta dissertação. O objetivo deste levantamento bibliográfico é
apresentar alguns dos principais trabalhos e pesquisas científicos sobre
arquiteturas e sistemas de controle de missão de robôs móveis. Por fim,
o leitor é direcionado para os ambientes de software desenvolvidos para robôs
autônomos (\textit{Robotic Development Environments} - RDEs).

O conceito de arquitetura %do grego arkhétékhton, do ingles architecture, do
% frances architecture
para robôs é definido de diferentes formas na
literatura. Em \cite{arkin1998behavior}, arquitetura de robô é
relacionada com arquitetura de software, em uma adaptação à
arquitetura de computadores de \cite{stone1980introduction}, e definida como:
arquitetura de robô é a disciplina dedicada ao projeto de robôs altamente
específicos e individuais a partir de uma coleção de blocos comuns de softwares.
Em \cite{mataric1992behavior}, a definição aborda sistemas de controle: uma
arquitetura fornece uma maneira principal de organizar um
sistema de controle, contudo, a arquitetura também impõe restrições sobre a
forma como o problema de controle pode ser resolvido. Já
em \cite{brooks1986robust}, o autor tenta associar a arquitetura de software
com os componentes de hardware (processadores) para compor a arquitetura
robótica.

O sistema robótico é composto por diversos elementos de hardware e
software que são interdependentes e necessários para o funcionamento do sistema.
Como o propósito deste trabalho é o desenvolvimento de uma arquitetura robótica
para o DORIS, sendo considerados os aspectos físicos, lógicos e a aplicabilidade do
robô, entende-se que uma arquitetura para robô móvel descreve uma maneira de se construir o
controle inteligente do robô, os módulos do sistema, como estes
módulos interagem entre si e seus elementos de hardware associados, visando sua
aplicação. A evolução das arquiteturas apresentadas nesta revisão
bibliográfica mostra que os elementos de hardware assumem um papel de grande
importância durante o desenvolvimento dessas arquiteturas, por exemplo como um
fator limitador, assim como a aplicação e o meio em que o robô está inserido.

De acordo com \cite{siegwart2004autonomous}, os componentes básicos de uma
arquitetura para robôs são classificados em três grupos: \textit{Percepção}, que
envolve as atividades de interpretação e integração dos sensores;
\textit{Planejamento} de tarefas, sincronização,
e o monitoramento da execução de todas as atividades do robô; \textit{Atuação},
que envolve as atividades de execução dos movimentos, ações do robô e controle
dos atuadores.

As três primeiras seções desta pesquisa bibliográfica abordam os paradigmas da
robótica, isto é, as três arquiteturas de operação de um sistema robótico:
paradigma hierárquico/deliberativo (SPA - \emph{Sense, Plan and Act}); paradigma
reativo; e paradigmo híbrido deliberativo/reativo. As seções apresentam e
exemplificam as arquiteturas pela ótica de diversos autores, e são
comparadas e analisadas.

%TODO: acrescentar mais uma referência (arkin?)
O controle de missão (\textit{Mission Control System} - MCS) ou planejamento de
missão (\textit{Mission Planning}) ou planejamento de tarefas (\textit{Task Planning})
de robôs faz parte da arquitetura robótica, e pode ser desenvolvido para os
três tipos de arquiteturas. Em \cite{fryxell1996navigation}, o conceito é bem
introduzido como: controle de missão é um sistema que permite ao operador
definir as missões de um veículo em linguagem de alto nível; provê ferramentas adequadas para converter planos em
Progamas de Missões que podem ser verificados e executados em tempo real; e
permite ao operador saber o estado da missão enquanto esta é executada, e
modificá-la se for necessário. Em \cite{brumitt1996dynamic}, o conceito de
planejamento de missão é ampliado para múltiplos robôs: planejamento de missão
é o processo de determinar o que cada robô deve fazer para alcançar, de uma
maneira conjunta, os objetivos da missão, em um ambiente dinâmico.

Neste trabalho, o controle de missão de robôs é o componente da arquitetura
robótica que organiza e executa todas as tarefas do robô de maneira ótima,
exerce o papel de traduzir os comandos de missão do usuário ao robô, provê feedback ao
operador (\textit{execution monitoring}), e contém as diretivas do robô. Como
faz parte da arquitetura, as seções que seguem buscam, em cada arquitetura, destacar de forma exemplificada
alguns controles de missão. 

A robô DORIS é um robô móvel com aplicação de inspeção em um ambiente não
muito dinâmico. Apresenta missões semelhantes a um AUV, apesar de sua dinâmica
ser bem mais simplificada, já que este se move ao longo de um trilho.
Entretanto, como a aplicação (inspeção) é igual, os hardwares são equivalentes
por ser um robô móvel com vários sensores, e alguns desafios são comuns, é de
se esperar que a arquitetura robótica possa apresentar muitas semelhanças. Desta
forma, durante a apresentação das arquiteturas, será sempre destacada uma
arquitetura em AUV.

\section{Paradigma hierárquico/deliberativo}
Em meados do século XX, são realizados os primeiros estudos de robôs autônomos,
juntamente com o aparecimento da Inteligência Artificial (IA). Em um sistema
robótico, a IA clássica consiste em um modelo centralizado que coleta
informações usando sensores, cria um modelo do ambiente, planeja o próximo
movimento e executa a ação. São sistemas do tipo \emph{Sense, Plan and
act} (SPA). Essa arquitetura de controle é clássica e tem abordagem
\emph{top-down} (hierárquica), como na decomposição tradicional,
figura~\ref{hierarquica}.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/Hierarchical.png}
\caption{Arquitetura hierárquica tradicional.}
\label{hierarquica}
\end{figure}

De acordo com Marvin Minsky, uma máquina (robô) deveria tender a criar, por si
só, um modelo abstrato do ambiente em que está inserido (define-se
\emph{mundo}).
Caso fosse dado uma tarefa, ela primeiro poderia explorar soluções dentro de seu modelo abstrato e, então,
experimentá-las externamente. Seria como realizar uma simulação interna
e, caso funcionasse, realizá-la no mundo real.

\subsection{Robôs deliberativos}
Entre 1966 e 1972, Charles Rosen e Nils Nisson da Universidade de Stanford
criaram o Shakey, primeiro robô móvel autônomo (figura~\ref{SHAKEY_1}). Foi
desenvolvida uma inteligência artificial, \textit{problem solver}, chamada
STRIPS. Este sistema é um planejador de trajetórias que armazena as imformações
do ambiente (mapas e obstáculos) de maneira simbólica, e se dada uma tarefa de
deslocamento (\textit{goto}), é realizada uma busca lógica pelo sistema. 

Em 1977, começou a ser desenvolvido o projeto HILARE (figura~\ref{hilare}), no
Laboratoire d'Automatique et d'Analyse des Systèmes (LAAS), Toulouse, France.
O robô possuía sensores como câmera, ultrassons e laser para medir
distância, sendo possível atualizar o seu mundo com acurácia. Seu mundo era
representado por modelos geométricos e um modelo relacional que expressava a
conectividade dos quartos e corredores (simbólico) \cite{norelis1989control}.

Também em 1977, o Stanford Cart foi criado por Moravec para navegação e desvio
de obstáculos \cite{moravec1977towards}. Os obstáculos eram identificados pelo
robô durante a operação e representados em seu mundo interno como
esferas. O robô possuía uma segunda representação do mundo, simbólica por
grafos.

Em 1969, Victor Scheinman, Universidade de Stanford
\cite{scheinman1969design}, inventou o primeiro manipulador robótico
totalmente elétrico de seis elos e com solução completa e integrada de
cinemática inversa. Isto é, dado um ponto qualquer pertencente ao espaço de
trabalho do manipulador, este calcula o ângulo das juntas de forma que o
efetuador alcance o ponto especificado. Isso permitiu que o manipulador
percorresse trajetórias arbitrárias. Até os dias atuais, 2015, é ampla a
utilização de manipuladores industriais. A sofisticação destes sistemas já
possibilita que estes armazenem todo o conhecimento do mundo e executem tarefas
autônomas (figura~\ref{manipulador}).

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/SHAKEY_1.png}
\caption{Shakey robot}
\label{SHAKEY_1}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/HILARE.jpg}
\caption{HILARE}
\label{hilare}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/MANIPULADOR.jpg}
\caption{Manipulador robótico atual}
\label{manipulador}
\end{figure}

%TODO: Verificar controle de missão dos modelos
\subsection{Arquiteturas deliberativas}
As arquiteturas deliberativas são sistemas hierárquicos com a lógica
\textit{SPA}. São utilizados em sistemas robóticos até hoje, quando a aplicação
favorece seu uso e o poder computacional não é uma restrição.
Destacam-se os modelos de Albus, NASREM, o \emph{Intelligent Mobile
Robot System}, MARIUS (AUV).

\subsubsection{Modelo de Albus}

Albus foi o pioneiro e mais influente autor de teorias em arquiteturas
deliberativas, \cite{albus1991outline}. Sua grande contribuição foi a
formalização e definição de diversos termos amplamente utilizados em automação e controle. Dentre outros, destaca-se o
teorema de que há quatro sistemas que compõem a inteligência: processamento de
sensores, modelo do mundo, geração de comportamentos e julgamento de valor. As
entradas desses elementos são os sensores e suas saídas são os atuadores:

\begin{itemize}
  \item Atuadores: as saídas de um sistema inteligente pe produzida por
  atuadores, como mover, posicionar braços, pernas, mãos, olhos e etc. Os
  atuadores naturais são os músculos e as glândulas, já os atuadores de máquinas
  são motores, pistões e válvulas.
  \item Sensores: são as entradas de um sistema inteligente, como sensores de
  força, torque, posição, velocidade, vibração, acústico, gases, temperatura e
  muitos outros. Monitoram o mundo e o estado interno do sistema, e provê dados
  ao sistema de processamento sensorial.
  \item Processamento sensorial: sistema que compara novas observações com a
  expectativa interna do modelo do mundo. Integra e armazena as diferenças e
  semelhanças encontradas, a fim de reconhecer padrões, objetos e relações no
  mundo.
  \item Modelo do mundo: é a melhor estimativa que o sistema inteligente possui
  do mundo, e atualizado pelo processamento sensorial. É um banco de dados com
  todo o conhecimento do mundo e contém uma capacidade de simulação que gera expectativas e predições. O modelo do mundo
  pode prover informações do passado, presente e prevê estados futuros.
  Os dados são importantes para: o gerador de comportamentos escolher o plano
  adequado para execução das ações; o processamento sensorial fazer correlações,
  comparação de modelos, e reconhecimento de objetos, estados e eventos; e o
  sistema de julgamento de valor computar valores de custo, benefício, risco,
  incerteza, importância e outros.
  \item Julgamento de valor: este é o sistema que determina o que é bom ou ruim,
  importante ou trivial, certo ou improvável. Computa custos, riscos e
  benefícios de situações observadas e atividades planejadas.
  \item Gerador de comportamentos: elemento que seleciona objetivos e planos,
  executa e monitora ações, e modifica planos existentes quando alguma situação
  do mundo exigir. Tarefas são decompostas em subtarefas, e subtarefas são
  sequências de objetivos. A ordem lógica de funcionamento é: o gerador de
  comportamentos cria planos, o modelo do mundo predita o resultado do plano, e
  o julgamento de valor avalia os resultados. O gerador de comportamento
  seleciona o plano com a avaliação mais alta.
\end{itemize}

As relações entre os elementos do sistema inteligente estão representados na
figura~\ref{albus}.  Esses elementos e suas relações possibilitaram a criação de
diversas arquiteturas.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/albus.pdf}
\caption{Arquitetura de Albus para sistemas deliberativos.}
\label{albus}
\end{figure}

Vale ressaltar que, nesta arquitetura, o \textit{gerador de comportamentos} faz
o papel do controle de missão, porém não de maneira completa, já que a
interação com o usuário ainda é precária.

\subsubsection{NASREM}
O NASREM \cite{albus1989nasa} foi uma arquitetura utilizada pela
NASA e possuía uma arquitetura com seis níveis de
funcionalidade (figura~\ref{nasrem}):

\begin{enumerate}
  \item Servo: provê o controle dos atuadores do robô (posição, velocidade e
  etc).
  \item Primitiva: determina as primitivas de movimento para gerar trajetórias
  suaves.
  \item Movimento elementar: define e planeja trajetórias livre de colisões.
  \item Tarefa: converte ações desejadas de um objeto em sequências de
  movimentos elementares.
  \item Compartimento de serviços: converte ações de grupos de objetos em
  tarefas de um objeto.
  \item Missão: decompõe o plano de missão em alto nível em compartimento de
  serviços.
\end{enumerate}

Vale ressaltar que, no modelo NASREM, o operador tem acesso a qualquer nível
hierárquico do robô e pode tomar o controle do robô para si, além de poder
substituir as entradas de sensores, modelo do mundo e outros. Dessa forma, o
nível de autonomia do robô pode ser desenvolvido de forma incremental.

A arquitetura hierárquica proposta em NASREM permite modularidade e propõe uma
metodologia de software.  
 
\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/NASREM.pdf}
\caption{Arquitetura NASREM.}
\label{nasrem}
\end{figure}

\subsubsection{\textit{Intelligent Mobile Robot System}}
Em 1991, Saridis \cite{wang1991petri} cria o \emph{Intelligent Mobile
Robot System} (IMRS) baseado na teoria de inteligência hierárquica de controle
\cite{saridis1988analytical}. Saridis utiliza redes de Petri como módulos
básicos da arquitetura para traduzir os comandos gerados pelo nível de
organização em algo compreensível para o nível de execução.

O IMRS possui a seguinte arquitetura (figura~\ref{Saridis_1}):
\begin{itemize}
  \item Nível organizacional (organizador de tarefas): gera tarefas de
  movimentação de alto nível.
  \item Nível de coordenação: funciona como uma interface entre o nível
  organizacional e o de execução. O nível é composto por um remetente e alguns
  coordenadores. O remetente recebe o plano da tarefa do organizador, decompõe a
  tarefa em ações de controle e remete aos coordenadores. Os coordenadores
  traduzem os comandos de controle em instruções de operação e transmite ao
  nível de execução.
  \item Nível de execução: executa a instrução proveniente do nível de
  coordenação e reporta seus resultados a ele.
\end{itemize}

O nível de coordenação do IMRS é composto por um remetente
(\emph{Dispatcher}) e três coordenadores: sistema de visão (VS), desvio de
obstáculo e controle de rastreamento (OATC), e planejamento de trajetórias (PP).
Com o modelo de redes de Petri não é possível implementar o esquema de linguagem de
decisão para descrever a tradução de tarefas entre remetente e coordenadores.
Portanto, os \emph{Petri Net Transducers} (PNTs) foram introduzidos como
tradutores de linguagem (protocolo): $PNT = (N,\Sigma,
\Delta, \sigma, \mu, F)$. Onde:
\begin{itemize}
	\item A rede de Petri $N=(P,T,I,O)$, $P$ lugares, $T$
transições, função de entrada $I$, função de saída $O$, é o controle da
tradução;
	\item $\mu$ é o estado inicial de $N$;
	\item $\Sigma$ é o alfabeto de entrada, representa tarefas de entradas;
	\item $\Delta$ é o alfabeto de saída, representa tarefas de saída; 
	\item $\sigma$ especifica, para uma dada tarefa de entrada, as transições em
$N$ e as subtarefas de saída que podem ser usadas na tarefa;
	\item $F$ é o estado final. Indica o fim da tradução da tarefa;
\end{itemize}    

Os quatro PNT's são combinados para realizarem a tradução de tarefas no Nível
de Coordenação: remetente, sistema de visão, desvio de obstáculo
e controle de rastreamento, e planejamento de trajetórias. 
%Será brevemente descrito o componente Remetente (\emph{Dispatcher}) do modelo
% de Nível de Coordenação para melhor entendimento do PNT.

%Foram definidas quatro tarefas para o Nível de Coordenação: 1) \emph{wmu}:
%atualização da memória 3-D do ambiente; 2) \emph{mod}: detecção de objetos em
%movimento; 3) \emph{pp}: planejamento de trajetórias; 4) \emph{moac}: desvio de
%obstáculos e controle de rastreamento. A figura~\ref{Saridis_2} mostra o modelo
%de rede de Petri para o Remetente.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/SARIDIS_1.pdf}
\caption{Arquitetura de Saridis}
\label{Saridis_1}
\end{figure}

A modelagem do sistema utilizando redes de Petri proporcionaram algumas
funcionalidades essenciais em uma arquitetura robótica: a capacidade de executar duas tarefas simultaneamente, por
exemplo, movimentação e planejamento de trajetórias; e o \emph{Input Semaphore},
que impede um processo de ser executado até outro ser finalizado.
  
Saridis salienta os benefícios das PNT:
\begin{itemize}
  \item Redes de Petri podem ser usadas como módulos básicos para sistemas de
  controle de missão de robôs móveis.
  \item A comunicação e conexão de módulos são eficientes entre redes de Petri.
  \item Controle e mecanismo de comunicação para coordenação de tarefas de um
  robô móvel podem ser realizados com redes de Petri.
\end{itemize} 

A arquitetura de Saridis é uma contribuição importante por criar um nível
organizacional, separando o nível do desenvolvedor de baixo nível e um
nível de alto nível para um operador (usuário). Além disso, as redes de Petri
assumem um importante papel como módulo básico de controle para seu sistema
IMRS. As redes de Petri foram originalmente introduzidas para descrever as
comunicações de máquinas de estado finito (FSM), possibilitando flexibilidade
e robustez, e é provado que redes de Petri são uma excelente ferramenta para
modelagem de sistemas, sobretudo quando envolvem tarefas conflitantes ou
simultâneas \cite{murata1989petri}.

\subsubsection{MARIUS}
Em 1996, Silva et al. \cite{oliveira1996design} (Institute for Systems and
Robotics, Lisboa) projetaram, desenvolveram e testaram um sistema de controle de missão para o
MARIUS, robô autônomo submarino. O trabalho de Silva introduz novos e
importantes conceitos chave para o MCS: Tarefa do Sistema (\emph{System Task}), Primitiva do
Veículo (\emph{Vechicle Primitive}), Procedimento de Missão (\emph{Mission Procedure})
e Programa de Missão (\emph{Mission Program}). Além disso, a arquitetura do
veículo, por ser um AUV, possui sistemas e interconexões
semelhantes ao robô DORIS, estudo desta dissertação.

\textbf{Tarefa do Sistema} (ST): é a especificação paramétrica de uma classe
de algoritmos ou processos que implementam uma funcionalidade básica em um robô.
Requer a implementação de dois módulos: \textit{i}) um \emph{módulo Funcional}
que contém um determinado algoritmo e processo, e transfere dados com outras
Tarefas do Sistema e dispositivos físicos; \textit{ii}) um \emph{módulo
Comando}, máquina de estado finito, que recebe comandos externos, produz
mensagens de saída, e controla a seleção de algoritmos, processos, e caminhos
dos dados para/de módulos Funcionais.

A arquitetura do MARIUS é descrita abaixo, figura~\ref{SILVA_1}:
\begin{itemize}
  \item \emph{Vehicle Support System} (VSS) - Controla a distribuição de energia
  aos hardwares instalados no veículo, monitora consumo de energia e detecta
  falhas de hardware, podendo enviar comandos de emergência.
  \item \emph{Actuator Control System} (ACS) - Controla a velocidade de rotação
  dos propulsores e posição dos ailerions e lemes. Os \emph{Set Points} dos
  atuadores são dados pelo \emph{Vehicle Guidance and Control System} (VGCS) e
  os dados dos atuadores são transmitidos para o \emph{Mission Control System}.
  \item \emph{Navigation System} (NS) - Estima posição linear e velocidade do
  veículo, orientação e velocidade angular. O sistema funde informações do
  \emph{Positioning System} (\emph{Long Baseline unit}) e \emph{Motion Sensor
  Integration System}, o qual inclui diversos sensores. As saídas do NS são
  entradas do VGCS, e enviadas ao MCS.
  \item \emph{Vehicle Guidance and Control System} (VGCS) - Recebe como entrada
  as trajetórias de referência pelo MCS, e os dados de navegação do NS. Suas
  saídas são \emph{Set Points} para velocidade de rotação e outros atuadores do
  ACS, tal que o veículo siga a trajetória desejada mesmo com incertezas e
  distúrbios.
  \item \emph{Communication System} (COMS) - Controla o link bidirecional usado
  pelo operador para passar missões ao MCS, e pelo veículo para passar status de
  missão ou estados do veículo.
  \item \emph{Environmental Inspection System} (EIS) - Coleta dados do ambiente
  com diversos sensores (inclusive câmeras), como temperatura, pressão, pH. É
  controlado pelo MCS.
  \item \emph{Data Logging System} (DLS) - Adquiri e armazena dados do veículo.
  \item \emph{Mission Control System} (MCS) - Sequencia e sincroniza a execução
  das tarefas básicas do veículo para uma determinada missão e provê a
  recuperação em caso de falhas.
\end{itemize}

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/SILVA_1.pdf}
\caption{Arquitetura do Veículo MARIUS}
\label{SILVA_1}
\end{figure}

Como pode ser visto, a arquitetura é dividida em um nível organizacional, um
coordenador e um nível funcional.

Silva desenvolveu os softwares CORAL e ATOL para implementação das VPs e STs em
redes de Petri de forma que um usuário final, como um operador, pudesse
facilmente criar seus MPs. A grande contribuição  


\subsection{Análise crítica}
A abordagem deliberativa simula, de certa forma, o processo de planejamento e
tomada de decisão do ser humano. Há um núcleo (cérebro) que
processa todos os dados sensorias e armazena o mundo, isto é, o ambiente em que
o robô está inserido, de maneira simbólica, geométrica ou outros tipos de
mapeamento. Além disso, o núcleo planeja todas as ações para uma determinada
tarefa, consultando sua ideia de mundo intensivamente. Há, também, sensores que
enviam suas novas informações periodicamente para o núcleo, (órgãos receptivos:
visão, olfato, e etc), atualizando o mundo. E há atuadores (músculos)
necessários para a realização das tarefas (figura~\ref{brain}).

É fácil observar que a arquitetura deliberativa é dependente do
modelo de mundo armazenado e suas atualizações periódicas. Portanto, a
utilização da abordagem deliberativa em ambientes extremamente dinâmicos pode ser muito
custosa devido às atualizações e ao replanejamento. Além disso, é fácil observar
que a arquitetura SPA dificulta a criação de sistemas em tempo real eficientes.
Dessa forma, robôs móveis em ambientes muito dinâmicos, como o carro autônomo da
google (figura~\ref{googlecar}), não são aplicações favoráveis para esta
arquitetura.

O controle de missão é presente em arquiteturas deliberativas, mas de maneira
primitiva, normalmente possuindo apenas as funcionalidades de: quebrar as
missões em tarefas menores que o robô possa executar, gerenciar as tarefas, e
monitoramento interno. Entretando, peca no desenvolvimento da interface com o
usuário, a possibilidade de alteração de tarefas em tempo de
execução, e feedback ao operador em tempo real.

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/brain.jpg}
\caption{Comparativo da arquitetura deliberativa com o ser humano.}
\label{brain}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/googlecar.jpg}
\caption{Projeto da google 2011- para o desenvolvimento de um carro autônomo.}
\label{googlecar}
\end{figure}

\section{Paradigma reativo}

Sistemas de arquitetura reativa também são chamados de sistemas baseados em
comportamentos. Os robôs são programados para agir através de ativação de uma
coleção de comportamentos primitivos de baixo nível. De acordo com
\cite{arkin1995reactive}, as principais características de sistemas puramente
reativos são:

\begin{itemize}
  \item Comportamentos são como elementos construtivos: são um par sensor-motor,
  onde o sensor provê informação necessária para o motor executar uma ação
  reativa, como desvio de obstáculo, atrair-se a objetivos, escapar de
  predadores e etc.
  \item Não há criação ou manutenção precisa do modelo do mundo. Os sistemas
  reagem ao estímulo do mundo, extremamente útil para mundos dinâmicos e
  hostis.
  \item Comportamentos de animais são normalmente utilizados para modelar esses
  sistemas.
\end{itemize}

Dessa forma, controle reativo é uma técnica que une percepção e ação,
tipicamente no contexto de comportamentos motores, para produzir respostas
robóticas em tempo real em mundos dinâmicos e não estruturados.

Em 1986, um dos primeiros estudos em sistemas reativos foi desenvolvido por
Rodney Brooks \cite{brooks1986robust}. Este estudo é a base para diversos
trabalhos atuais que envolvem robôs reativos móveis. Os desafios de
robôs autônomos apontados por Brooks e que ainda ilustram os problemas da
atualidade são: \emph{múltiplos objetivos}, \emph{múltiplos sensores},
\emph{robustez} e \emph{extensibilidade}. De acordo com Brooks, esses desafios
não são suportados pela arquitetura tradicional (paradigma hierárquico) de um
sistema de controle.

Os múltiplos objetivos de robôs móveis podem:
\begin{itemize}
  \item Ser conflitantes: por exemplo, um robô pode estar tentando alcançar um
  determinado ponto no espaço, porém evitando obstáculos locais.
  \item Ter relações de prioridade: por exemplo, um robô que inspeciona trilhos
  de trêm deve sair dos trilhos ao ouvir o sinal de um trêm chegando, mesmo se estiver
  finalizando a operação.
  \item Ser denpendentes: objetivos de \emph{alto nível} englobam diversos
  objetivos de \emph{baixo nível}. No caso do exemplo acima, o robô que sai do
  trilho para evitar o trêm deve se manter equilibrado para não cair. Artigos
  recentes, como em \cite{fryxell1996navigation} separam esses objetivos em
  \emph{tarefas} (objetivos de \emph{alto nível}) e \emph{primitivas do veículo}.
\end{itemize}

Robôs são normalmente providos de múltiplos sensores e suas diversas
informações podem ser redundantes, conflitantes ou complementares,
podendo ser utilizadas para uma mesma tarefa do robô.
Por exemplo, encoders para odometria e câmeras fixas ao robô
podem ser utilizados para localização, de forma que se complementem.
Os sensores podem apresentar erros ou resultados conflitantes, portanto a fusão
da informação de múltiplos sensores, a determinação de seus graus de
confiabilidade e em quais tarefas devem ser considerados são decisões que o
robô deve saber fazer.

Um robô deve ser robusto, isto é, em caso de falha de um sensor, o robô
deve se adaptar e utilizar os outros sensores que ainda funcionam para realizar as
tarefas. Ou em caso de alterações no ambiente, o robô deve ser
capaz de cumprir determinadas funções essenciais.

A extensibilidade constitui em acrescentar mais sensores e,
portanto, aumentar a capacidade do robô, sendo possível a execução de novas
tarefas. Porém, esta afirmação é normalmente criticada por alguns autores já que
existe um limite imposto pelo processamento do robô, já que um novo hardware
(sensor) é adicionado, mas o processamento (computador) não é substituído e sua
capacidade não é aumentada.

Brooks propõe um dos primeiros sistemas baseados em comportamentos, uma
arquitetura que tem como objetivo descentralizar a tomada de decisão de um
modelo central, como pode ser visto na figura~\ref{BROOKS_1}. O autor comenta
que essa decomposição conduz a uma arquitetura radicalmente diferente para
sistema de controle de robôs móveis em estratégias de implementação a nível de
hardware e com grandes vantagens em robustez, desenvolvimento e teste.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_1.pdf}
\caption{Arquitetura para sistema de controle de robôs móveis por Brooks}
\label{BROOKS_1}
\end{figure}

\subsection{Robôs reativos}
Antes mesmo de Brooks, ou seja, antes da formalização de toda a teoria em
sistemas reativos, simples robôs eram criados na lógica de controle reativo e de
comportamentos. Em 1953, por exemplo, Grey Walter \cite{holland1997grey}
desenvolveu uma ``tartaruga'' elétrica capaz de se movimentar pelo ambiente,
evitando luz intensa (``ameaças'') e atraída por certos objetivos. Vale
observar a característica de perceber baixo nível de bateria e procurar
uma estação de recarga, comportamento que se sobrepõe aos outros. Os
comportamentos são simples e não há representação abstrata do mundo:
dirigir-se para luz fraca; fugir de luz forte; e evitar obstáculos
(figura~\ref{turtle}).

Em 1984, veículos simples e puramente reativos com os pares clássicos
sensor-motor foram desenvolvidos pelo psicologista Braitenberg
\cite{braitenberg1986vehicles}, a fim de simular sentimentos, como covardia,
agressividade e outros (figura~\ref{Braitenberg}). 

Em 2002 até os dias atuais, o robô iRobot Roomba ganha destaque comercial e
executa uma simples tarefa doméstica: limpar o chão. Em sua arquitetura, o robô
Roomba possui apenas algumas funções reativas, como esquivar-se e locomover-se,
e, em suas versões antigas, foi constatado que não possui o modelo do mundo,
mapa, dentro de si \cite{tribelhorn2007evaluating} (figura~\ref{roomba}).

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/turtle.jpg}
\caption{A tartaruga de Grey Walter.}
\label{turtle}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/Braitenberg.jpg}
\caption{Veículos de Braitenberg.}
\label{Braitenberg}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/roomba.jpg}
\caption{Robô comercial Roomba da iRobot.}
\label{roomba}
\end{figure}

\subsection{Arquiteturas reativas}
As arquiteturas reativas foram formalmente introduzidas em 1986 por
Roodney Brooks. O roboticista, futuro fundador da empresa iRobot, vivenciou uma
época de processadores lentos e de alto custo, dificultando o uso de diversos
sensores e a armazenagem do modelo do mundo no robô. Simulações de tarefas,
atualizações do mundo e análise de sensores como câmeras eram extremamente
complexas para robôs e impossíveis de serem executadas em tempo real. Brooks
vislumbrou como solução o processamento paralelo, evitar o uso de um modelo do
mundo e criar módulos puramente reativos, pares sensor-motor, que juntos compõem
o robô. 

O sistema de controle de arquiteturas reativas utilizam informações locais
do meio, obtidas pelos sensores do robô. Estas são simplificadamente tratadas,
de forma que a ação ao estímulo é tomada rapidamente e, assim, os robôs reativos
podem responder de forma mais rápida a variações do ambiente. A arquitetura
define como a informação é mapeada em uma ação e como é feita a coordenação dos
pares estímulo-ação (comportamentos reativos).

De acordo com Arkin \cite{arkin1998behavior}, há duas classes predominantes
para a função de coordenação: competitiva e cooperativa.

Um conflito ocorre quando dois ou mais comportamentos estão ativos ao mesmo
tempo e possuem respostas diferentes. Nesse caso, a coordenação de forma
competitiva entra em ação, escolhendo um dos comportamentos para a ação final do
robô. A prioridade de um comportamento sobre os demais pode ser definida
explicitamente em uma hierarquia entre os comportamentos, ou pode haver uma
votação por uma ação, ou outros métodos. O exemplo de sistema reativo com
coordenação do tipo competitiva é o desenvolvido por Brooks, arquitetura de
subsunção.

Na arquitetura cooperativa, a ação do robô é a fusão da resposta de todos os
comportamentos ativos. A arquitetura reativa esquema motor de Arkin é um exemplo
claro deste tipo de coordenação, onde cada comportamento influencia o movimento
do robô por meio de um vetor de força artificial e a ação resultante é
determinada pela soma vetoria de todos os vetores de força.


\subsubsection{Arquitetura de subsunção}
A arquitetura de subsunção é, neste trabalho, destacada, exemplificada e
minuciosamente comentada, já que sua lógica será o cerne da implementação da
camada reativa da DORIS.

Na figura~\ref{BROOKS_1}, Brooks define \emph{Níveis de competência}, que são
classes de comportamentos desejados para o robô sobre todos os ambientes que ele
pode encontrar. As classes definidas por Brooks são:
\begin{enumerate}
\setcounter{enumi}{-1}
  \item Evitar contato com objetos (estacionários ou móveis);
  \item Vaguear sem rumo e sem bater em objetos;
  \item Explorar o ambiente utilizando sensores, definir lugares alcançáveis, e
  seguir rumo em suas direções;
  \item Construir um mini-mapa do ambiente e planejar trajetórias de um lugar
  para outro;
  \item Observar mudanças no ambiente;
  \item Raciocinar sobre o ambiente em termos de objetos identificáveis e
  realizar tarefas relacionadas a certos objetos;
  \item Formular e executar planos que envolvam mudar o estado do ambiente como
  desejado;
  \item Raciocinar sobre o comportamento de objetos no ambiente e modificar
  planos quando necessário;
\end{enumerate}

Cada nível de competência inclui, como subconjunto, os
níveis de competência anteriores.

Após a decomposição na nova arquitetura, Brooks define as \emph{Camadas de
Controle}, correspondentes a cada nível de competência. A ideia dessa abordagem
é adicionar camadas de controle a níveis de competências superiores sem precisar
alterar a camada do nível inferior. Inicia-se, portanto, com a camada de
controle para o nível zero de competência, esta será testada e não mais
alterada. Após, é criada a camanda de nível 1, capaz de examinar os dados
da camada de nível 0 e injetar dados nas interfaces internas deste nível,
suprimindo seu trânsito de dados, figura~\ref{BROOKS_2}.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_2.pdf}
\caption{Camadas de controle de Brooks}
\label{BROOKS_2}
\end{figure}

A camada de controle nível zero deve garantir que o robô não entre em contato
com outros objetos, estacionários ou móveis. Portanto, o robô deve desviar de
objetos que se aproximam ou parar se houver um objeto fixo em sua trajetória. A camada de controle nível 1, combinada a camada de controle nível 0, permite
 que o robô vagueie sem colisões. A figura~\ref{BROOKS_4} mostra o sistema de
 controle aumentado pelo nível da camada 1. 

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/BROOKS_4.pdf}
\caption{Nível 0 e 1 de controle do sistema}
\label{BROOKS_4}
\end{figure}

A estrutura das camadas de controle foram construídas por um conjunto de
pequenos processadores que enviam mensagens uns para os outros. Cada processador
é uma máquina de estado finito. A nova arquitetura e essa nova estrutura de
camadas com eventos discretos foram a base de diversos sistemas de controle de
missão da atualidade. A fim de melhorar o entendimento desse sistema criado
por Brooks, serão apresentados dois níveis de seu controle em uma aplicação de robô
móvel.

A nova arquitetura de Brooks é robusta, permite interações dinâmicas, é flexível
para integrar novas funcionalidades, em camadas superiores, e fácil para
implementar e debugar.
Brooks ainda associa sistemas de eventos discretos no controle de robôs autônomos,
utilizando como módulos básicos máquinas de estados finitos (FSM - \emph{Finite
State Machine}). Como a conexão de diversas FSM's não é uma FSM, a solução
encontrada por Brooks foi acrescentar inibidores e supressores em suas
FSM, chamando-as AFSM (\emph{Augmented Finite State Machine} ou máquina de
estado aumentada, figura~\ref{afsm}). Porém, o modelo hierárquico dos níveis
cria uma certa inflexibilidade nos níveis inferiores.

\begin{figure}[!ht]
\centering
\includegraphics[width=.6\columnwidth]{figs/afsm.jpg}
\caption{Módulo básico da arquitetura de subsunção (AFSM).}
\label{afsm}
\end{figure}

Apesar dos pontos positivos, a arquitetura de controle de um sistema
baseado em comportamento apresenta problemas com escala e contextualização
(\emph{situatedness}). 

O problema com escala é resultado das interconexões, que
podem crescer de maneira fatorial em relação ao número de comportamentos. 
A contextualização é um problema de sistemas de subsunção, onde subsistemas são
incluídos em um sistema mais amplo. Todos os comportamentos estão operando
ao mesmo tempo e anulando as saídas de outros comportamentos, de forma que
apenas uma é a saída do veículo. Portanto, há computação ineficiente.

Apenas em 1996, Bellingham e Consi \cite{bellingham1994second}
propuseram um controle por camadas (\emph{Layered Control}) a fim de resolver o
problema de escala. Há um módulo de processamento de sensores que
disponibiliza os dados aos comportamentos, resolvendo o problema de
interconexões, já que antes as camadas superiores deveriam se conectar às
inferiores para obter os dados dos sensores. Porém, Bellingham não resolveu o
problema utilizando uma arquitetura do tipo subsunção: as camadas são associadas
com um número de prioridade, de forma que saídas conflitantes são resolvidas
com esse número. Esta solução pode gerar uma certa inflexibilidade, visto que
que a adição de um novo comportamento pode alterar toda a estrutura de
prioridades previamente estabelecida.

A solução para o problema de contextualidade só foi resolvido em 2000 por Bennet
\cite{bennett2000behavior}. No \emph{State Configured Layered Control} (SCLC),
múltiplos conjuntos de comportamentos simples são escolhidos de uma biblioteca
de comportamentos e são executados em cada fase da missão. A vantagem é o
número reduzido de comportamentos executados ao mesmo tempo. Esta é
uma estratégia comum em arquiteturas de controle híbrido. 

\paragraph{O AUV Eric}
Desenvolvido pelo Key Center Robotics Laboratory, University of Technology,
Sydney \cite{boswell1994using}, o AUV Eric segue a arquitetura de subsunção
desenvolvida por Brooks com alguns avanços. Foram desenvolvidos três níveis de
competência, que descrevem a capacidade do sistema: nível de preservação, nível
de exploração e nível de socialização. O nível de preservação realiza o desvio
de obstáculos, a exploração executa navegação de alto nível, e a socialização
habilita o comportamento de seguir objetos.

\subsubsection{Arquitetura Esquema Motor}\label{motorscheme}
Em 1987, Arkin \cite{arkin1987aura} utiliza a teoria de esquemas (psicologia)
proposta por \cite{arbib1992schema} para desenvolver sua função de coordenação
cooperativa para sistemas reativos, chamado de Esquema Motor. Neste sistema, as
respostas dos comportamentos aos estímulos são representadas por vetores
(magnitude e orientação) e a coordenação é alcançada pela adição dos vetores,
produzindo um vetor resultante. Não há hierarquia pré-definida entre
comportamentos, todos os comportamentos ativos contribuem
para a saída do sistema com sua resposta individual (vetor) e ganho
associado. O ganho do vetor (ou peso) é um parâmetro para dar flexibilidade,
possibilidade de aprendizado e adaptação do robô caso este não seja fixo.


Em uma tarefa de navegação, é fácil imaginar como funciona o método do Esquema
Motor. São definidos alguns esquemas motor (comportamentos), como mover-se em
direção ao objetivo, evitar obstáculos, desviar, escapar, e outros, e cada
comportamento responde com um vetor que representa velocidade (magnitude) e
direção (orientação) que o robô deve seguir. A soma dos vetores resulta
na direção e velocidade final do robô. Ao perceber um obstáculo, por
exemplo, os vetores do comportamento \textit{desvio de obstáculos} possuem
magnitude superior aos outros e orientação para fora do obstáculo (vetor de
repulsão), de forma que o robô executa o desvio, em vez de colidir.

Assim como a arquitetura de subsunção, no Esquema Motor, os esquemas agem de
maneira distribuída, paralela e são modulares. O sistema apresenta vantagem em
relação à arquitetura de camadas por sua dinâmica, já que os esquemas podem ser instanciados e desinstanciados a
qualquer momento, e fácil reconfiguração. Apesar do importante e atraente
resultado em tarefas de navegação, os esquemas motores dominaram apenas esse
nicho da robótica e, mesmo neste nicho, outras tarefas normalmente não são
executadas com esta arquitetura.

\subsection{Análise crítica}
Se a abordagem deliberativa simulava o processo de planejamento e tomada de
decisão do ser humano, os sistemas de arquitetura reativa simulam outra
importante função da medula espinhal, pertencente ao nosso sistema nervoso
central: o circuito reflexivo, ou arco reflexo. O reflexo é uma resposta
involuntária rápida, consciente ou não, originado de um estímulo externo e
realizada antes mesmo de o cérebro tomar conhecimento do estímulo periférico.

Dessa forma, não há planejamento, não há modelo de mundo, apenas uma reação ao
estímulo. Esse comportamento é extremamente importante e necessário para a
sobrevivência do ser humano. Por exemplo, quando encostamos a mão em
uma panela quente, temos a reação imediata de retirar a mão sem intervenção do
cérebro, sem replanejamento, cujo processamento levaria tempo suficiente para
causar danos severos. É fácil, portanto, perceber que tais comportamentos são
necessários a robôs.

Robôs simples, como por exemplo um robô para limpar trilhos de trêm, ou robôs
para limpar o chão, podem ter o custo reduzido e executar extraordinariamente
bem suas tarefas sem a necessidade de planejamento e modelos complexos do mundo.
Durante a execução de sua tarefa, um robô limpador de trilhos só precisa saber
que é necessário sair do trilho ao avistar um trêm, logo basta um par
estímulo-motor e uma supressão de tarefa (no caso, a tarefa de continuar
limpando o trilho). Os grandes motivadores do aparecimento da
arquitetura reativa foram as aplicações simples para alguns robôs e a baixa
capacidade dos processadores da época.

Não é comum na literatura encontrarmos controle de missão em arquiteturas
reativas e é comum alguns autores se referirem a esses robôs como
\textit{non-taskable systems}, isto é, sistemas que não é possível atribuir
tarefas. Não há interface com o usuário, mas sim com o programador, que deve
alterar comportamentos a fim de gerar uma nova tarefa ou aplicação.

A tabela~\ref{comparativa} mostra a compração das arquiteturas analisadas até
agora.

\begin{table}[!ht]
\centering
\caption{Tabela comparativa de arquitetura deliberativa e reativa}
\label{comparativa}
\begin{tabular}{ll}
\hline
\multicolumn{1}{|l|}{Arquiteturas deliberativas}                                                   & \multicolumn{1}{l|}{Arquiteturas reativas}                                                            \\ \hline
Modelo interno completo e preciso                                                                  & Informações sensoriais locais                                                                         \\
Planejamento                                                                                       & \begin{tabular}[c]{@{}l@{}}Ações pré-definidas às informações \\ sensoriais\end{tabular}              \\
\begin{tabular}[c]{@{}l@{}}Maior flexibilidade na definição de \\ tarefas e objetivos\end{tabular} & \begin{tabular}[c]{@{}l@{}}Sistemas mais dedicados às tarefas \\ e problemas específicos\end{tabular} \\
\begin{tabular}[c]{@{}l@{}}Resposta lenta às mudanças no \\ ambiente\end{tabular}                  & \begin{tabular}[c]{@{}l@{}}Resposta rápida às mudanças do \\ ambiente\end{tabular}                   
\end{tabular}
\end{table}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/brain2.jpg}
\caption{Analogia de sistemas reativos com o ser humano.}
\label{brain2}
\end{figure}

\section{Paradigma híbrido ou deliberativo/reativo}

Arquiteturas deliberativas e reativas apresentam vantagens e
desvantagens e que muitas vezes se opõe. Por exemplo, é muito ineficiente
utilizar uma arquitetura deliberativa em um ambiente extremamente dinâmico,
assim como é ineficiente utilizar arquitetura reativa em uma linha de montagem
(manipuladores industriais). É natural pensar que integrando, de alguma forma,
as duas arquiteturas, formando uma arquitetura híbrida, será possível absorver
as vantagens de ambas.

Atualmente, os robôs com arquitetura híbrida predominam. Em muitas
aplicações de robôs móveis mais complexas, fica claro que formas de conhecimento
do mundo na arquitetura robótica permitem que a navegação dos robôs seja mais
flexível, eficiente e geral. A arquitetura híbrida tenta combinar os
métodos simbólicos da IA e seu uso de representação abstrata do modelo do mundo,
mas mantem o objetivo de prover robustez, resposta em tempo real e flexibilidade
dos sistemas puramente reativos. Arquiteturas híbridas podem permitir a
reconfiguração de controles reativos baseado no conhecimento do mundo através da
sua capacidade de raciocinar sobre os componentes comportamentais subjacentes.

O principal problema no paradigma híbrido é em como desenvolver uma
metodologia unificada de arquiteturas que garantem um sistema capaz de executar
planos de uma maneira robusta, como a arquitetura reativa, e, ao mesmo tempo,
ter um entendimento de alto nível da natureza do mundo e um modelo da intenção
do usuário.  

\subsection{Robôs híbridos}
Entre 1986 e 1987 \cite{arkin1989mobile}, Arkin foi o primeiro a criar uma
arquitetura híbrida e implementar em um robô. O onjetivo do robô era reconhecer
o ambiente de trabalho, planejar uma trajetória e navegar até o ponto desejado,
evitando obstáculos estáteis e móveis (figura~\ref{george}).

Em 1996, o AUV com arquitetura híbrida Phoenix, desenvolvido em Naval
Post-graduated School, Monterey, foi testado em Moss Landing
California \cite{brutzman1996nps}, figura~\ref{phoenix}.  

Desde 2003 com o Spirit até os dias atuais com Opportunity e Curiosity
(figura~\ref{curiosity}, a NASA vem desenvolvendo robôs de alta tecnologia,
com grande robustez de hardware e software.

\begin{figure}[!ht]
\centering
\includegraphics[width=.3\columnwidth]{figs/georgerobot.jpg}
\caption{Robô George.}
\label{george}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/phoenix.jpeg}
\caption{O AUV Phoenix.}
\label{phoenix}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/curiosity.jpg}
\caption{Robô Curiosity, o robô da NASA explorador do planeta Marte.}
\label{curiosity}
\end{figure}

\subsection{Aquitetura híbrida}
Em \cite{arkin1998behavior}, Arkin aponta quatro possíveis estratégias para o
projeto de arquiteturas híbridas:

\begin{itemize}
  \item Seleção: o planejador é visto como um configurador. O planejador
  determina a composição de comportamentos e parâmetros usados durante a
  execução. O planejador pode reconfigurá-los quando necessário devido a falhas
  no sistema.
  \item Conselho: o planejador é visto como um aconselhador. O planejador sugere
  mudanças que o controle reativo pode ou não usar.
  \item Adaptação: o planejador é visto como um adaptador. O planejador
  continuamente altera os componentes reativos ativos de acordo com as mudanças
  nas condições do mundo e requisitos de tarefas.
  \item Adiamento: o planejador é visto como um recurso para ser usado em último
  caso. Neste caso, os planos só são elaborados quando necessários.
\end{itemize}

Em \cite{murphy2000introduction}, Murphy afirma que apesar de arquiteturas
híbridas variarem em como a função deliberativa (o planejador) atua no sistema,
os componentes implementados em uma arquitetura híbrida são semelhantes,
possuindo geralmente os seguintes módulos:

\begin{itemize}
  \item Sequenciador: agente que gera o conjunto de comportamentos a serem
  usados para completar uma subtarefa, e determina qualquer sequência e
  condições de ativação. A sequência é normalmente representada como uma rede de
  dependências ou FSMs, mas o sequenciador gera essa estrutura ou ou
  dinamicamente a adapta.
  \item Gerenciador de recursos: agente que aloca recursos aos comportamentos.
  Este agente está diretamente ligado aos sensores do robô, podendo verificar
  qual o sensor é mais adequado para cada situação do robô. 
  \item Cartógrafo: agente responsável por criar, armazenar e atualizar o mapa,
  modelo do mundo.
  \item Planejador de missão: agente que interage com o usuário, traduz a
  mensagem do usuário para os termos do robô, e contrói um plano de missão. Por
  exemplo, um robô ``assistente'' poderia receber o comando ``Robô, traga um
  xícara com café''. O planejador de missão interpreta o comando de forma que
  primeiro o robô deve procurar uma xícara, servir café (supondo que este já
  esteja pronto) e, então, levá-lo até o usuário.
  \item Monitor de desempenho e solucionador de problemas: é o agente que
  permite ao robô perceber se está progredindo no cumprimento de sua tarefa.
\end{itemize}

Neste trabalho, são destacadas arquitetura híbridas Autonomous Robot
Architecture (AuRA), AUV Phoenix, CLARAty e Stanley.

\subsubsection{AuRA}

A Autonomous Robot Architecture (AuRA) foi a primeira arquitetura
híbrida, desenvolvida em 1986 por Arkin \cite{arkin1987aura}. De acordo com
Murphy \cite{murphy2000introduction}, AuRA pertence ao estilo de arquitetura híbrida \textit{administradora}
(\textit{Managerial}), reconhecida por sua decomposição similar a um
gerenciamento de negócios. Há agentes superiores que realizam planejamento em
alto nível e passam o plano a subordinados, os quais refinam os planos e coletam
os recursos, e, então, estes são passados ao último nível de agentes, os
comportamentos reativos. De acordo com Arkin, AuRA é um projeto de arquitetura
com estratégia de Seleção.

AuRA é composto por cinco subsistemas, dos quais dois pertencem à porção
deliberativa: Planejador e Cartógrafo, o subsistema de sensores, subsistema de
gerenciador de comportamentos (gerenciador esquema motor) e o subsitema de
controle homestático.

O planejador é responsável pela missão e
o planejamento de tarefas e é subdividido em três componentes: planejador da
missão, navegador e piloto e seus módulos são executados sequencialmente, tornando-se mais específico e detalhado.
A lógica é hierárquica: o planejador de missão envia trechos da missão ao
navegador, o qual envia trechos de trajetória para o piloto, que determina ações
ao controlador de baixo nível. O planejador de missão também funciona como
interface ao usuário. A utilização do mapa interno do robô por cada módulo é
diferente, enquanto o planejador usa o mapa global, o piloto recebe informações
locais. Vale observar que, quando o modelo do mundo é atualizado, muitas vezes
não há necessidade de o planejador atualizar toda a missão e recomeçar o ciclo
de planejamento, o piloto pode recalcular a trajetória local. Por exemplo, o
navegador recebe as tarefas: ``vá até a montanha até a torre da água, siga o
caminho até o acampamento'', e o piloto recebe a primeira subtarefa ``vá até a
montanha ae a torre da água'' e as informações necessárias para gerar os
comportamentos.

O Cartógrafo encapsula todo o mapa e tem a funcionalidade de receber mapas a
priori (operador pode fornecer um mapa inicial). Os três componentes do
planejador interagem com o Cartógrafo para obter a trajetória a seguir, quebrada
em segmentos.

O subsistema do AuRA que gerencia comportamentos utiliza a arquitetura
reativa esquema motor. O esquema motor, como visto na subseção
\ref{motorscheme}, representa cada ação em campos potenciais (vetores) e a resposta do sistema é a
soma dos vetores. 

O controle homeostático, quinto subsistema, está no meio do caminho entre os
sistemas deliberativos e reativos. Sua função é modificar a relação entre
comportamentos, modificando os ganhos do vetores (subseção \ref{motorscheme}).
Considere o seguinte exemplo, para melhor entendimento deste subsistema: um
veículo (robô) operando, no planeta Marte em um amabiente rochoso, têm como
tarefa remover fisicamente amostras de rochas de várias localidades pelo planeta
e levá-las a um veículo de retorno, o qual tem uma data fixa de lançamento. O
robô é provido com ganhos padrões em seus comportamentos, os quais produzem uma
execução conservadora da operação, por exemplo garantindo que o robô esteja
sempre 2 metros de distância dos obstáculos em seu caminho. No começo da missão,
a execução conservadora parece razoável, mas agora considere próximo à data
limite de decolagem do veículo de retorno: se o robô estiver próximo ao veículo
de decolagem, ele deveria cortar caminhos, reduzindo sua margem de evitar
obstáculos para realizar a entrega, sacrificando sua própria existência para a
missão.

AuRA poderia integrar o controle homeostático à parte deliberativa da
arquitetura, mas foi motivado pela biologia a colocá-lo em outra área, o qual
chama de subconsciente, o qual em animais modifica sempre a área consciente em
resposta a necessidades internas. A figura~\ref{aura} mostra os cinco
subsistemas da arquitetura AuRA. A tabela~\ref{auratable} resume a arquitetura.


\begin{table}[!ht]
\centering
\caption{Resumo da arquitetura AuRA}
\label{auratable}
\begin{tabular}{|l|l|}
\hline
Sequenciador            & Navegador, Piloto                       \\ \hline
Gerenciador de recursos & Gerenciador esquema Motor               \\ \hline
Cartógrafo              & Cartógrafo                              \\ \hline
Planejador de missão    & Planejador de Missão                    \\ \hline
Monitor de desempenho   & Piloto, Navegador, Planejador de missão \\ \hline
\end{tabular}
\end{table}


\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/aura2.pdf}
\caption{Arquitetura AuRA.}
\label{aura}
\end{figure}  

\subsubsection{Arquitetura de três camadas}
De acordo com Murphy, esta arquitetura pertence ao estilo Estado-hierárquico por
ser organizado em três camadas baseadas no estado de conhecimento: Planejador,
Executivo e Funcional. A arquitetura de três camadas é a mais aplicada em robôs
de grande complexidade , como AUVs e robôs do desafio DARPA (GRACE e Stanley).
Para melhor entendimento das funções das três camadas, será utilizado o exemplo
empregado em \cite{kortenkamp2008robotic}: considere um robô de entregas em
escritório, operando em um ambiente conhecido (mapeado).

O planejador é uma camada composta pelo planejador de missão e o
cartógrafo. O planejador de missão gera objetivos e planos estratégicos, e
os repassa para a camada intermediária, chamada Executivo. O cartógrafo é
responsável por armazenar e atualizar o modelo do mundo, além de poder prover
diferentes modelos para as diferentes funções do robô, a fim de otimizar a
execução. A componente planejador olha para o futuro.
 
No exemplo do robô de escritório, a componente de planejamento analisa as
entregas do dia, verifica os recursos do robô, atualiza o mapa, determina as
melhores rotas de entrega e agendamento, quando o robô deve se recarregar, e
replanejar quando necessário, por exemplo, quando um escritório estiver
fechado, o robô deve alterar o agendamento para realizar a entrega mais tarde.

A camada Executivo utiliza técnicas de planejamento reativo para selecionar um
conjunto de comportamentos de uma biblioteca de comportamentos, e desenvolve uma
rede de tarefa \textit{task network} especificando a sequência de execução para
os comportamentos a um subobjetivo particular. De acordo com Murphy, o Executivo
seria a camada responsável por sequenciar e monitorar o desempenho de uma
arquitetura híbrida. Ele é responsável por traduzir os planos de alto nível da
camada Planejador em comportamentos de baixo nível, chamando estes na hora
apropriada. É possível que a camada Executiva aloque e monitore os recursos,
substituindo esta função do Planejador.

No exemplo do robô de escritório, uma tarefa de alto nível seria entregar uma
carta a um escritório. O executivo deveria decompor esta tarefa em subtarefas,
deve usar um planejador de trajetórias geométrico para determinar a sequência de
corredores ao qual deve passar e interseções que deve virar, anunciar que a
pessoa tem uma carta e monitorar se a pessoa pegou a carta. Se a pessoa não
receber a carta depois de um determinado tempo, uma falha deve ser acionada, e
uma ação de recuperação deve ser tomada, como anunciar novamente à pessoa ou
notificar o planejamento a reagendar a entrega.

Os comportamentos selecionados para uma tarefa pelo Executor formam a camada
Funcional. Esta camada é o nível mais baixo nesta arquitetura, conectando
diretamente sensores e atuadores. É neste nível que a teoria de controle
tradicional reside, como a implementação de controles PID, filtros de Kalman e
etc.

No exemplo do robô de escritório, alguns comportamentos possíveis para o robô
são: 1) mover a uma determinada localização, evitando obstáculos; 2) mover por
um corredor, evitando obstáculos; 3) achar uma porta; 4) achar maçaneta da
porta; 5) agarrar a maçaneta da porta; 6) girar maçaneta da porta; 7) atravessar
porta; 8) determinar localização; 9) achar número do escritório; 10) anunciar
entrega. Estes comportamentos combinam sensores (visão, distância por
infravermelho, e outros) a atuadores (motores das rodas, motores do manipulador
e outros).

A tabela~\ref{3Ttable} resume os componentes desta arquitetura
híbrida.

A arquitetura do AUV Phoenix foi destacada por ser um AUV e, portanto, ser uma
aplicação semelhante ao robô em destaque desta dissertação. São famosas
as arquiteturas Atlantis \cite{gat1991reliable}, sua evolução CLARAty
\cite{volpe2001claraty}, ambas desenvolvidas pela NASA, e o robô Stanley
(Stanford).

\begin{table}[!ht]
\centering
\caption{Resumo da arquitetura de três camadas}
\label{3Ttable}
\begin{tabular}{|l|l|}
\hline
Sequenciador            & Executor                       \\ \hline
Gerenciador de recursos & Executor               \\ \hline
Cartógrafo              & Planejador                              \\ \hline
Planejador de missão    & Planejador                    \\ \hline
Monitor de desempenho   & Planejador \\ \hline
\end{tabular}
\end{table}

\paragraph{AUV Phoenix}
Em 1996, Healey \cite{healey1996autonomous}, Calfornia, aplica técnicas de
controle híbrido em seu trabalho de desenvolvimento do AUV Phoenix.  Haley propõe
uma arquitetura de software híbrida com três níveis organizacionais e
hierárquicos. Há um aumento de inteligência entre as camadas, do reflexivo,
para o prcedural, para o deliberativo figura~\ref{HEALEY_1}:

\begin{itemize}
  \item \textbf{Estratégico (planejador)}: utiliza Prolog como linguagem de
  controle de missão. Desenvolve os comandos que levam o veículo a executar determinada
  missão.
  \item \textbf{Tático (executivo)}: funções na linguagem C que faz interface
  com os predicados de Prolog e retorna variáveis booleanas (\emph{true, false}. Este
  nível funciona de maneira assíncrona e retém os dados da missão, além de se comunicar com o
  nível de execução.
  \item \textbf{Funcional}: controlador em tempo real do veículo, usando
  mensagens assíncronas. Opera os atuadores do veículo. 
\end{itemize}

O controle híbrido será responsável tanto pela movimentação do veículo, contínuo
e síncrono, quanto pela sequência lógica das fases das missões, eventos discreto
com transições assíncronas. A arquitetura incorpora detecção de erros e
procedimentos de recuperação. O módulo reativo é desenvolvido pela arquitetura
de subsunção.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/HEALEY_1.pdf}
\caption{Arquitetura do Robô Phoenix de Healey}
\label{HEALEY_1}
\end{figure}

\paragraph{Stanley}
Em 2006, Sebastian Thrun \cite{montemerlo2006winning} ganhou o desafio DARPA,
uma competição de veículos autônomos organizada pelo governo dos Estados Unidos
a fim de promover o desenvolvimento na área de direção autônoma.

O robô Stanley foi desenvolvido pela Stanford University. É um veículo
(Volkswagen Touareg R5) Fora de estrada (\textit{Off Road}) autônomo de alta
velocidade, que ganhou o desafio de se locomover pela acidentada região do
deserto Mojave por mais 132 milhas sem a interferência de um ser humano. Em
grande parte, o desafio DARPA é uma competição de software, pois um motorista
equipado com um carro apropriado consegue atravessar o deserto sem muitas
dificuldades.

O software desenvolvido é capaz de adquirir dados de sensores, construir modelos
do mundo e tomar decisões de direção a uma velocidade de 60 km/h. Neste robô,
foi utilizada a arquitetura híbrida de três camadas, como em Atlantis
(figura~\ref{stanley})

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/stanley.jpg}
\caption{Arquitetura do Robô Stanley}
\label{stanley}
\end{figure}

\paragraph{CLARAty}
Em 2001, Volpe \cite{volpe2001claraty} desenvolve uma arquitetura híbrida de
duas camadas: Coupled Layer Autonomous Robot Architecture (CLARAty), como uma
evolução da arquitetura Atlantis, arquitetura de três camadas. De acordo com
Volpe, a arquitetura de três camadas apresenta algumas desvantagens: 

\begin{itemize}
  \item As responsabilidades e tamanho de cada nível é subjetivo ao criador da
  arquitetura. Portanto, há arquiteturas em que a camada funcional é dominante,
  outras em que a camada de planejamento domina.
  \item O acesso entre a mais alta camada da hierarquia (planejador) à camada de
  nível inferior (funcional) é restrita. Apesar de isso ser desejado durante
  execução, isto separa o planejador de informações da funcionalidade do sistema
  durante o planejamento. Uma consequênia é que planejadores normalmente
  carregam seus modelos do sistema, que não são derivados (sentido de classe
  derivada, em programação como C++) diretamente do nível Funcional. Esta
  repetição de modelos pode gerar certas inconsistências. %TODO mostrar como
  % ocorre no DORIS
  \item Cada camada pode ter sua própria hierarquia com granularidade variada. A
  camada funcional é composta por vários subsistemas aninhados, o executivo tem
  árvores lógicas para coordená-los, e o planejador tem diversas linhas de tempo
  e horizontes.
\end{itemize}

De acordo com Volper, a estrutura CLARAty tem duas vantagens principais:
representação explícita da granularidade das camadas (em uma representação 3D);
e a mistura das técnicas declarativas e processuais para a tomada de decisões
(figura~\ref{claraty}).

A camada funcional é uma interface com todo o sistema de hardware e suas
capacidades. É um software orientado a objeto, obtendo assim modularidade de
hardware, e estruturação apropriada de software para usar
as propriedades de herança, característica extremamente importante para o nível
funcional.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/claraty.jpg}
\caption{Arquitetura CLARAty}
\label{claraty}
\end{figure}

\subsection{Análise crítica} 
Continuando a analogia de robôs com o funcionamento de animais e,
especificamente o ser humano, a arquitetura híbrida visa juntar as duas
abordagens anteriores, deliberativa e reativa, e de forma inteligente
aproveitar as vantagens de ambas as arquiteturas e aproximar cada vez
mais o funcionamento das máquinas com o homem. Nesta arquitetura final, está
presente tanto o planejamento exercido pelo cérebro, quanto a camada reflexiva
da medula, buscando tornar o robô uma entidade completa.

A grande dificuldade está em como será realizada essa fusão de arquiteturas,
qual será a maneira ótima e que garanta essas vantagens. A abordagem híbrida
evolui a cada ano e novos sistemas, como robôs aeroespaciais e carros
com direção autônoma, provam que esta arquitetura é eficiente.

A arquitetura híbrida é modular já que grande maioria é
dividida em camadas, as quais são subdivididas em módulos. O escopo de aplicação
é enorme se comparada às outras arquiteturas, como já foi apontado: 
veículo aeroespacial, carros autônomos, AUV e outras, e como é
possível particionar a arquitetura, pode-se utilizar apenas a área
deliberativa ou a reativa e englobar o escopo das duas arquiteturas anteriores.
Além disso, a arquitetura híbrida provê robustez, já que apresenta monitor de
desempenho e é capaz de adaptação e reconfiguração.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/brain3.jpg}
\caption{Analogia de sistemas reativos com o ser humano.}
\label{brain3}
\end{figure}


\section{Robotic Development Environments}

A tecnologia em robótica e o número de aplicações de robôs autônomos aumentaram
muito nos últimos anos, exigindo o desenvolvimento de softwares robustos, de
alta performance, de fácil uso e com possibilidade de simular modelos robóticos,
sensores e controle em ambientes virtuais. De acordo com
\cite{staranowicz2011survey}, os ambientes de desenvolvimento em robótica
evoluíram devido à emergente interação entre robôs e seres humanos, o que exige
grande robustez e simulação prévia, como em aplicações médicas, assistência em
ambientes nocivos, e outros. Dessa forma, a comunidade robótica reconheceu a
necessidade do desenvolvimento de softwares abertos para simulação e interface
em robótica.

As arquiteturas híbridas são normalmente decompostas em camadas, isto fica
explícito, por exemplo, na arquitetura de três camadas. Os componentes da
arquitetura necessitam se comunicar entre si, trocar dados e enviar comandos. A
forma de comunicação entre componentes, comumente chamada \textit{middleware},
é o cerne no desenvolvimento de uma RDE, e é uma das mais importantes e
restritivas decisões no projeto de uma arquitetura robótica. De acordo com
\cite{kortenkamp2008robotic}, durante o desenvolvimento de arquiteturas, a
grande maioria dos problemas e a maior parte do tempo gasto em depuração
(\textit{debugging}) está ligado à comunicação entre os componentes. Há
basicamente dois tipos: cliente-servidor (\textit{client-server})) e
editor-subscritor (\textit{publish-subscriber}).

Em um protocolo de comunicação cliente-servidor (ou ponto-a-ponto), componentes
falam diretamente com outros componentes. As vantagens deste protocolo são:
definição prévia da interface; é uma abordagem distribuída para comunicação, já
que não há um módulo central que distribui os dados. Uma desvantagem deste
protocolo é o \textit{overhead}, que é significativo se muitos componentes
precisam de uma mesma informação.

Em um protocolo de comunicação \textit{publish-subscriber} (ou
\textit{broadcast}), um componente publica dados e qualquer outro componente
pode subscrever (ouvir) a esse dado. Normalmente, há um processo central que
roteia os dados entre \textit{publish} e \textit{subscriber}. Em uma arquitetura
típica, um componente pode publicar e subscrever a vários tipos de informações.
As vantagens desse protocolo de comunicação são: simplicidade e pouco
\textit{overhead}; ideal quando não se sabe quantos componentes diferentes
necessitarão dos dados (como em muitas interfaces); componentes não ficam
sobrecarregados em caso de múltiplos pedidos de um mesmo dado. Suas principais
desvantagens são: difícil de \textit{debug}, pois normalemente a sintaxe da
mensagem está escondida em uma simples \textit{string} (uma \textit{lista}
pode ser enviado como \textit{string} e o componente subscritor retraduz);
utilização de um servidor central que distribui as mensgens (recebe dos
\textit{publishers} e envia aos \textit{subscribers}), o que pode criar um único
ponto de falha e sobrecarga.

A utilização do protocolo de comuicação tipo \textit{publish-subscriber} já
aparecia em arquiteturas robóticas antes de Brooks. Em 1983, Elfes
\cite{elfes1983distributed} idealiza uma arquitetura em módulos e controle
distribuído a fim de atingir efetividade em processamento paralelo,
flexibilidade de interação com os diversos sensores, distribuir capacidades de
decisão e flexibilidade de expansão e modificação do sistema. O sistema de
comunicação entre módulos era centralizado e chamado de \textit{Blackboard}.

Em \cite{staranowicz2011survey} e \cite{kramer2007development}, foram realizadas
compilações de RDEs, apontando suas vantagens, desvantagens, aplicações e
os tipos de comunicação. Neste trabalho, são destacados os dois sistemas abertos
mais populares: Player e ROS, e, por fim, é justificado a escolha por ROS como o RDE do robô DORIS.

\subsection{Player}
Em 2001, Player/Stage \cite{gerkey2003player} foi projetado para ser uma
interface de programação, não um ambiente de desenvolvimento, focando em
programação de dispositivos (drivers) e sensores, em vez de robôs. Em Player, os
dispositivos são independentes entre si e são registrados em um servidor,
podendo ser acessados por clientes (programas de controle). Cada cliente usa uma
conexão com o servidor para transferência de dados, possibilitando operações
concorrentes. Múltiplos clientes podem subscrever a um mesmo dispositivo e podem
enviar comandos simultaneamente, porém não há fila, logo comandos antigos são
descartados. Stage, a segunda parte do software, é um simulador de dispositivo.

O objetivo de Player é a separação de interface e função. O fato de servidores
se comunicarem via soquete TCP/IP possibilita que clientes possam ser escritos
em qualquer linguagem de programação que possua esse suporte, por
exemplo Python, C++, Java e outros. Clientes podem operar em qualquer host que
possua conexão, possibilitando independência de localização.

\subsection{Robot Operating System - ROS}

ROS é um software aberto que provê camada de abstração de hardware (CAH -
hardware abstraction), controle baixo nível de dispositivos, mensagens entre
processos TCP/IP ou UDP, e gerenciamento de pacotes. Dentre todas, a mais
importante característica de ROS é a presença de uma grande comunidade de pesquisadores que
contribui para a expansão do software, possível, principalmente, pela
repositório disponível no website ROS. 

ROS, como o próprio autor \cite{quigley2009ros} salienta, não é um sistema
operacional (SO) no sentido tradicional de gerenciador de processos e
agendamento, mas apresenta algumas ferramentas parecidas, como
mensagens entre processos. De acordo com o autor, a filosofia por trás do
desenvolvimento deo ROS pode se resumida nos seguintes pontos:

\begin{itemize}
  \item Arquitetura de rede ponto-a-ponto (\textit{peer-to-peer}).
  \item Tools.
  \item Multi linguagens de programação.
  \item \textit{Thin}.
  \item Gratuito e aberto.
\end{itemize}

Um sistema desenvolvido em ROS é capaz de possuir diversos processos, em
diferentes hosts, conectados por uma topologia ponto-a-ponto, em tempo de
execução. Uma topologia com servidor central começa a se tornar problemática se
computadores são conectados em uma rede heterogênea. ROS necessita de um
mecanismo de busca para permitir que processos se encontrem em tempo de
execução, chamado \textit{service} ou \textit{master}. 

O sistem se comporta de maneira semelhante ao Player em relação à conexão por
soquete TCP/IP, possibilitando o uso de múltiplas
linguagens, como Python, C++, Octave e LISP.

Em ROS, pequenas \textit{tools} são usadas para construir e
executar os componentes, em vez um grande monolítico ambiente de
desenvolvimento. As \textit{tools} realizam diversas tarefas, como navegar pela
árvore de código, obter e definir parâmetros, visualizar a conexão
ponto-a-ponto, medir a largura de banda utilizada, representar graficamente
dados, gerar automaticamente documentações, e outros.

A ideologia \textit{thin} de ROS é possibilitar que códigos, como drivers e
algoritmos, possam ser reutilizados em outros middlewares, fora de ROS. Alguns
exemplos são algoritmos de visão de OpenCV, e algoritmos de planejamento de
OpenRAVE.

Os conceitos fundamentais de ROS são nós, mensagens, tópicos e serviços.

Nós são processos ou módulos de software no código de controle, por exemplo um
nó \textit{camera} poderia processar todos os dados visuais. Nós podem se
comunicar com outros nós por simples mensagens (\textit{integer},
\textit{floating point}, \textit{boolean}, etc), que são enviadas a um ou
múltiplos tópicos (\textit{strings}, como ``mapa'' ou ``odometria''). Um nó
interessado em certo tipo de mensagem deverá subescrever o tópico apropriado.
Pode haver múltiplos publicadores e subscritores concorrentes a um mesmo tópico.

Apesar de o modelo de comunicação do tipo publicador-subscritor ser flexível,
sua rotina de \textit{broadcast} não é apropriada para transações síncronas. Em
ROS, é chamado serviço (também definido por uma \textit{string}) um par de
mensagens: um para pedido, outro para resposta, análogo à URI de um web service.
A figura~\ref{roscomm} mostra os tipos de comunicação do sistema ROS.

\begin{figure}[!ht]
\centering
\includegraphics[width=.8\columnwidth]{figs/roscomm.jpg}
\caption{Tipos de comunicação so sistema ROS.}
\label{roscomm}
\end{figure}

A figura~\ref{rosarchitecture} é um resumo de todas as características
discutidas acima, mostrando como funciona o ambiente de desenvolvimento ROS. 

\begin{figure}[!ht]
\centering
\includegraphics[width=.8\columnwidth]{figs/rosarchitecture.png}
\caption{Arquitetura do ambiente de desenvolvimento ROS.}
\label{rosarchitecture}
\end{figure} 
