\chapter{Arquitetura proposta}

O capítulo~\ref{bibliografia} apresentou os conceitos necessários para o
entendimento desta dissertação, mostrou a evolução das arquiteturas robóticas e
controles de missão, e as diversas aplicações em robôs modernos. A autonomia de
um robô depende, em grande parte, do desenvolvimento desta arquitetura robótica.

Neste capítulo, será apresentada uma implementação da arquitetura híbrida de
três camadas, utilizando o ambiente de desenvolvimento ROS, para um robô
móvel que executa tarefas de inspeção, a DORIS. Como definido no
capítulo~\ref{bibliografia}, a arquitetura robótica não é apenas uma
arquitetura de software, mas sim uma arquitetura que depende dos
componentes físicos do robô (hardware) e a sua aplicação. Dessa forma, faz-se
necessário apresentar o objeto de estudo desta dissertação.

\section{Robô DORIS}\label{doris}
DORIS é um robô desenvolvido pela COPPE/UFRJ, em colaboração com Petrobras e
Statoil, para aplicação \textit{offshore}: monitoramento e inspeção em
plataformas de petróleo. O robô é controlado de maneira autônoma ou teleoperado,
permitindo que o operador acompanhe o estado da missão, e monitore a informação
dos sensores. O robô apresenta as seguintes funcionalidades
\cite{carvalho2013doris}:

\begin{itemize}
  \item Detecção de anomalias por vídeo: uso de múltiplas câmeras (luz visível,
  infravermelho, fisheye e estéreo) para detectar anomalias, como objetos abandonados, fumaça,
  fogo, intrusos e vazamentos.
  \item Detecção de anomalias por áudio: microfones detectam áudios anômalos,
  como explosões, e realizam diagnóstico de mau funcionamento de máquinas, comparando os sons recebidos com
  assinaturas obtidas previamente.
  \item Detecção de anomalias por vibração: DORIS possui um manipulador com
  sensor de vibração em seu efetuador para inspecionar o funcionamento de máquinas, a partir de
  algoritmos com classificadores de falhas.
  \item Detecção de anomalias por sensor de gás: sensor de hidrocarboneto
  detecta o vazamento de gases.
  \item Mapeamento 3D do ambiente: DORIS é capaz de reconstruir um ambiente 3D a
  partir de câmeras e Laser.
  \item Detecção de anomalias por temperatura: DORIS possui um sensor de
  temperatura e umidade.
  \item Detecção de anomalias por câmera de infravermelho: uma câmera de
  infravermelho pode detectar pessoas, indicar a presença de intrusos ou
  indentificar incêncidos.
\end{itemize}

DORIS é um robô móvel que se locomove em um trilho pelo uso de dois gimbals, os
quais contêm atuadores e rodas. O robô foi desenvolvido dentro da filosofia
de modularidade, isto é, novos sensores podem ser integrados ao sistema, ou até
um novo módulo do robô pode ser adicionado, a fim de melhorar seu desempenho
dentro do escopo da aplicação de inspeção. Isso exige a
flexibilidade e modularidade do sistema mecânico, software e sistema
elétrico/eletrônico.

O sistema é alimentado por quatro baterias, composto por um computador
embarcado com processador de alto desempenho e memória, e um \textit{solid-state drive} para armazenamento. Possui
comunicações: Wireless IEEE 802.11n com a base (operador); \textit{Controller
Area Network} (CAN) entre computador embarcado e drivers dos atuadores; rede \textit{Local
Gigabit Ethernet} para os diversos componentes internos do robô; e rádio 2.4/5.0
GHz para emergência. Possui atuadores: quatro motores 200 W EC-4pole para
locomoção; e quatro motores para as juntas do mannipulador. Sensores:
câmera fixa; câmera térmica; câmera \textit{fisheye}; duas webcams; e uma
\textit{Inertial Measurement Unit} (IMU). Além disso, há um
sistema eletrônico de suporte de veículo, chamado \textit{Vehicle Support
System (VSS)} \cite{freitas2015embedded}, capaz de detectar falhas eletrônicas,
distribuir energia de maneira ótima entre os componentes e proteger o robô em
situações emergenciais.

O VSS possui funções que independem do software e da arquitetura robótica, são
considerados de alto risco e, portanto, não estão disponíveis para
programador e usuário. Em detalhes, as funções do VSS são:
\begin{itemize}
  \item Detecção de falhas: em dispositivos, pelo monitoramento de
  corrente/tensão; no módulo, pela verificação de temperatura/umidade;
  \item Proteção de dispositivos contra sobrecorrente graças a fusíveis;
  \item Distribuição ótima de energia e monitoramento de baterias;
  \item Botão de emergência para desligamento manual ou via rádio.
\end{itemize}

O trilho por onde o robô se desloca é construído a partir de tubos de
policloreto de polivinila (PVC) e possui seções retas, curvas ortogonais de
subida, descida, para a direita e para a esquerda. Os segmentos curvos são tubos
de 1 m dobrados $90^o$, resultando em curvaturas de aproximadamente 630 mm. Um
trilho para testes foi construído no Centro de Pesquisas e
Desenvolvimento da Petrobras (CENPES) e sua extensão é cerca de 140 m.

\section{A arquitetura robótica implementada}

Na seção~\ref{doris}, foi apresentado o robô DORIS e suas funcionalidades. Como
foi definido na seção~\ref{conceitos}, pela visão do autor, o conceito de
\emph{arquitetura robótica} não é equivalente apenas a uma arquitetura de
software, necessitando da avaliação do robô como um todo, isto é, seus
elementos de hardware e sua aplicação. Assim como o desenvolvedor do RDE ROS
\cite{quigley2009ros} evidencia que não há melhor RDE, já que todos apresentam
vantagens e desvantagens e o melhor depende de sua aplicação, também não há
melhor arquitetura robótica, pois esta depende dos hardwares do robô e também da
sua aplicação.

DORIS é um robô móvel com a funcionalidade de inspeção em um ambiente não muito
dinâmico, usando técnicas que exigem grande processamento de imagem (câmeras) e
outros sensores. O usuário final poderá, com o auxílio de uma interface,
programar as missões: inspeção até uma posição do trilho, inspeção de
equipamento, ir até uma posição do trilho, e ronda (inspeção global). Além
disso, o usuário pode tomar o controle manual do robô, e visualizar as
respostas dos sensores.
 
As funcionalidades de inspeção do robô exigem a construção e manutenção do
modelo do mundo, pois há constante comparação com a situação esperada e
possíveis anomalias. Também fica claro que não é só um modelo do mundo que se
faz necessário, mas a construção de modelos distintos para cada componente
de forma a otimizar as missões. Além disso, robôs \textit{offshore} exigem
grande robustez, por trabalharem em ambientes hostis, e que demandam ações rápidas em situações
emergenciais. As exigências de um controle de missão para modos
flexíveis de inspeção, a manutenção de modelos de mundo e a robustez
no controle do robô demandam uma arquitetura híbrida.

No capítulo~\ref{bibliografia}, foi explicitada algumas formas de arquitetura
híbrida, mas aquela com maior número de aplicações bem sucedidas é a arquitetura
híbrida de três camadas, utilizadas desde a aplicação do carro autônomo do
desafio DARPA (Stanley) até a aplicação de exploração do robô da NASA no
planeta Marte. 

Escolhida a arquitetura híbrida de três camadas como arquitetura robótica da
DORIS, faz-se ainda necessário explicitar a implementação de cada camada, isto
é, como e qual executará as funções descritas por Murphy: sequenciador,
gerenciador de recurso, cartógrafo, planejador de missão, e monitor de
desempenho. A arquitetura de três camadas é formada por: camada Funcional,
camada Executiva e camada Planejador, e como cada arquitetura de três camadas
apresenta suas peculiaridades, as camadas desenvolvidas para o robô DORIS são descritas nas
subseções adiante.


\subsection{Implementação da camada Funcional}

A camada funcional é a primeira implementada e exaustivamente testada no
robô DORIS. Como nas outras arquiteturas de três camadas previamente
apresentadas, a camada Funcional é o nível mais baixo, conecta sensores a
atuadores, implementa controladores PID, e diversos outros algoritmos, por
exemplo para a localização do robô. Utiliza-se Ubuntu/Linux como sistema
operacional e ROS como RDE para a implementação do nível funcional, já que este
apresenta todas as vantagens descritas na subseção~\ref{ros}, e linguagem de programação C++, a fim de
se garantir maior eficiência computacional.

A camada funcional seguiu a recomendação dos desenvolvedores do ROS, sendo
estruturado de maneira semelhante à camada funcional do sistema CLARAty. Neste,
a camada funcional é uma interface com todo o sistema de hardware e suas
capacidades. É um software orientado a objeto, obtendo assim modularidade de
hardware, e uma estruturação apropriada para usar as propriedades de
herança, em software. A figura~\ref{claratyfunc} mostra a organização da camada
Funcional da arquitetura CLARAty.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/claratyfunc.jpg}
\caption{Organização da camada Funcional CLARAty}
\label{claratyfunc}
\end{figure}

Foi proposto o \textit{Robot Package Software}. Neste sistema,
\emph{Tools} (janelas gráficas) e \emph{Componentes} (unidades de comunicação e
processamento) são agrupados em \textit{Robot Package} (bibliotecas dinâmicas).
Os componentes que lidam com hardware rodam no computador embarcado do robô,
já os componentes que interagem com as \textit{tools} rodam no computador base.
Os diversos componentes, tanto do computador embarcado quanto da base, se
comunicam através de mensagens ROS, permitindo que a base controle o robô, na
função de teleoperação \cite{freitas2015embedded}. Os componentes do robô são
o foco de estudos desta dissertação, já que os componentes da base não estão
diretamente ligados à autonomia do robô, mas apenas a uma fração do controle de
missão, que diz respeito à interface com o usuário e \textit{feedback} dos
planos ao usuário.

Dois \textit{Robot Packages} fazem parte no desenvolvimento do robô DORIS:
\textit{General Package} e \textit{DORIS Package}, derivado do primeiro. Outros
robôs desenvolvidos por GSCAR, como o ROV LUMA, possuem seus pacotes
específicos, derivados do \textit{General Package}. 

O \textit{General Package} contém os componentes e \textit{tools} gerais
relacionados a vídeo, áudio, tabela de dados, \textit{gamepad} (para controle
remoto de robôs), e configurações de dispositivos que podem ser usados em outros
robôs

O \textit{DORIS Package} é um pacote mais específico ao robô DORIS e lida com
seus elementos de hardware e suas funcionalidades. Do ponto de vista de uma
arquitetura robótica, neste pacote foram implementados os \emph{comportamentos}
específicos do robô DORIS.  Os diversos componentes implementados para o DORIS
foram divididos em funcionalidades, neste trabalho, a fim de proporcionar melhor
entendimento.

Como já descrito na seção~\ref{doris}, os atuadores para locomoção e para o
manipulador do DORIS se comunicam via CAN-Bus, que provê velocidade e
transferência confiável dos dados \cite{corrigan2008introduction}. Esta
comunicação extra, exigiu a implementação do componente \emph{CANOpen}, que utiliza a biblioteca
SocketCAN disponivel em Linux. Um componente \emph{EPOS} é classe derivada de
\emph{CANOpen} e especifica este tipo de comunicação com o hardware EPOS
(driver) utilizado no DORIS, além de implementar outras caracterísiticas do
driver, como os dados dos encoders dos motores: posição (odometria), velocidade
e corrente.
Além disso, há a \emph{EPOSNodelet}, classe derivada de \emph{EPOS}, que implementa a comunicação ROS. A implementação dos
componentes respeita a sugestão do desenvolvedor do \textit{framework}, de forma
que sempre há a criação de uma classe padrão C++ e uma classe derivada dentro do
ambiente ROS, que usa os métodos do \textit{framework}.

Os componentes que executam o controle de locomoção do robô são:
\emph{Controller}, \emph{ControllerNodelet} (derivada de \emph{Controller}),
\emph{MotionController} (derivada de \emph{Controller}),
\emph{MotionControllerNodelet} (derivada de \emph{MotionController}),
\emph{PositionController} (derivada de \emph{Controller}) e
\emph{PositionControllerNodelet} (derivada de \emph{PositionController}). Os
componentes \emph{Controller} e \emph{ControllerNodelet} (componente
\emph{Controller} com os recursos de ROS) são classes genéricas de controle,
sendo necessária a implementação do controle para o robô específico,
componentes \emph{MotionController} e \emph{PositionController}.

Os quatro hardwares EPOS possuem uma malha de controle PD ou
PID para realizar o controle do robô por velocidade ou corrente, porém de
maneira independente para cada motor. A sincronia e ajustes dessas malhas de
controle são realizados no componente \emph{MotionController}. Este componente
se comunica por serviço de ROS (\textit{service}) com o componente
\emph{EPOSNodelet}, enviando os valores de velocidade desejados para cada motor.
Por exemplo, observe que, em uma curva, devido à distância entre os dois gimbals
do robô e à distância entre as rodas dos gimbals, os motores devem possuir
velocidades diferentes. O \emph{MotionController} envia set-points de
velocidade às EPOS e pode alterar os parâmetros de aceleração e
desaceleração. Além disso, este componente é responsável por receber entradas do
componente \emph{Joystick} e \emph{Interface}, que podem controlar o robô pela
base, ou \emph{MissionController}, o componente de missão autônoma. Há apenas
a prioridade do \emph{MissionController} sobre todos os outros controladores,
tal que, com exceção do \emph{MissionController}, o componente que irá
controlar será o primeiro que pedir o controle.

O componente \emph{PositionController} será futuramente integrado ao
\emph{MotionController}. Sua funcionalidade é realizar um controle de posição,
logo possui uma malha interna de controle, não disponível no hardware da EPOS, e
se comunica com o componente \emph{MotionController}, enviando set-points de
velocidades. É um controle proporcional de posição com saturação de velocidade.

O manipulador da DORIS utiliza mais quatro EPOS (quatro motores) e exigirá ainda
a implementação de um controle de força para sensoriamento de equipamentos ao
toque, a partir de um sensor de vibração. Componentes como \emph{ForceControl} e
\emph{InspectionVibration} ainda estão em desenvolvimento em.
%TODO referencia marco

Ainda em fase de aperfeiçoamento, os componentes de localização
\emph{Localization} e \emph{LocalizationNodelet} recebem mensagens de ROS
(\textit{subscriber}) do componente \emph{EPOSNodelet}, os dados da odometria,
isto é, quanto cada roda girou. Dentro de \emph{Localization} é feita uma média
para estimar quanto o robô se locomoveu. Em implementação, está sendo feito um
sistema inteligente de localização com os dados dos sensores IMU e LaserScan. A
fusão de sensores permitirá estimar de maneira precisa a posição do robô. O
\emph{LocalizationNodelet} ainda envia mensagens (\emph{Publish}) para o
\emph{PositionController}, \emph{MotionController} e \emph{RVIZ}, um componente
de vizualização para o usuário.

Os diversos componentes de sensores, no robô, são: \emph{AudioSender},
\emph{AudioSenderNodelet} (derivada de \emph{AudioSender}),
\emph{VideoSender}, \emph{VideoSenderNodelet} (derivada de
\emph{VideoSender}), \emph{VideoWebcamera} (derivada de
\emph{VideoSenderNodelet}), \emph{AxisVideo} (derivada de
\emph{VideoSenderNodelet}), \emph{LMS1xx}, \emph{IMU}, \emph{IMUNodelet} e
\emph{ColorDetector}.

O componente \emph{AudioSender} é um driver que faz a interface com os diversos
microfone disponíveis no robô. Comunica-se (\textit{publisher}) por mensagem de
ROS com o componente da base \emph{AudioReceiverNodelet} (\textit{subscriber})
para disponibilizar os dados ao usuário. Futuramente, irá se comunicar
(\textit{publisher}) com o \emph{InspectionAudioNodelet} (\textit{subscriber}),
um componente que compara o áudio da base de dados do robô e detecta anomalias através de um algoritmo de reconhecimento de padrões.

O componente \emph{VideoWebcamera} é um driver que faz a interface com as duas
câmeras webcams disponíveis no robô. Comunica-se
(\textit{publisher}) com o componente da base
\emph{VideoReceiverNodelet} (\textit{subscriber}) para disponibilizar os dados
ao usuário, e com o componente \emph{ColorDetection} (\textit{subscriber}), um
algoritmo que verifica a porcentagem de vermelho obtida em cada frame da
câmera. Futuramente, o componente \emph{ColorDetection} irá se comunicar
(\textit{publisher}) com o \emph{Localization} (\textit{subscriber}), já que a
informação de vermelho no trilho será utilizada para calibrar a
localização.

O componente \emph{LMS1xx} é um driver que faz a interface com o LaserScan,
sensor que realiza um escaneamento a laser do ambiente. Comunica-se
(\textit{publisher}) com o componente da base \emph{LaserReceiverNodelet}
(\textit{subscriber}) para disponibilizar os dados ao usuário. Futuramente, irá
também se comunicar com o \emph{PoleDetection} (\textit{subscriber}), que possui
um algoritmo para detecção de postes, e o \emph{Localization} (\textit{subscriber}), já que
este é mais um sensor que provê dados para o sistema de localização (altura do
robô).

O componente \emph{IMU} é um driver que faz a interface com a IMU.
Ele envia uma lista de dados: velocidade, orientação, posição, pólos
magnéticos e outros. Futuramente, também irá se comunicar com o
\emph{Localization}.

O componente \emph{AxisVideo} é um driver que faz a interface com a câmera fixa
da AXIS. Comunica-se (\textit{publisher}) com o componente
da base de mesmo nome para disponibilizar os dados ao usuário. Futuramente, o
algoritmo de detecção de anomalias por vídeo será integrado ao sistema ROS,
logo um componente \emph{InspectionVideo} será \emph{subscriber} do mesmo
tópico.

A FIGURA represente o esquema de comunicação entre os diversos componentes e
suas hierarquias.

\subsection{Implementação da camada Executivo}
%TODO falar das prioridades
%TODO recursos compartilhados, como fica?
%TODO Referenciar DFKI tb
A camada Executivo elaborada para a DORIS usa SMACH (subseção~\ref{smach}) como
linguagem da camada Executivo, e implementa a técnica de função de coordenação
competitiva (subseção~\ref{reativa}), a arquitetura de subsunção, onde o módulo
básico de comportamento reativo é uma máquina de estados aumentada
(\emph{AFSM}) da figura~\ref{afsm} sem \textit{Reset}. A camada Executivo é o
foco da implementação do autor desta dissertação e, junto com a camada
Planejador, permite a autonomia do robô.

As subseções a seguir detalham a implementação da camada Executivo,
identificando como é realizada cada responsabilidade: Tradutor (planos do
Planejador em tarefas), Sequenciador, Selecionador, Gerenciador de recursos, e
Monitoramento da execução e recuperação de erros (\textit{Execution monitoring
and error recovery}). Como o ambiente de desenvolvimento da camada Funcional é
ROS, optou-se pela utilização da camada Executivo SMACH \cite{bohren2010smach}
por demonstrar resultados positivos em diversas aplicações, e já ser integrada
ao sistema ROS. Foram adicionadas algumas funcionalidades à camada a fim de
garantir todas as responsabilidades de uma camada Executivo. A linguagem de
programação utilizada é Python.


\subsubsection{Sequenciador e Selecionador}
SMACH é um \textit{framework} para projetar máquinas de estados hierárquicas
concorrentes. As máquinas de estados de SMACH possuem características bem
peculiares não encontradas em máquinas de estados formais, como a \textit{user
data}, comentada na subseção~\ref{smach}. O Sequenciador desenvolvido para a
DORIS utilizará as capacidades de SMACH para a modelagem das tarefas do robô.

Dependendo da aplicação, robôs, como seres humanos, possuem um conjunto de
processos que estão sempre em execução, e outros conjuntos de processos que só
entrarão em execução dependendo da tarefa que o robô irá executar. Por exemplo,
em um ser humano, os processos vitais como ``respirar'' e ``o bombear do
coração'' estão sempre em execução, sendo que alguns podem ser postos em espera
por um tempo, como ``respirar'', e outros são incontroláveis, como ``o bombear
do coração''. A camada Executivo é a camada, em DORIS, que assumirá
esta responsabilidade de \textbf{Selecionador}, simulando este mesmo princípio
encontrado na natureza, extremamente necessário para garantir robustez e
proteção. 

 


A concepção da camada Executivo é de se criar vários processos sendo executados
em


\subsubsection{Gerenciador de recursos}


\subsubsection{Monitoramento de tarefas e recuperação de
erros}\label{monitoamento}
% The languages presented differ considerably in how
% they deal with execution monitoring and exception
% handling. ESL and TDL both provide explicit
% execution monitoring constructs and support exceptions
% that are thrown and then caught by registered
% handlers in a hierarchical fashion. This type of
% exception handling is similar to that used in C++, Java,
% and Lisp. ESL and TDL also support clean up
% procedures that can be invoked when tasks are
% terminated. RAPs and PLEXIL use return values to
% signal failure, and do not have hierarchical exception
% handling. PLEXIL, though, does support clean up
% procedures that are run when tasks fail. PRS has
% support for execution monitoring, but not exception
% handling. ESL and PRS support the notion of resources
% that can be shared. Both provide support for
% automatically preventing contention amongst tasks for
% the resources. In the other executive languages, this
% must be implemented separately (although there are
% plans to extend PLEXIL in this area).





\subsection{Implementação da camada Planejador}\label{planejador}
%TODO lembrar de mapa de equipamentos e quais precisam de manipulador
%TODO mapa de postes
%TODO mapa de distancias ao chao
%TODO mapa 3D
%TODO mapas analiticos
%TODO mapa das seções do trilho.
%TODO mapa audio
%TODO Mapa audio de anomalias
%TODO Mapa de equipamentos
%TODO falar de SLAM

% Many architectures provide for specialized planning
% ``experts" that are capable of solving particular
% problems efficiently.
% In particular, these include
% motion planners, such as path planners and trajectory
% planners.
% Sometimes, the planning layer of the
% architecture invokes these specialized planners directly;
% in other architectural styles, the motion planners are
% part of the lower levels of the architecture (the
% executive, or even the behavioral layer). Where to put
% these specialized planners is often a question of style
% and performance (see Section 8.5).
\subsubsection{Controle de missão} %UI

\subsubsection{Planejador de missão e Tradutor}
A camada Planejador enviará missões à camada Executivo, quando estas estiverem
agendadas ou quando o usuário requisitar. Na subseção~\ref{hibrida}, em
\ref{murphy}, foi exemplificada a responsabilidade de \textbf{Tradutor} da
camada Planejador com um robô assistente que serve cafés. A implementação desta
responsabilidade no DORIS é realizada por um dicionário codificado no robô.
Este método é normalmente conhecido na literatura como \textit{encoded
knowledge} (conhecimento codificado), que são dados incorporados ao código
fonte \textit{hard coded}.

As missões do robô podem ser classificadas em: \textbf{Missões Simples},
\textbf{Missões Complexas} e \textbf{Missões Desconhecidas}. Todas as missões
possuem \textit{argumentos}, entradas mínimas do usuário necessários para a
execução da missão.

As missões simples não necessitam de tradução por já estarem em nível
mínimo de máquinas de estados SMACH. Por exemplo:
\begin{itemize}
  \item \textbf{GOTO}: missão de locomoção do robô até um ponto do trilho. Os
  \textit{argumentos} para esta missão são: posição desejada no trilho, em valor
  absoluto; velocidade desejada, um valor fuzzy: ``slow'' (devagar), ``normal''
  (normal) ou ``fast'' (rápida); direção de movimento, 1 para sentido de
  locomoção para frente (baterias chegam por último) e -1 para sentido
  contrário; número de voltas desejado, em caso de trilho fechado, antes de o
  robô atingir a posição requisitada. O único argumento obrigatório é posição
  desejada, de forma que os valores padrão são: velocidade ``fast''; direção de
  movimento de velocidade mínima; e zero voltas.
  \item \textbf{RECORD\_TYPE}: gravar dados de sensores no robô. Há um 
 \textit{argumentos} para esta missão que pode ser preenchido como: vídeo, áudio
 e termografia. Cada tipo representa uma missão de gravar dados de um sensor
 específico (câmera, microfone e câmera termográfica, respectivamente).
  \item \textbf{STOP\_RECORD\_TYPE}: parar gravação de dados de sensores no
  robô. Assim como a inicialização da missão, há um \textit{argumento} que deve
  ser preenchido: o tipo de gravação, que irá resultar na utilização do sensor
  apropriado para a execução da tarefa.
  \item \textbf{START\_DETECTING\_ANOMALIES\_TYPE}: iniciar algum detector
  específico de anomalia. Há três tipos de detecção de anomalias
  que podem ser escolhidos: vídeo, áudio e termografia. Para cada um deles, há
  uma máquina de estados específica: iniciar algoritmo detector de anomalias por
  câmera, microfones ou câmera termográfica, respectivamente.
  \item \textbf{END\_DETECTING\_ANOMALIES\_TYPE}: finalizar algum detector
  específico de anomalia. Assim como iniciar, finalizar apresenta os mesmos três
  tipos de detecção de anomalias: vídeo, áudio e termografia. E Para cada um
  deles, há uma máquina de estados específica: iniciar algoritmo detector de
  anomalias por câmera, microfones ou câmera termográfica, respectivamente.
\end{itemize}

As missões complexas, de mais alto nível, são combinações de
missões simples. Estas necessitam ser traduzidas pelo Planejador com os
argumentos corretos. Por exemplo:
\begin{itemize}
  \item \textbf{GOTO\_BASE}: missão de locomoção do robô à base.
  Não há \textit{argumentos} para esta missão. Tradução necessária para camada
  Executivo: \textbf{GOTO}: posição zero, velocidade ``fast''.
  \item \textbf{INSPECTION}: missão para inspecionar planta em um trecho.
  Necessita que o usuário escolha até onde inspecionar (posição final absoluta
  no trilho) e o tipo de inspeção: vídeo, áudio e termográfico. Tradução: para cada tipo selecionado realizar
  \textbf{START\_DETECTING\_ANOMALIES\_TYPE}; \textbf{GOTO}:
  velocidade ``slow'' (observe que inspeção requer velocidade mínima); para cada
  tipo realizar \textbf{STOP\_DETECTING\_ANOMALIES\_TYPE}.
  \item \textbf{PATROL}: realizar uma ronda completa, isto é, inspecionar toda a
  planta. Não há \textit{argumentos} para esta missão. Tradução:
  \textbf{INSPECTION}: todos os sensores, posição final do trilho.
  \item \textbf{MANIPULATOR\_INSPECTION}: inspecionar um equipamento com
  manipulador. O \textit{argumento} desta missão é o equipamento a
  ser inspecionado. O robô deve ir à posição que se encontra o equipamento, tocar o
  equipamento com o sensor de vibração através do manipulador, e executar uma
  detecção de anomalias por vibração. Em linguagem da camada Executivo, seria
  \textbf{GOTO}: posição do equipamento (requer verificar mapa de equipamentos),
  velocidade ``fast''; \textbf{MANIPULATOR\_POSITION\_CONTROL}: posição
  referente ao equipamento; \textbf{MANIPULATOR\_FORCE\_CONTROL};
  \textbf{START\_DETECTING\_ANOMALIES\_VIBRATION}.
\end{itemize}  

As missões desconhecidas são missões que não estão
descritas no robô, isto é, missões que, até o momento, não pertencem ao
dicionário do robô. Até esta fase da implementação, DORIS não permite que o
usuário use missões desconhecidas. O motivo principal disso é que o robô não
interage com o ser humano de maneira direta, mas apenas através de uma
interface. Vale, porém, explicitar situações de aplicações robóticas em que
missões desconhecidas são essenciais:

\begin{enumerate}
  \item Robô que serve bebidas: uma missão desconhecida é o usuário pedir
  uma bebida que não exista em sua base de conhecimento (mapa de bebidas).
  Durante a tarefa de reconhecer a bebida na geladeira, o robô irá falhar. Porém, o Planejador
  poderia executar uma busca por fotos de bebida em algum site de buscas, antes
  de executar a tarefa, e atualizar a sua base de conhecimento (mapa de
  bebidas), de forma que a tarefa tenha resultado positivo com novo dado.
  \item J.A.R.V.I.S., a inteligência artificial das histórias em quadrinhos
  Iron Man (homem de ferro): comandos por voz normalmente são complexos, já que
  há diversas maneiras de pedir que um plano a um robô. Pro exemplo, os planos
  ``Robô, preciso de uma tesoura'', ``Robô, dê-me uma tesoura'', ``Robô,
  traga-me uma tesoura'' são planos equivalentes, ditos de maneira diferentes.
  Todas estas diferentes formas devem estar disponíveis em alguma base de
  conhecimento, dentro ou fora do robô, como na nuvem (\textit{cloud}), a qual
  deveria ser compartilhada com todos os robôs que exercem a mesma função.
  RoboEarth \cite{hunziker2013rapyuta} é uma ideia visionária que está buscando
  criar uma \textit{internet dos robôs} (como a \textit{internet das coisas}),
  já está sendo integrada ao ambiente ROS, e sua contribuição é criar um
  repositório na nuvem com missões compartilhadas para todos os robôs que a
  utilizam.
\end{enumerate}

\subsubsection{Agendador}

\subsubsection{Cartógrafo}