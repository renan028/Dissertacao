\chapter{Arquitetura proposta}

O capítulo~\ref{bibliografia} apresentou os conceitos necessários para o
entendimento desta dissertação, mostrou a evolução das arquiteturas robóticas e
controles de missão, e as diversas aplicações em robôs modernos. A autonomia de
um robô depende, em grande parte, do desenvolvimento desta arquitetura robótica.

Neste capítulo, será apresentada uma implementação da arquitetura híbrida de
três camadas, utilizando o ambiente de desenvolvimento ROS, para um robô
móvel que executa tarefas de inspeção, a DORIS. Como definido no
capítulo~\ref{bibliografia}, a arquitetura robótica não é apenas uma
arquitetura de software, mas sim uma arquitetura que depende dos
componentes físicos do robô (hardware) e a sua aplicação. Dessa forma, faz-se
necessário apresentar o objeto de estudo desta dissertação.

\section{Robô DORIS}\label{doris}
DORIS é um robô desenvolvido pela COPPE/UFRJ, em colaboração com Petrobras e
Statoil, para aplicação \textit{offshore}: monitoramento e inspeção em
plataformas de petróleo. O robô é controlado de maneira autônoma ou teleoperado,
permitindo que o operador acompanhe o estado da missão, e monitore a informação
dos sensores. O robô apresenta as seguintes funcionalidades
\cite{carvalho2013doris}:

\begin{itemize}
  \item Detecção de anomalias por vídeo: uso de múltiplas câmeras (luz visível,
  infravermelho, fisheye e estéreo) para detectar anomalias, como objetos abandonados, fumaça,
  fogo, intrusos e vazamentos.
  \item Detecção de anomalias por áudio: microfones detectam áudios anômalos,
  como explosões, e realizam diagnóstico de mau funcionamento de máquinas, comparando os sons recebidos com
  assinaturas obtidas previamente.
  \item Detecção de anomalias por vibração: DORIS possui um manipulador com
  sensor de vibração em seu efetuador para inspecionar o funcionamento de máquinas, a partir de
  algoritmos com classificadores de falhas.
  \item Detecção de anomalias por sensor de gás: sensor de hidrocarboneto
  detecta o vazamento de gases.
  \item Mapeamento 3D do ambiente: DORIS é capaz de reconstruir um ambiente 3D a
  partir de câmeras e Laser.
  \item Detecção de anomalias por temperatura: DORIS possui um sensor de
  temperatura e umidade.
  \item Detecção de anomalias por câmera de infravermelho: uma câmera de
  infravermelho pode detectar pessoas, indicar a presença de intrusos ou
  indentificar incêncidos.
\end{itemize}

DORIS é um robô móvel que se locomove em um trilho pelo uso de dois gimbals, os
quais contêm atuadores e rodas. O robô foi desenvolvido dentro da filosofia
de modularidade, isto é, novos sensores podem ser integrados ao sistema, ou até
um novo módulo do robô pode ser adicionado, a fim de melhorar seu desempenho
dentro do escopo da aplicação de inspeção. Isso exige a
flexibilidade e modularidade do sistema mecânico, software e sistema
elétrico/eletrônico.

O sistema é alimentado por quatro baterias, composto por um computador
embarcado com processador de alto desempenho e memória, e um \textit{solid-state drive} para armazenamento. Possui
comunicações: Wireless IEEE 802.11n com a base (operador); \textit{Controller
Area Network} (CAN) entre computador embarcado e drivers dos atuadores; rede \textit{Local
Gigabit Ethernet} para os diversos componentes internos do robô; e rádio 2.4/5.0
GHz para emergência. Possui atuadores: quatro motores 200 W EC-4pole para
locomoção; e quatro motores para as juntas do mannipulador. Sensores:
câmera fixa; câmera térmica; câmera \textit{fisheye}; duas webcams; e uma
\textit{Inertial Measurement Unit} (IMU). Além disso, há um
sistema eletrônico de suporte de veículo, chamado \textit{Vehicle Support
System (VSS)} \cite{freitas2015embedded}, capaz de detectar falhas eletrônicas,
distribuir energia de maneira ótima entre os componentes e proteger o robô em
situações emergenciais.

O VSS possui funções que independem do software e da arquitetura robótica, são
considerados de alto risco e, portanto, não estão disponíveis para
programador e usuário. Em detalhes, as funções do VSS são:
\begin{itemize}
  \item Detecção de falhas: em dispositivos, pelo monitoramento de
  corrente/tensão; no módulo, pela verificação de temperatura/umidade;
  \item Proteção de dispositivos contra sobrecorrente graças a fusíveis;
  \item Distribuição ótima de energia e monitoramento de baterias;
  \item Botão de emergência para desligamento manual ou via rádio.
\end{itemize}

O trilho por onde o robô se desloca é construído a partir de tubos de
policloreto de polivinila (PVC) e possui seções retas, curvas ortogonais de
subida, descida, para a direita e para a esquerda. Os segmentos curvos são tubos
de 1 m dobrados $90^o$, resultando em curvaturas de aproximadamente 630 mm. Um
trilho para testes foi construído no Centro de Pesquisas e
Desenvolvimento da Petrobras (CENPES) e sua extensão é cerca de 140 m.

\section{A arquitetura robótica implementada}

Na seção~\ref{doris}, foi apresentado o robô DORIS e suas funcionalidades. Como
foi definido na seção~\ref{conceitos}, pela visão do autor, o conceito de
\emph{arquitetura robótica} não é equivalente apenas a uma arquitetura de
software, necessitando da avaliação do robô como um todo, isto é, seus
elementos de hardware e sua aplicação. Assim como o desenvolvedor do RDE ROS
\cite{quigley2009ros} evidencia que não há melhor RDE, já que todos apresentam
vantagens e desvantagens e o melhor depende de sua aplicação, também não há
melhor arquitetura robótica, pois esta depende dos hardwares do robô e também da
sua aplicação.

DORIS é um robô móvel com a funcionalidade de inspeção em um ambiente não muito
dinâmico, usando técnicas que exigem grande processamento de imagem (câmeras) e
outros sensores. O usuário final poderá, com o auxílio de uma interface,
programar as missões: inspeção até uma posição do trilho, inspeção de
equipamento, ir até uma posição do trilho, e ronda (inspeção global). Além
disso, o usuário pode tomar o controle manual do robô, e visualizar as
respostas dos sensores.
 
As funcionalidades de inspeção do robô exigem a construção e manutenção do
modelo do mundo, pois há constante comparação com a situação esperada e
possíveis anomalias. Também fica claro que não é só um modelo do mundo que se
faz necessário, mas a construção de modelos distintos para cada componente
de forma a otimizar as missões. Além disso, robôs \textit{offshore} exigem
grande robustez, por trabalharem em ambientes hostis, e que demandam ações rápidas em situações
emergenciais. As exigências de um controle de missão para modos
flexíveis de inspeção, a manutenção de modelos de mundo e a robustez
no controle do robô demandam uma arquitetura híbrida.

No capítulo~\ref{bibliografia}, foi explicitada algumas formas de arquitetura
híbrida, mas aquela com maior número de aplicações bem sucedidas é a arquitetura
híbrida de três camadas, utilizadas desde a aplicação do carro autônomo do
desafio DARPA (Stanley) até a aplicação de exploração do robô da NASA no
planeta Marte. 

Escolhida a arquitetura híbrida de três camadas como arquitetura robótica da
DORIS, faz-se ainda necessário explicitar a implementação de cada camada, isto
é, como e qual executará as funções descritas por Murphy: sequenciador,
gerenciador de recurso, cartógrafo, planejador de missão, e monitor de
desempenho. A arquitetura de três camadas é formada por: camada Funcional,
camada Executiva e camada Planejador, e como cada arquitetura de três camadas
apresenta suas peculiaridades, as camadas desenvolvidas para o robô DORIS são descritas nas
subseções adiante.

\subsection{Implementação da camada Planejador}\label{planejador}

As diversas arquiteturas robóticas de três camadas diferem em relação às
responsabilidades da camada Planejador. \cite{kortenkamp2008robotic}, por
exemplo, aponta que as responsabilidades mais comuns são criar
redes de tarefas hierárquicas, ou agendamentos e gerenciamento de
recursos.  Em \cite{arkin1998behavior}, o Planejador pode assumir
responsabilidades de Adaptador, ou Selecionador, ou Conselheiro (ver seção
\ref{hibrida}). A camada Planejador implementada na DORIS terá as seguintes
responsabilidades:

\begin{itemize}
  \item Controle de missão: como definido na subeção \ref{conceitos}, é a
  interface com o usuário, permitindo que o operador defina as
  missões. Além disso, o controle de missão traduz os comandos de missão do
  usuário ao robô, provê feedback ao operador (\textit{execution monitoring}), 
 e contém as diretivas do robô.
  \item Agendador: é a responsabilidade de agendar as missões, e reorganizá-las
  quando necessário ou quando não há um recurso disponível.
  \item Cartógrafo: é a responsabilidade de criar, e realizar a manutenção dos
  mapas, ou modelos do mundo. Além disso, deve gerar novos mapas para otimizar
  as diversas funções executadas no robô, quando há necessidade.
\end{itemize}

Muitas arquiteturas especializadas em planejamento de trajetórias colocam
esta responsabilidade também para a camada Planejador, outras separam
esta responsabilidade em duas camadas, como um planejamento global e um
planejamento local. Na DORIS, não há um planejamento de trajetória, já que o
trilho é um mapa unidimensional, porém há um planejamento de velocidades
(parte do planejamento de movimento - \textit{Motion Planning}) que será
responsabilidade da camada Funcional.

Antes de detalhar a implementação de cada responsabilidade da camada Planejador,
é necessário definir alguns termos específicos para melhor entendimento desta
dissertação:

\textbf{Definição}: \textbf{Plano de Missão} ou \textbf{plano} é o conjunto de
\textbf{missões} definidas ou escolhidas pelo usuário, em uma interface, a serem
realizadas sequencialmente pelo robô.

\textbf{Definição}: \textbf{Missão} é o comando básico, com alguns parâmetros a
serem definidos (\textit{argumentos}), que o usuário pode dar ao robô, em uma
interface. A \textbf{missão} é um conjunto de tarefas.

\textbf{Definição}: \textbf{Tarefa} é um processo executado pelo robô com um
determinado objetivo. O conjunto de tarefas ordenado sequencialmente compõe a
missão. Uma tarefa pode ser cancelada por outras tarefas (subsunção). 

\textbf{Definição}: \textbf{Estado} é o processo básico definido na
camada Executivo SMACH. Em linguagem de arquitetura robótica, esta definição se
confunde com \textbf{comportamentos} por ser um processo básico e ser modelado
como uma AFSM, porém é uma definição mais geral por não necessariamente
envolver um par estímulo-reação/sensor-atuador. Um conjunto de estados com um
fim compõe uma tarefa.


\subsubsection{Controle de missão} 

O controle de missão é a combinação de três responsabilidades interligadas: a
interface com o usuário, o acompanhamento e feedback das missões ao usuário e a
tradução das missões ao robô. Portanto, o controle de missão é a parte da
arquitetura robótica que faz a interface Homem-Robô: traduz a linguagem do
homeme à linguagem do robô e vice-versa.

A interface de usuário da DORIS possui o conjunto de missões e seus parâmetros
disponíveis para o operador. O usuário pode adicionar missões sequencialmente,
salvar um plano de missão, agendá-lo e/ou executá-lo (botão \textit{Play}). Além
disso, a interface disponibiliza os logs das missões.

A camada Planejador enviará missões à camada Executivo, quando estas estiverem
agendadas ou quando o usuário requisitar. Na subseção~\ref{hibrida}, em
\ref{murphy}, foi exemplificada a responsabilidade de \textbf{Tradutor} da
camada Planejador com um robô assistente que serve cafés. A implementação desta
responsabilidade no DORIS é realizada por um dicionário codificado no robô.
Este método é normalmente conhecido na literatura como \textit{encoded
knowledge} (conhecimento codificado), que são dados incorporados ao código
fonte \textit{hard coded}.

As missões do robô podem ser classificadas em: \textbf{Missões Simples},
\textbf{Missões Complexas} e \textbf{Missões Desconhecidas}. Todas as missões
possuem \textit{argumentos}, entradas mínimas necessárias para a
execução da missão.

As missões simples não necessitam de tradução por já estarem em nível
mínimo de máquinas de estados SMACH. Por exemplo:
\begin{itemize}
  \item \textbf{GOTO}: missão de locomoção do robô até um ponto do trilho. Os
  \textit{argumentos} para esta missão são: posição desejada no trilho, em valor
  absoluto; velocidade desejada, um valor fuzzy: ``slow'' (devagar), ``normal''
  (normal) ou ``fast'' (rápida); direção de movimento, 1 para sentido de
  locomoção para frente (baterias chegam por último) e -1 para sentido
  contrário; número de voltas desejado, em caso de trilho fechado, antes de o
  robô atingir a posição requisitada. O único argumento obrigatório é posição
  desejada, de forma que os valores padrão são: velocidade ``fast''; direção de
  movimento de velocidade mínima; e zero voltas.
  \item \textbf{RECORD\_TYPE}: gravar dados de sensores no robô. Há um 
 \textit{argumentos} para esta missão que pode ser preenchido como: vídeo, áudio
 e termografia. Cada tipo representa uma missão de gravar dados de um sensor
 específico (câmera, microfone e câmera termográfica, respectivamente).
  \item \textbf{STOP\_RECORD\_TYPE}: parar gravação de dados de sensores no
  robô. Assim como a inicialização da missão, há um \textit{argumento} que deve
  ser preenchido: o tipo de gravação, que irá resultar na utilização do sensor
  apropriado para a execução da tarefa.
  \item \textbf{DETECTING\_ANOMALIES\_TYPE}: iniciar algum detector
  específico de anomalia. Há três tipos de detecção de anomalias
  que podem ser escolhidos: vídeo, áudio e termografia. Para cada um deles, há
  uma máquina de estados específica: iniciar algoritmo detector de anomalias por
  câmera, microfones ou câmera termográfica, respectivamente.
  \item \textbf{STOP\_DETECTING\_ANOMALIES\_TYPE}: finalizar algum detector
  específico de anomalia. Assim como iniciar, finalizar apresenta os mesmos três
  tipos de detecção de anomalias: vídeo, áudio e termografia. E Para cada um
  deles, há uma máquina de estados específica: iniciar algoritmo detector de
  anomalias por câmera, microfones ou câmera termográfica, respectivamente.
\end{itemize}

As missões complexas, de mais alto nível, são combinações de
missões simples. Estas necessitam ser traduzidas pelo Planejador com os
argumentos corretos. Por exemplo:
\begin{itemize}
  \item \textbf{GOTO\_BASE}: missão de locomoção do robô à base.
  Não há \textit{argumentos} para esta missão. Tradução necessária para camada
  Executivo: \textbf{GOTO}: posição zero, velocidade ``fast''.
  \item \textbf{INSPECTION}: missão para inspecionar planta em um trecho.
  Necessita que o usuário escolha até onde inspecionar (posição final absoluta
  no trilho) e o tipo de inspeção: vídeo, áudio e termográfico. Tradução: para cada tipo selecionado realizar
  \textbf{DETECTING\_ANOMALIES\_TYPE}; \textbf{GOTO}:
  velocidade ``slow'' (observe que inspeção requer velocidade mínima); para cada
  tipo realizar \textbf{STOP\_DETECTING\_ANOMALIES\_TYPE}.
  \item \textbf{PATROL}: realizar uma ronda completa, isto é, inspecionar toda a
  planta. Não há \textit{argumentos} para esta missão. Tradução:
  \textbf{INSPECTION} (todos os sensores, posição final do trilho).
  \item \textbf{MANIPULATOR\_INSPECTION}: inspecionar um equipamento com
  manipulador. O \textit{argumento} desta missão é o equipamento a
  ser inspecionado. O robô deve ir à posição que se encontra o equipamento, tocar o
  equipamento com o sensor de vibração através do manipulador, e executar uma
  detecção de anomalias por vibração. Em linguagem da camada Executivo, seria
  \textbf{GOTO}: posição do equipamento (requer verificar mapa de equipamentos),
  velocidade ``fast''; \textbf{MANIPULATOR\_POSITION\_CONTROL}: posição
  referente ao equipamento; \textbf{MANIPULATOR\_FORCE\_CONTROL};
  \textbf{START\_DETECTING\_ANOMALIES\_VIBRATION}.
\end{itemize}  

As missões desconhecidas são missões que não estão
descritas no robô, isto é, missões que, até o momento, não pertencem ao
dicionário do robô. Até esta fase da implementação, DORIS não permite que o
usuário use missões desconhecidas. O motivo principal disso é que o robô não
interage com o ser humano de maneira direta, mas apenas através de uma
interface. Vale, porém, explicitar situações de aplicações robóticas em que
missões desconhecidas são essenciais:

\begin{enumerate}
  \item Robô que serve bebidas: uma missão desconhecida é o usuário pedir
  uma bebida que não exista em sua base de conhecimento (mapa de bebidas).
  Durante a tarefa de reconhecer a bebida na geladeira, o robô irá falhar. Porém, o Planejador
  poderia executar uma busca por fotos de bebida em algum site de buscas, antes
  de executar a tarefa, e atualizar a sua base de conhecimento (mapa de
  bebidas), de forma que a tarefa tenha resultado positivo com novo dado.
  \item J.A.R.V.I.S., a inteligência artificial das histórias em quadrinhos
  Iron Man (homem de ferro): comandos por voz normalmente são complexos, já que
  há diversas maneiras de pedir um plano a um robô. Por exemplo, os planos
  ``Robô, preciso de uma tesoura'', ``Robô, dê-me uma tesoura'', ``Robô,
  traga-me uma tesoura'' são planos equivalentes, ditos de maneira diferentes.
  Todas estas diferentes formas devem estar disponíveis em alguma base de
  conhecimento, dentro ou fora do robô, como na nuvem (\textit{cloud}), a qual
  deveria ser compartilhada com todos os robôs que exercem a mesma função.
  RoboEarth \cite{hunziker2013rapyuta} é uma ideia visionária que está buscando
  criar uma \textit{internet dos robôs} (como a \textit{internet das coisas}),
  já está sendo integrada ao ambiente ROS, e sua contribuição é criar um
  repositório na nuvem com missões compartilhadas para todos os robôs que a
  utilizam.
\end{enumerate}

Na interface, o usuário pode escolher sequencialmente um conjunto de missões e
executar, por exemplo, o plano: 
$$\textbf{GOTO(30)}$$
$$\textbf{RECORD\_TYPE('VIDEO')}$$
$$\textbf{INSPECTION('AUDIO',50)}$$
$$\textbf{STOP\_RECORD\_TYPE()}$$ 
$$\textbf{RECORD\_TYPE('AUDIO')}$$
$$\textbf{GOTO\_BASE()}$$
$$\textbf{STOP\_RECORD\_TYPE()}$$ 

O controle de missão da camada Planejador traduz sequencialmente o plano nas
missões simples:

$$\textbf{GOTO(30)}$$
$$\textbf{RECORD\_TYPE('VIDEO')}$$
$$\textbf{DETECTING\_ANOMALIES\_TYPE('AUDIO')}$$
$$\textbf{GOTO(50)}$$
$$\textbf{STOP\_DETECTING\_ANOMALIES\_TYPE('AUDIO')}$$
$$\textbf{STOP\_RECORD\_TYPE()}$$ 
$$\textbf{GOTO(0)}$$
$$\textbf{STOP\_RECORD\_TYPE()}$$ 

Os status, motivo de interrupções, e possíveis erros ocorridos de cada missão
são fornecidos pela camada Executivo. O controle de missão tem acesso fácil a
essas informações graças ao estilo de comunicação publish-subscriber,
característica do \textit{middleware} ROS. Dessa forma, o controle de missão
subscreve o tópico de \textit{Warnings}, interpreta as mensagens, quando
necessário, e disponibiliza esta informação no espaço de logs da interface. 

O controle de missão está implementado, mas ainda não embarcado no robô. A
interface de usuário ainda não foi finalizada, mas testes podem ser realizados
simulando a interface por mensagens de ROS.

\subsubsection{Agendador}

O usuário pode armazenar o plano de missões no robô com data e hora. A
responsabilidade Agendador é verificar a hora agendada para a execução da
missão, executar a missão na hora correta, e, caso esta não seja bem sucedida e
o motivo do insucesso for contornável em tempo estimável, reagendar a missão
para depois. Com o Agendador, o robô ganha uma rotina, o que é importante a
DORIS, um robô de inspeção. A responsabilidade Agendador, porém, ainda não foi
implementada.

\subsubsection{Cartógrafo}

Há diversas formas de armazenar mapas do mundo dentro do robô, como mapas
geométricos, nuvens de pontos, simbólicos, analíticos e outros. Cada forma
apresenta vantagens e desvantagens, de forma que muitas vezes é necessário
armazenar várias formas para otimizar seus usos nas diversas funções do
robô. No caso da DORIS, por exemplo, durante o planejamento de velocidades do
robô, o mapa geométrico 3D do ambiente não é a melhor opção, já que a DORIS se
movimenta em um espaço unidimensional (o trilho), e carregar e processar um
espaço 3D é muito custoso. A camada Planejador deve gerar um mapa
unidimensional, ou um mapa simbólico, para otimizar a função de planejamento de
velocidades. Além disso, a camada Planejador deve manter os mapas gerados
atualizados.

Por ser um robô de inspeção, DORIS possui diversos mapas do mundo:
\begin{enumerate}
  \item Frames de câmera de vídeo (matriz);
  \item Frames de câmera de termográfica (matriz);
  \item Sonoro (analítico);
  \item Seções do trilho (matriz);
  \item Postes (ou outras características marcantes) do ambiente (nuvem
  de pontos);
  \item Scans de laser (nuvens de pontos);
  \item Equipamentos (matriz);
  \item Distâncias do trilho ao solo (analítico);
  \item Arquivo CAD do trilho (CAD);
\end{enumerate}

Os mapas utilizados para inspeção são 1, 2, 3 e 6, e foram gerados com os
sensores câmera fixa, câmera termográfica, microfones e laser, respectivamente.
O mapa 9 é obtido durante a fabricação do trilho e não é mais alterado. O mapa
4 foi gerado pelo CAD da fabricação do trilho, ou seja, a partir do mapa 9, e
será necessário para a locomoção do robô. Os mapas 5 e 8 são gerados a partir do
mapa 6 e são necessários para a localização do robô. O mapa 7 é inserido
manualmente pelo programador, sendo uma matriz que relaciona o equipamento às
suas coordenadas cartesianas.

A camada Planejador ainda não integra, nem faz a manutenção e atualização dos
dos mapas, já que isso requer integração de todos os algoritmos de SLAM do robô,
o que foge do escopo desta dissertação. Entretanto, quando os algoritmos
SLAM forem implementados e testados, é importante que esta responsabilidade seja
finalizada na camada Planejador do robô.

\subsection{Implementação da camada Funcional}

A camada funcional é a primeira implementada e exaustivamente testada no
robô DORIS. Como nas outras arquiteturas de três camadas previamente
apresentadas, a camada Funcional é o nível mais baixo, conecta sensores a
atuadores, implementa controladores PID, e diversos outros algoritmos, por
exemplo para a localização do robô. Utiliza-se Ubuntu/Linux como sistema
operacional e ROS como RDE para a implementação do nível funcional, já que este
apresenta todas as vantagens descritas na subseção~\ref{ros}, e linguagem de
programação C++, a fim de se garantir maior eficiência computacional.

A camada funcional seguiu a recomendação dos desenvolvedores do ROS, sendo
estruturado de maneira semelhante à camada funcional do sistema CLARAty. Neste,
a camada funcional é uma interface com todo o sistema de hardware e suas
capacidades. É um software orientado a objeto, obtendo assim modularidade de
hardware, e uma estruturação apropriada para usar as propriedades de
herança, em software. A figura~\ref{claratyfunc} mostra a organização da camada
Funcional da arquitetura CLARAty.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/claratyfunc.jpg}
\caption{Organização da camada Funcional CLARAty}
\label{claratyfunc}
\end{figure}

Foi proposto o \textit{Robot Package Software}. Neste sistema,
\emph{Tools} (janelas gráficas) e \emph{Componentes} (unidades de comunicação e
processamento) são agrupados em \textit{Robot Package} (bibliotecas dinâmicas).
Os componentes que lidam com hardware rodam no computador embarcado do robô,
já os componentes que interagem com as \textit{tools} rodam no computador base.
Os diversos componentes, tanto do computador embarcado quanto da base, se
comunicam através de mensagens ROS, permitindo que a base controle o robô, na
função de teleoperação \cite{freitas2015embedded}. Os componentes do robô são
o foco de estudos desta dissertação, já que os componentes da base não estão
diretamente ligados à autonomia do robô, mas apenas a uma fração do controle de
missão, que diz respeito à interface com o usuário e \textit{feedback} dos
planos ao usuário.

Dois \textit{Robot Packages} fazem parte no desenvolvimento do robô DORIS:
\textit{General Package} e \textit{DORIS Package}, derivado do primeiro. Outros
robôs desenvolvidos por GSCAR, como o ROV LUMA, possuem seus pacotes
específicos, derivados do \textit{General Package}. 

O \textit{General Package} contém os componentes e \textit{tools} gerais
relacionados a vídeo, áudio, tabela de dados, \textit{gamepad} (para controle
remoto de robôs), e configurações de dispositivos que podem ser usados em outros
robôs

O \textit{DORIS Package} é um pacote mais específico ao robô DORIS e lida com
seus elementos de hardware e suas funcionalidades. Do ponto de vista de uma
arquitetura robótica, neste pacote foram implementados os \emph{comportamentos}
específicos do robô DORIS.  Os diversos componentes implementados para o DORIS
foram divididos em funcionalidades, neste trabalho, a fim de proporcionar melhor
entendimento.

Como já descrito na seção~\ref{doris}, os atuadores para locomoção e para o
manipulador do DORIS se comunicam via CAN-Bus, que provê velocidade e
transferência confiável dos dados \cite{corrigan2008introduction}. Esta
comunicação extra, exigiu a implementação do componente \emph{CANOpen}, que utiliza a biblioteca
SocketCAN disponivel em Linux. Um componente \emph{EPOS} é classe derivada de
\emph{CANOpen} e especifica este tipo de comunicação com o hardware EPOS
(driver) utilizado no DORIS, além de implementar outras caracterísiticas do
driver, como os dados dos encoders dos motores: posição (odometria), velocidade
e corrente.
Além disso, há a \emph{EPOSNodelet}, classe derivada de \emph{EPOS}, que implementa a comunicação ROS. A implementação dos
componentes respeita a sugestão do desenvolvedor do \textit{framework}, de forma
que sempre há a criação de uma classe padrão C++ e uma classe derivada dentro do
ambiente ROS, que usa os métodos do \textit{framework}.

Os componentes que executam o controle de locomoção do robô são:
\emph{Controller}, \emph{ControllerNodelet} (derivada de \emph{Controller}),
\emph{MotionController} (derivada de \emph{Controller}),
\emph{MotionControllerNodelet} (derivada de \emph{MotionController}),
\emph{PositionController} (derivada de \emph{Controller}) e
\emph{PositionControllerNodelet} (derivada de \emph{PositionController}). Os
componentes \emph{Controller} e \emph{ControllerNodelet} (componente
\emph{Controller} com os recursos de ROS) são classes genéricas de controle,
sendo necessária a implementação do controle para o robô específico,
componentes \emph{MotionController} e \emph{PositionController}.

Os quatro hardwares EPOS possuem uma malha de controle PD ou
PID para realizar o controle do robô por velocidade ou corrente, porém de
maneira independente para cada motor. A sincronia e ajustes dessas malhas de
controle são realizados no componente \emph{MotionController}. Este componente
se comunica por serviço de ROS (\textit{service}) com o componente
\emph{EPOSNodelet}, enviando os valores de velocidade desejados para cada motor.
Por exemplo, observe que, em uma curva, devido à distância entre os dois gimbals
do robô e à distância entre as rodas dos gimbals, os motores devem possuir
velocidades diferentes. O \emph{MotionController} envia set-points de
velocidade às EPOS e pode alterar os parâmetros de aceleração e
desaceleração. Além disso, este componente é responsável por receber entradas do
componente \emph{Joystick} e \emph{Interface}, que podem controlar o robô pela
base, ou \emph{MissionController}, o componente de missão autônoma. Há apenas
a prioridade do \emph{MissionController} sobre todos os outros controladores,
tal que, com exceção do \emph{MissionController}, o componente que irá
controlar será o primeiro que pedir o controle.

O componente \emph{PositionController} será futuramente integrado ao
\emph{MotionController}. Sua funcionalidade é realizar um controle de posição,
logo possui uma malha interna de controle, não disponível no hardware da EPOS, e
se comunica com o componente \emph{MotionController}, enviando set-points de
velocidades. É um controle proporcional de posição com saturação de velocidade.

O manipulador da DORIS utiliza mais quatro EPOS (quatro motores) e exigirá ainda
a implementação de um controle de força para sensoriamento de equipamentos ao
toque, a partir de um sensor de vibração. Componentes como \emph{ForceControl} e
\emph{InspectionVibration} ainda estão em desenvolvimento em.
%TODO referencia marco

Ainda em fase de aperfeiçoamento, os componentes de localização
\emph{Localization} e \emph{LocalizationNodelet} recebem mensagens de ROS
(\textit{subscriber}) do componente \emph{EPOSNodelet}, os dados da odometria,
isto é, quanto cada roda girou. Dentro de \emph{Localization} é feita uma média
para estimar quanto o robô se locomoveu. Em implementação, está sendo feito um
sistema inteligente de localização com os dados dos sensores IMU e LaserScan. A
fusão de sensores permitirá estimar de maneira precisa a posição do robô. O
\emph{LocalizationNodelet} ainda envia mensagens (\emph{Publish}) para o
\emph{PositionController}, \emph{MotionController} e \emph{RVIZ}, um componente
de vizualização para o usuário.

Os diversos componentes de sensores, no robô, são: \emph{AudioSender},
\emph{AudioSenderNodelet} (derivada de \emph{AudioSender}),
\emph{VideoSender}, \emph{VideoSenderNodelet} (derivada de
\emph{VideoSender}), \emph{VideoWebcamera} (derivada de
\emph{VideoSenderNodelet}), \emph{AxisVideo} (derivada de
\emph{VideoSenderNodelet}), \emph{LMS1xx}, \emph{IMU}, \emph{IMUNodelet} e
\emph{ColorDetector}.

O componente \textit{AudioSender} é um driver que faz a interface com os diversos
microfone disponíveis no robô. Comunica-se (\textit{publisher}) por mensagem de
ROS com o componente da base \textit{AudioReceiverNodelet} (\textit{subscriber})
para disponibilizar os dados ao usuário. Futuramente, irá se comunicar
(\textit{publisher}) com o \textit{InspectionAudioNodelet} (\textit{subscriber}),
um componente que compara o áudio da base de dados do robô e detecta anomalias através de um algoritmo de reconhecimento de padrões.

O componente \textit{VideoWebcamera} é um driver que faz a interface com as duas
câmeras webcams disponíveis no robô. Comunica-se
(\textit{publisher}) com o componente da base
\textit{VideoReceiverNodelet} (\textit{subscriber}) para disponibilizar os dados
ao usuário, e com o componente \textit{ColorDetection} (\textit{subscriber}), um
algoritmo que verifica a porcentagem de vermelho obtida em cada frame da
câmera. Futuramente, o componente \textit{ColorDetection} irá se comunicar
(\textit{publisher}) com o \textit{Localization} (\textit{subscriber}), já que a
informação de vermelho no trilho será utilizada para calibrar a
localização.

O componente \textit{LMS1xx} é um driver que faz a interface com o LaserScan,
sensor que realiza um escaneamento a laser do ambiente. Comunica-se
(\textit{publisher}) com o componente da base \textit{LaserReceiverNodelet}
(\textit{subscriber}) para disponibilizar os dados ao usuário. Futuramente, irá
também se comunicar com o \textit{PoleDetection} (\textit{subscriber}), que possui
um algoritmo para detecção de postes, e o \textit{Localization} (\textit{subscriber}), já que
este é mais um sensor que provê dados para o sistema de localização (altura do
robô).

O componente \textit{IMU} é um driver que faz a interface com a \textit{IMU}.
Ele envia uma lista de dados: velocidade, orientação, posição, pólos
magnéticos e outros. Futuramente, também irá se comunicar com o
\textit{Localization}.

O componente \textit{AxisVideo} é um driver que faz a interface com a câmera fixa
da AXIS. Comunica-se (\textit{publisher}) com o componente
da base de mesmo nome para disponibilizar os dados ao usuário. Futuramente, o
algoritmo de detecção de anomalias por vídeo será integrado ao sistema ROS,
logo um componente \textit{InspectionVideo} será \textit{subscriber} do mesmo
tópico.

A FIGURA represente o esquema de comunicação entre os diversos componentes e
suas hierarquias.

\subsubsection{Planejamento de velocidades}

A DORIS se locomove em um trilho (mapa unidimensional), logo não há a
necessidade de computação de um \textit{Motion Planning} complexo. Quando uma
missão do tipo \textbf{GOTO} é requisitada, apenas são calculadas as
velocidades de segurança e compensação das rodas do robô, não a trajetória, pois
só há uma trajetória possível, ou duas, caso o trilho seja circular. Apesar de o
\textit{Motion Planning} estar na camada Funcional, ele também é fundamental
para a autonomia do robô, portanto o autor desenvolveu sua implementação. 

O processo chamado \textit{MasterPlanning} é um \textit{thread} inicializado
junto ao robô e que subscreve ao tópico \textit{DORIS/Vehicle/Path\_Planning}
para obter os parâmetros de entrada e publica sua saída ao tópico
\textit{DORIS/Vehicle/Path\_Planning/Plan}. Suas entradas são: localização
atual do robô; localização objetivo; direção de movimento (1 ou -1 - sentido
natural ou sentido contrário); número de voltas desejado antes de chegar à
localização objetivo; e se o trilho é circular (verdadeiro ou falso). Sua saída
é uma matriz com $n$ linhas e três colunas: a primeira coluna representa a posição
do trilho onde ocorre troca de velocidade máxima; a segunda coluna é a
velocidade máxima; a terceira é o \textit{set-point} de posição.

A matriz de saída será utilizada pela tarefa
\textit{Motion\_Planning\_Position} da camada Executivo, a qual se comunica com
o processo da camada Funcional \textit{PositionController}. Portanto, no modo
autônomo, DORIS será controlada por posição, havendo a necessodade de
especificar velocidades máximas para cada trecho do trilho. O mapa do
trilho é uma matriz de duas colunas: a primeira coluna representa o tipo de
trecho do trilho (reta, transição reta-subida, transição reta-descida, subida,
descida, curva à direita, curva à esquerda); a segunda coluna se refere ao
comprimento do trecho. O robô pode acelerar nas retas, mas deve reduzir a
velocidade em curvas, onde há compensação de velocidades devido ao comprimento
do robô e à distância entre as rodas em um mesmo gimbal, e em subidas e
descidas, onde grandes velocidades produzirão muito esforço e desgaste nos
motores/engrenagens.

Durante uma missão do tipo \textit{GOTO}, a tarefa
\textit{Motion\_Planning\_Position}, após obter a localização do robô, envia um
pedido de planejamento de velocidades ao processo \textit{MasterPlanning}, em
uma mensagem com todas as entradas necessárias. \textit{MasterPlanning} tem
acesso ao mapa do trilho, disponibilizado pelo Cartógrafo,
e possui um dicionário de três possíveis velocidades máximas ($V_{max}$):
``fast'', ``normal'' e ``slow'', mapeadas em 0.6, 0.3 e 0.1 m/s respectivamente.

As velocidades máximas dos trechos do trilho são proporconais à $V_{max}$ e
escolhidas empiricamente: $V_{reto} = V_{max}$; $V_{reto/subida} = 0.7*V_{max}$;
$V_{reto/descida} = 0.7*V_{max}$; $V_{curva} = 0.85*V_{max}$; $V_{subida} =
0.5*V_{max}$; $V_{descida} = 0.5*V_{max}$. A fim de garantir que o robô chegue
em determinado trecho respeitando a velocidade máxima deste, o
\textit{MasterPlanning} calcula a posição de troca de velocidade máxima pela
equação de Torricelli: $v_{f}^2 = v_{0}^2+2a\Delta S$. $\Delta S$
representa a distância percorrida, ou seja, a posição de troca de velocidades
e $a$ é a aceleração/desaceleração máxima da EPOS ($a=0.11 m/s^2$).

\textbf{Exemplo}

Suponha que o robô está na posição 0 do trilho e começa a execução da tarefa
\textit{Motion\_Planning\_Position} da missão \textit{GOTO(10,'fast')}. A função
$master\_planning(0,'fast',10)$ retorna a matriz~\ref{matrizvmax}, que pode ser
interpretada graficamente em ~\ref{plvl}. 

\begin{table}[!ht]
\centering
\caption{Matriz de velocidades máximas em cada trecho do trilho do ponto 0 ao
10.}
\label{matrizvmax}
\begin{tabular}{ccc}
\hline
\multicolumn{1}{l}{Ponto de troca (m)} & \multicolumn{1}{l}{$V_{max}$ (m/s)} &
\multicolumn{1}{l}{Set-point (m)} \\ \hline 0                                  &
0.6                           & 10                            \\
1.907                              & 0.42                          & 10                            \\
3.355                              & 0.3                           & 10                            \\
4.495                              & 0.42                          & 10                            \\
5.506                              & 0.6                           & 10                            \\
5.847                              & 0.51                          & 10                            \\
7.308                              & 0.6                           & 10                            \\
8.334                              & 0.42                          & 10                            \\
9.282                              & 0.3                           & 10                           
\end{tabular}
\end{table}

\begin{figure}[!ht]
\centering
\includegraphics[width=.8\columnwidth]{figs/masterplot.png}
\caption{representação gráfica do plano de velocidades do robô para uma missão
de GOTO(10,'fast').}
\label{plvl}
\end{figure}

O mapa das seções do trilho até a posição 10, disponível pelo Cartógrafo, está
representado na tabela~\ref{mapatrilho}. Observe que o trecho inicial ``Reto"
possui comprimento 2.733 m e velocidade máxima 0.6 m/s, mas antes de o robô
chegar no final do trecho, ele começa o processo de desaceleração em 1.907 m de
forma a ser possível fazer a troca de trecho na velocidade máxima permitida para
a ``Transição reto-subida'' (0.42 m/s).

\begin{table}[!ht]
\centering
\caption{Mapa das seções do trilho}
\label{mapatrilho}
\begin{tabular}{ccc}
\hline
Tipo de trecho         & Comprimento (m) & Soma (m)  \\ \hline
Reto                   & 2.733       & 2.733 \\
Transição reto-subida  & 1.011       & 3.744 \\
Subida                 & 0.750       & 4.495 \\
Transição subida-reto  & 1.011       & 5.506 \\
Reto                   & 0.790       & 6.297 \\
Curva à esquerda       & 1.011       & 7.308 \\
Reto                   & 1.852       & 9.160 \\
Transição reto-descida & 0.510       & 9.670 \\
Descida                & 0.790       & 10.46
\end{tabular}
\end{table}

\subsection{Implementação da camada Executivo}

A camada Executivo elaborada para a DORIS usa SMACH (subseção~\ref{smach}) como
\textit{framework}, e implementa a técnica de função de coordenação competitiva
(subseção~\ref{reativa}), a arquitetura de subsunção, onde o módulo básico de
comportamento reativo é uma máquina de estados aumentada (\textit{AFSM}), como a
figura~\ref{afsm} sem \textit{Reset}. A camada Executivo é essencial para a
autonomia do robô, portanto também é o escopo da implementação do autor e, junto
com a camada Planejador.

As subseções a seguir detalham a implementação da camada Executivo,
identificando como é realizada cada responsabilidade: Sequenciador,
Selecionador, Gerenciador de recursos, e Monitoramento da execução e
recuperação de erros (\textit{Execution monitoring and error recovery}). Como o
ambiente de desenvolvimento da camada Funcional é ROS, optou-se pela utilização
da camada Executivo SMACH \cite{bohren2010smach} por demonstrar resultados
positivos em diversas aplicações, e já ser integrada ao sistema ROS. Foram
adicionadas algumas funcionalidades à camada a fim de garantir todas as
responsabilidades de uma camada Executivo. Como a camda Executiva não executa
algoritmos de alto processamento, como a camada Funcional, foi escolhida a
linguagem Python.


\subsubsection{Sequenciador e Selecionador}
SMACH é um \textit{framework} para projetar máquinas de estados hierárquicas
concorrentes. As máquinas de estados de SMACH possuem características bem
peculiares não encontradas em máquinas de estados formais, como a \textit{user
data}, comentada na subseção~\ref{smach}. O \textbf{Sequenciador} e
\textbf{Selecionador} desenvolvidos para a DORIS utilizarão as capacidades de
SMACH e as vantagens de ROS para a modelagem das tarefas do robô.

Como seres humanos, robôs deveriam possuir um conjunto de
processos que estão sempre em execução, e outros conjuntos de processos que só
entrarão em execução dependendo da missão a ser executada. Por exemplo,
em um ser humano, os processos vitais, como ``respirar'' e ``o bombear do
coração'', estão sempre em execução. Alguns podem ser postos em
espera por um tempo, como ``respirar'', e outros são incontroláveis, como ``o bombear
do coração''. 

\textbf{Definição}: \textbf{Processo reativo vital} é um processo que deve ser
executado sempre que o robô estiver em modo autônomo. É o tipo de processo vital
ao robô, garante robustez, proteção ou a sobrevivência do sistema e aos seus
dispositivos.

Dependendo da missão a ser realizada, além das tarefas que a especificam, um
conjunto de processos paralelos começa a ser executado de maneira automática a fim de
garantir o sucesso da missão, ou como novas formas de proteção do
sistema aos novos perigos que a missão pode impor. Para o ser humano, em missões
como ``palestrar'', ``produzir um relatório'', e ``ir a um evento'', os
processos ``falar'', ``escrever'' e ``desviar de pessoas e objetos'' são
automáticos e executados somente durante a realização das missões. 

\textbf{Definição}: \textbf{Processo reativo específico} é um processo
executado paralelamente às tarefas da missão, quando esta começa a ser
realizada. São processos específicos de uma determinada missão, e
inicializados automaticamente. Podem garantir
robustez, proteção, sobrevivência do sistema, ou melhorar a execução da missão.

Os \textbf{processos reativos vitais} e \textbf{processos reativos
específicos} podem interromper a execução de tarefas das missões temporaria ou
definitivamente. Por exemplo, uma falha no bombeamento do coração cancela
imediatamente qualquer missão em execução. Esta característica de supressão dos
\textbf{processos reativos} foi modelada pela função de coordenação competitiva,
subsunção. Desta forma, foi implementada uma classe, derivada de SMACH, para a
AFSM padrão de todas as tarefas da DORIS. A classe também depende de ROS, e
foi idealizada para absorver a vantagem do estilo de comunicação
\textit{publish/subscriber}, tornando a modelagem das tarefas bastante modular.

O módulo básico, chamado \textbf{SUPPRESSION\_STATE}, é um \textit{container}
SMACH do tipo \textit{concurrence} (concorrente), isto
é, um \textit{container} composto por dois \textit{containers} que são executados simultaneamente.
Um dos \textit{containers} concorrentes é o \textit{MAIN}, composto por tarefas
sequenciais que executam a missão. O outro \textit{container} concorrente é o
\textit{SUPPRESSION\_MAIN}, responsável por abortar a missão
(\textit{container} \textit{MAIN}) caso receba uma mensagem ROS
'Abort' (em tópico específico) de outro módulo (exemplo na
figura~\ref{supression}).

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/goto.png}
\caption{Exemplo do módulo básico para a missão simples \textbf{GOTO}.}
\label{supression}
\end{figure}

Desta forma, um \textbf{processo reativo vital} pode abortar uma missão,
enviando uma mensagem ROS \textit{'Abort'} ao tópico
\textit{'DORIS\_MCS\_MISSION'}. O módulo básico implementado torna a estrutura
da camada Executivo muito mais flexível, modular e estimula o paralelismo, sem
a preocupação de tarefas conflitantes, já que os conflitos são resolvidos pela
subsunção, mais flexível que um esquema de prioridades. Além disso, a
modelagem do robô fica mais intuitiva e correspondente à natureza.

O problema de \textit{situatedness} (subseção~\ref{brooks}) é resolvida pela
decomposição em \textit{processos reativos vitais},
\textit{processos reativos específicos} e pelas tarefas que compõem
sequencialmente a missão. Não são todos os comportamentos que estão
sempre em execução, mas apenas os essenciais (``vitais'') para o robô e aqueles
que possuem alguma relação com a missão. Essa responsabilidade de classificar
os processos e escolher qual entrará em ação é chamada de \textbf{Selecionado},
foi implementada na camada Executivo e resolve um grande problema de
arquiteturas de subsunção.

A responsabilidade Sequenciador é quebrar as missões do Planejador em tarefas,
que, no caso do SMACH, são sequências de máquinas de estados SMACH. O
programador deve, por tanto, modelar a quebra de uma missão em tarefas
utilizando o \textit{framework} SMACH e adicionar a decomposição à base de
conhecimento da camada Executivo.


\paragraph{Processos reativos vitais na DORIS}

Os \textbf{processos reativos vitais} criados para a DORIS são:
\begin{itemize}
  \item \textbf{STATE\_OF\_CHARGE}: obtém os status das baterias se
  comunicando com o \textit{VSS} da camada Funcional. Caso a carga das
  baterias esteja inferior a $5\%$, o robô deve parar todos as missões e
  processos reativos. O processo envia mensagem 'Abort' aos tópicos de todas as
  missões: \textit{'DORIS/MCS/INSPECTION'}, \textit{'DORIS/MCS/PATROL'}, \textit{'DORIS/MCS/RECORD\_TYPE'},\textit{'DORIS/MCS/GOTO'}; e a alguns
  processos reativos: \textit{'DORIS/MCS/StateOfTempAndHum'}.
  \item \textbf{STATE\_OF\_TEMPERATURE\_AND\_HUMIDITY}: obtém as condições de
  temperatura e umidade externas se comunicando com o \textit{VSS}. Quando
  as condições estão fora do nível de operação do robô, este suspende as
  missões. O processo envia mensagem 'Abort' aos tópicos de todas as missões:
  \textit{'DORIS/MCS/INSPECTION'}, \textit{'DORIS/MCS/PATROL'},
  \textit{'DORIS/MCS/RECORD\_TYPE'}, \textit{'DORIS/MCS/GOTO'}, e outras.
\end{itemize}

\paragraph{Processos reativos específicos na DORIS}

No DORIS, um \textbf{processo reativo específico} foi implementado para
a missão simples \textbf{GOTO}: 
%TODO decompor obstacle
\begin{itemize}
  \item \textbf{OBSTACLE\_DETECTION}: detecta a presença de obstáculos. Foram
  criados dois estados concorrentes SMACH, um faz a detecção
  por câmera fixa por um algoritmo de anomalias no trilho (figura~\ref{camera}),
 outro pelo sensor de consumo de corrente dos motores (comunicação com
 EPOSNodelet da camada Funcional, figura~\ref{epos}), o qual se muito elevado,
 representa choque com algum obstáculo (a mesma
 logica deste estado pode ser encontrado em \cite{christensen2011cost}).
 Caso um dos sensores detecte obstáculo, o estado seguinte do \textbf{OBSTACLE\_DETECTION} aborta a tarefa
  \textbf{MOTION\_POSITION\_CONTROL}, pertencente à missão \textbf{GOTO}
  (mensagem ROS 'Abort' ao tópico
  \textit{'DORIS/MCS/MOTION\_POSITION\_CONTROL'}), e controla a velocidade do
  robô para zero. A figura~\ref{mainoa} mostra o processo em alto nível. 
\end{itemize}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/camera.png}
\caption{Estado \textbf{CAMERA} do processo reativo específico
\textbf{OBSTACLE\_DETECTION}.}
\label{camera}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/epos.png}
\caption{Estado \textbf{EPOS} do processo reativo específico
\textbf{OBSTACLE\_DETECTION}.}
\label{epos}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainoa.png}
\caption{Estados do processo reativo específico \textbf{OBSTACLE\_DETECTION}.}
\label{mainoa}
\end{figure}

Outro processo reativo específico para a missão \textbf{GOTO} é o
\textbf{AVAILABLE\_ENERGY}, ainda não implementado. Este processo poderá
calcular a variação da energia consumida durante uma missão e inferir se há
energia suficiente para a conclusão. Caso não haja, a missão deve ser abortada.

\paragraph{Tarefas na DORIS}
As tarefas criadas para a DORIS são detalhadas sequencialmente, conforme a
missão simples:
\begin{itemize}
  \item \textbf{GOTO}: \textbf{Localization}, \textbf{PathPlanning},
  \textbf{Motion\_Control\_Position}. Figura~\ref{maingoto}.  
\begin{itemize}
  \item \textbf{Localization}: espera receber mensagem da camada Funcional com
  a localização e a probabilidade. Caso esta probabilidade seja menor que 50\%,
  o estado \textbf{Wander} é ativado. Figura~\ref{mainlocalization}
\begin{itemize}
  \item \textbf{Wander}: estado um loop que recebe a localização do robô e a
  probabilidade. Caso a probabilidade seja menor que 50\%, o estado se comunica
  com o \textit{MotionControllerNodelet} e realiza controle de velocidade
  do robô a $0.1 m/s$, até que o robô consiga se localizar com maior precisão.
  Quando a probabilidade mínima é alcançada, o estado retorna ``sucesso''.
\end{itemize}  
  \item \textbf{PathPlanning}: comnunica-se com o \textit{MasterPlanning} da
  camada funcional para obter o plano de velocidades do robô, no trilho. Seu \textit{user data} é o plano de
  velocidades.
  \item \textbf{Motion\_Position\_Control}: comunica-se com o
  \textit{PositionControlNodelet} da camada Funcional para enviar o plano de
  velocidades. A tarefa fica em loop, obtendo localização do robô e enviando o
  plano de velocidade, conforme a mudança de localização.
  Figura~\ref{maincontrol}.
\end{itemize}
  \item \textbf{RECORD\_TYPE}: comunica-se com os a
  camada Funcional para gravação dos dados no SSD
  embarcado. Espera o comando de 'Abort', que será enviado pela
  missão \textbf{STOP\_RECORD\_TYPE}. Figura~\ref{mainrecord}.
  \item \textbf{STOP\_RECORD\_TYPE}: envia mensagem 'Abort' ao tópico
  \textit{'/DORIS/MCS/RECORD'}.
  \item \textbf{DETECT\_TYPE}: comunica-se com os algoritmos de inspeção da
  camada Funcional. Espera o comando de 'Abort', que será enviado pela
  missão \textbf{STOP\_DETECT\_TYPE}.
\end{itemize}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/main_goto.png}
\caption{Tarefas da missão simples \textbf{GOTO}.}
\label{maingoto}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainlocalization.png}
\caption{Estados da tarefa \textbf{Localization}.}
\label{mainlocalization}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainmotioncontrol.png}
\caption{Estados da tarefa \textbf{Motion\_Position\_Control}.}
\label{maincontrol}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainrecord.png}
\caption{Estados da tarefa \textbf{RECORD\_TYPE}.}
\label{mainrecord}
\end{figure}


\subsubsection{Gerenciador de recursos}

A camada Executivo tem a responsabilidade de gerenciar os recursos do robô pelas
missões, isto é, compartilhar, estabelecer prioridades e verificar a
disponibilidade dos sensores e atuadores do robô aos processos em execução. 

O compartilhamento de sensores, dados e processamento de sensores estão
sempre disponíveis a todas funções e processos do robô, graças ao estilo de
comunicação \textit{publish/subscriber} do \textit{framework} ROS. Os atuadores,
no entando, só estão disponíveis a executar uma tarefa por vez. Por exemplo, o
manipulador da DORIS não tem condições de inspecionar dois equipamentos ao mesmo
tempo; um robô com um manipulador que serve bebidas não é capaz de buscar
três bebidas simultaneamente; um robô submarino com apenas uma câmera sob um
sistema \textit{Pan \& Tilt} (atuador) não pode compartilhar a câmera para navegação e
observação da cauda simultaneamente. 

ROS soluciona o problema de compartilhamento de sensores, e o Sequenciador,
junto com a subsunção, resolve o problema de prioridades. As missões são
sequenciais, não paralelas, logo não há perigo de compartilhamento de atuadores
entre missões. O conflito ocorre quando processos reativos, paralelos às
missões, necessitam do mesmo recurso da missão. O esquema de função de
coordenação competitiva é a solução para os conflitos.

Por fim, a disponibilidade de recursos é essencial para a execução das missões.
Caso seja dada uma tarefa de inspeção com manipulador, na DORIS, o robô não deve
executar todas as tarefas da missão e, ao fim, verificar que o sensor de
vibração não está disponível. Os \textbf{processos de
recursos disponíveis} são individuais para cada recurso e verificam se o sensor
está disponível. Caso o recurso não esteja disponível, a missão que o utiliza é
automaticamente abortada (subsunção).

\textbf{Definição}: \textit{Processos de recursos disponíveis} são processos
reativos que monitoram os status dos recursos do robô (sensores e atuadores).
Estes processos podem abortar missões específicas, por exemplo, o
uma falha no \textbf{processo de recurso disponível} \textit{EPOS\_RESOURCE}
aborta a missão simples \textbf{GOTO} caso esta esteja no plano de missão do
robô.

\subsubsection{Monitoramento de tarefas e recuperação de
erros}\label{monitoamento}

O controle de missão da camada Planejador fornece ao usuário os status das
missões e os erros, junto com os motivos das falhas. Entretanto, ele apenas
interpreta e mostra os dados fornecidos pela camda Executivo, isto é, o
controle de missão possui um \textit{thread} nó de ROS subscritor do tópico
\textit{Warning} e \textit{loginfo}. A camda Executivo envia para este tópico os
status das missões que estão sendo executadas.

O SMACH possui um monitoramento de tarefas simplificado, de forma que todos os
estados publicam no tópico \textit{loginfo} os eventos ocorridos: transições de
estados, transições de \textit{containers}, \textit{outcomes} e \textit{user
data}. O \textit{Smach Viewer} (visualizador SMACH) e o
controle de missão subscrevem a este
tópico e, desta forma, é possível gerar um log detalhado ao usuário.

Além do uso do monitoramento simples do SMACH, foi desenvolvida uma classe
derivada para reportar acontecimentos de subsunção de processos, ou seja, quando
um \textit{processo reativo} aborta uma tarefa ou missão, o \textit{processo reativo} envia
automaticamente uma mensagem ao tópico \textit{Warning}, reportando o motivo do
cancelamento. Esta informação é a mais valiosa para o operador,
visto que é extremamente importante o usuário saber o motivo detalhado do
cancelamento de uma determinada missão. Por exemplo, pode haver diversos
motivos para o robô falhar a missão \textit{INSPECTION('VIDEO',30)}, e o
usuário, sem saber o motivo, pode tentar executar a missão diversas vezes
obtendo sempre uma falha ``misteriosa''. A um programador seria ainda necessário
o debug do código completamente, e mesmo somente nas tarefas que contém a missão
é muito trabalhoso. O monitoramento de tarefas exige, portanto, explicações
detalhadas da falha a fim de facilitar o uso do robô.

A recuperação de erros pode ser implementada no SMACH como novas tarefas da
missão. Como cada estado SMACH pode ter $n$ \textit{outcomes}, a falha de
execução de um processo poderia levar a um estado de recuperação. Um exemplo
disso é a implementação do \textbf{processo reativo específico}
\textbf{OBSTACLE\_DETECTION}, o qual cancela a tarefa
\textbf{MOTION\_POSITION\_CONTROL}. Em caso de cancelamento, a missão
\textbf{GOTO} não é abortada por inteiro, mas entra em uma tarefa de
recuperação, a qual busca uma nova trajetória para a DORIS (sentido contrário,
em caso de trilho circular).