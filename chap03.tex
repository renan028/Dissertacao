\chapter{Arquitetura proposta}\label{arquipro}
%TODO formalização da linguagem
O capítulo~\ref{bibliografia} apresentou os conceitos necessários para o
entendimento desta dissertação, mostrou a evolução das arquiteturas robóticas e
controles de missão, e as diversas aplicações em robôs modernos. A autonomia de
um robô depende, em grande parte, do desenvolvimento desta arquitetura robótica.

Neste capítulo, será apresentada uma implementação da arquitetura híbrida de
três camadas, utilizando o ambiente de desenvolvimento ROS, para um robô
móvel que executa tarefas de inspeção, a DORIS. Como definido no
Capítulo~\ref{bibliografia}, a arquitetura robótica não é apenas uma
arquitetura de software, mas sim uma arquitetura que depende dos
componentes físicos do robô (hardware) e a sua aplicação.

\section{A arquitetura robótica implementada}

Na Seção~\ref{doris}, foi apresentado o sistema robótico DORIS e suas
funcionalidades.
Como foi definido na Seção~\ref{conceitos}, pela visão do autor, o conceito de
\textit{arquitetura robótica} não é equivalente a uma arquitetura de
software, é necessária a avaliação do robô como um todo, isto é, seus
elementos de hardware e sua aplicação. O desenvolvedor de ROS
\cite{quigley2009ros} já afirmava que não há melhor RDE, já que
todos apresentam vantagens e desvantagens, e o mesmo pode ser afirmado no
contexto mais amplo de arquitetura robótica e em paradigmas. A arquitetura ideal
para um robô pode ser ineficiente para outro. A arquitetura robótica desenvolvida tenta
ser geral para robôs com características e desafios semelhantes ao sistema
robótico DORIS, como AUVs e UGVs.

DORIS exigem grande processamento de imagem (câmeras) e de
outros sensores. O usuário final poderá, com o auxílio de uma interface,
programar as missões: inspeção até uma posição do trilho, inspeção de
equipamento, ir até uma posição do trilho, e ronda (inspeção global). Além
disso, o usuário pode tomar o controle manual do robô, e visualizar as
respostas dos sensores.
 
As funcionalidades de inspeção do robô exigem a construção e manutenção do
modelo do mundo, pois há constante comparação com a situação esperada e
possíveis anomalias. Também fica claro que não é só um modelo do mundo que se
faz necessário, mas a construção de modelos distintos para cada componente
de forma a otimizar as missões. Além disso, robôs \textit{offshore} exigem
grande versatilidade, flexibilidade e resistência, por trabalharem em ambientes
hostis, e que demandam ações rápidas em situações emergenciais. As exigências de um controle de missão para modos
flexíveis de inspeção, a manutenção de modelos de mundo e a robustez
no controle do robô demandam uma arquitetura híbrida.

No Capítulo~\ref{bibliografia}, foi explicitada algumas formas de arquitetura
híbrida, mas aquela com maior número de aplicações bem sucedidas é a arquitetura
híbrida de três camadas, utilizadas desde a aplicação do carro autônomo do
desafio DARPA (Stanley) até a aplicação de exploração do robô da NASA no
planeta Marte. 

Um vez que a arquitetura híbrida de três camadas foi escolhida como arquitetura
robótica do sistema robótico DORIS, ainda é necessário desenvolver a
implementação de cada camada, isto é, como e qual executará as funções descritas por Murphy: sequenciador, gerenciador de recurso, cartógrafo, controle de missão, e monitor de
desempenho. A arquitetura de três camadas é formada por: camada Funcional,
camada Executivo e camada Planejador, e como cada arquitetura de três camadas
apresenta suas peculiaridades, as camadas do sistema robótico DORIS são
detalhadas adiante.

\subsection{Implementação da camada Planejador}\label{planejador}

As diversas arquiteturas robóticas de três camadas diferem em relação às
responsabilidades da camada Planejador. Kortenkamp \cite{kortenkamp2008robotic},
por exemplo, aponta que as responsabilidades mais comuns da camada Planejador
são criar redes de tarefas hierárquicas, ou agendamentos e gerenciamento de
recursos.  Em \cite{arkin1998behavior}, o Planejador pode assumir
responsabilidades de Adaptador, ou Selecionador, ou Conselheiro (ver Seção
\ref{hibrida}). A camada Planejador implementada no sistema robótico DORIS terá
as seguintes responsabilidades:

\begin{itemize}
  \item Controle de missão: como definido na subeção \ref{conceitos}, é a
  interface com o usuário, permitindo que o operador defina as
  missões. Além disso, o controle de missão traduz os comandos de missão do
  usuário ao robô e provê feedback ao operador (\textit{execution monitoring}).
  \item Agendador: é a responsabilidade de agendar as missões, e reorganizá-las
  quando não há um recurso disponível ou em caso de falha.
  \item Cartógrafo: é a responsabilidade de criar, e realizar a manutenção dos
  mapas, ou modelos do mundo. Além disso, deve gerar novos mapas para otimizar
  as diversas funções executadas no robô, quando houver necessidade.
\end{itemize}

Muitas arquiteturas especializadas em planejamento de trajetórias colocam
esta responsabilidade também para a camada Planejador, outras a separam em duas
camadas, como planejamento global e planejamento local. Na DORIS, não há um planejamento de trajetória, já que o
trilho é um mapa unidimensional, porém há um planejamento de velocidades
(parte do planejamento de movimento - \textit{Motion Planning}) atribuído à
camada Funcional.

Antes de detalhar a camada Planejador,
é necessário definir alguns termos específicos para melhor entendimento desta
dissertação.

\textbf{Definição}: \textbf{Plano de Missão} ou \textbf{plano} é o conjunto de
\textbf{missões} definidas ou escolhidas pelo usuário, em uma interface, a serem
realizadas sequencialmente pelo robô.

\textbf{Definição}: \textbf{Missão} é o comando básico, com alguns parâmetros a
serem definidos (\textit{argumentos}), que o usuário pode dar ao robô, em uma
interface. A \textbf{missão} é um conjunto de tarefas.

\textbf{Definição}: \textbf{Tarefa} é um processo executado pelo robô com um
determinado objetivo. O conjunto de tarefas ordenado sequencialmente compõe a
missão. Uma tarefa pode ser cancelada por outras tarefas (subsunção). 

\textbf{Definição}: \textbf{Estado} é o processo básico definido na
camada Executivo SMACH. Em linguagem de arquitetura robótica, esta definição se
confunde com \textbf{comportamentos} por ser um processo básico e ser modelado
como uma AFSM, porém é uma definição mais geral por não necessariamente
envolver um par estímulo-ação/sensor-atuador. Um conjunto de estados com um
fim compõe uma tarefa.

A figura~\ref{planejadorfig} mostra a arquitetura da camada Planejador,
destacando suas responsabilidades e suas interconexões entre camadas.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/arqprop/planejador.pdf}
\caption{Arquitetura da camada Planejador.}
\label{planejadorfig}
\end{figure}


\subsubsection{Controle de missão}\label{missioncontrol} 

O controle de missão é a combinação de três responsabilidades interligadas: a
interface com o usuário, o acompanhamento e feedback das missões ao usuário e a
tradução das missões ao robô. Portanto, o controle de missão é a parte da
arquitetura robótica que faz a interface Homem-Robô: traduz a linguagem do
homem à linguagem do robô e vice-versa.

A interface de usuário da DORIS possui o conjunto de missões e seus parâmetros
disponíveis para o operador. O usuário pode adicionar missões sequencialmente,
salvar um plano de missão, agendá-lo e/ou executá-lo (botão \textit{Play}). Além
disso, a interface disponibiliza os logs das missões.

A camada Planejador enviará missões à camada Executivo, quando estas estiverem
agendadas ou quando o usuário requisitar. Na subseção~\ref{hibrida}, foi
exemplificada a \textbf{tradução} da camada Planejador com um robô assistente
que serve cafés. A implementação desta responsabilidade na DORIS é realizada por
um dicionário codificado no robô.
Este método é normalmente conhecido na literatura como \textit{encoded
knowledge} (conhecimento codificado), que são dados incorporados ao código
fonte (\textit{hard coded}).

As missões do robô podem ser classificadas em: \textbf{Missões Simples},
\textbf{Missões Complexas} e \textbf{Missões Desconhecidas}. Todas as missões
possuem \textit{argumentos}, entradas (\textit{inputs}) mínimas necessárias para
a execução da missão.

As missões simples não necessitam de tradução por já estarem modeladas em
tarefas e máquinas de estados SMACH. Por exemplo:
\begin{itemize}
  \item $\textbf{GOTO(x,vel,direction,lap,circular)}$: missão de locomoção do
  robô até um ponto do trilho.
  Os \textit{argumentos} para esta missão são: posição desejada no trilho, em valor
  absoluto; velocidade desejada, um valor fuzzy: ``slow'' (devagar), ``normal''
  (normal) ou ``fast'' (rápida); direção de movimento, 1 para sentido de
  locomoção para frente (baterias chegam por último) e -1 para sentido
  contrário; número de voltas desejado, em caso de trilho circular, antes de o
  robô atingir a posição requisitada. O único argumento obrigatório é posição
  desejada, de forma que os valores padrão são: velocidade ``fast''; direção de
  movimento de distância mínima; zero voltas; e trilho circular.
  \item $\textbf{RECORD(type)}$: gravar dados de sensores no robô. Há um 
 \textit{argumento} para esta missão que pode ser preenchido como: vídeo, áudio
 e termografia. Cada tipo representa uma missão de gravar dados de um sensor
 específico (câmera, microfone e câmera termográfica, respectivamente).
  \item $\textbf{STOP\_RECORD()}$: parar gravação de dados de sensores no
  robô.
  \item $\textbf{DETECTING\_ANOMALIES(type)}$: iniciar algum detector
  específico de anomalia. Há três tipos de detecção de anomalias
  que podem ser escolhidos: vídeo, áudio e termografia. Para cada um deles, há
  uma máquina de estados específica: iniciar algoritmo detector de anomalias por
  câmera, microfones ou câmera termográfica, respectivamente.
  \item $\textbf{STOP\_DETECTING\_ANOMALIES()}$: finalizar algum detector
  específico de anomalia.
\end{itemize}

As missões complexas, de mais alto nível, são combinações de
missões simples. Estas necessitam ser traduzidas pelo Planejador com os
argumentos corretos. Por exemplo:
\begin{itemize}
  \item $\textbf{GOTO\_BASE()}$: missão de locomoção do robô à base.
  Não há \textit{argumentos} para esta missão. Tradução necessária para camada
  Executivo: $\textbf{GOTO(0,'fast')}$.
  \item $\textbf{INSPECTION(x,type)}$: missão para inspecionar um trecho do
  ambiente.
  \textit{Argumentos}: até onde o robô deve inspecionar ($x$ -posição final
  absoluta no trilho); e o tipo de inspeção: vídeo, áudio ou termográfico.
  Tradução: $\textbf{DETECTING\_ANOMALIES(type)}$; $\textbf{GOTO(x,'slow')}$:
  velocidade ``slow'' já que inspeção requer velocidade mínima;
  $\textbf{STOP\_DETECTING\_ANOMALIES()}$.
  \item $\textbf{PATROL()}$: realizar uma ronda completa, isto é, inspecionar
  todo o ambiente. Tradução: $\textbf{INSPECTION(lap=1,types)}$ (todos os
  sensores, posição final do trilho).
  \item $\textbf{MANIPULATOR\_INSPECTION(equipment)}$: inspecionar um
  equipamento com manipulador. O \textit{argumento} desta missão é o equipamento a
  ser inspecionado. O robô deve ir à posição do equipamento, tocar o
  equipamento com o sensor de vibração através do manipulador, e executar uma
  detecção de anomalias por vibração. Em linguagem da camada Executivo, seria
  $\textbf{GOTO(x,'fast')}$: posição do equipamento (requer verificar mapa de
  equipamentos, busca no cartógrafo);
  $\textbf{MANIPULATOR\_POSITION\_CONTROL([x,y,z])}$:
  posição referente ao equipamento; $\textbf{MANIPULATOR\_FORCE\_CONTROL()}$;
  $\textbf{STOP\_DETECTING\_ANOMALIES()}$.
\end{itemize}  

As missões desconhecidas são missões que não estão
descritas no robô, isto é, missões que, até o momento, não pertencem ao
dicionário do robô. Até esta fase da implementação, DORIS não permite que o
usuário use missões desconhecidas. O motivo principal disso é que o robô não
interage com o ser humano de maneira direta, mas apenas através de uma
interface gráfica. Vale, porém, explicitar situações de aplicações robóticas em
que missões desconhecidas são essenciais:

\begin{enumerate}
  \item Robô que serve bebidas: uma missão desconhecida é o usuário pedir
  uma bebida que não exista em sua base de conhecimento (mapa de bebidas).
  Durante a tarefa de reconhecer a bebida na geladeira, o robô irá falhar. Porém, o Planejador
  poderia executar uma busca por fotos de bebida em algum site de buscas, antes
  de executar a tarefa, e atualizar a sua base de conhecimento (mapa de
  bebidas), de forma que a tarefa tenha resultado positivo com novo dado.
  \item J.A.R.V.I.S., a inteligência artificial das histórias em quadrinhos
  Iron Man (homem de ferro): comandos por voz normalmente são complexos, já que
  há diversas maneiras de pedir um plano a um robô. Por exemplo, os planos
  ``Robô, preciso de uma tesoura'', ``Robô, dê-me uma tesoura'', ``Robô,
  traga-me uma tesoura'' são planos equivalentes, ditos de maneira diferentes.
  Todas estas diferentes formas devem estar disponíveis em alguma base de
  conhecimento, dentro ou fora do robô, como na núvem (\textit{cloud}), a qual
  deveria ser compartilhada com todos os robôs que exercem a mesma função.
  RoboEarth \cite{hunziker2013rapyuta} é uma ideia visionária que está buscando
  criar uma \textit{internet dos robôs} (como a \textit{internet das coisas}),
  já está sendo integrada ao ambiente ROS, e sua contribuição é criar um
  repositório na núvem com missões compartilhadas para todos os robôs que a
  utilizam.
\end{enumerate}

Na interface, o usuário pode escolher sequencialmente um conjunto de missões e
executar, por exemplo, o plano: 
$$\textbf{GOTO(30)}$$
$$\textbf{RECORD('VIDEO')}$$
$$\textbf{INSPECTION('AUDIO',50)}$$
$$\textbf{STOP\_RECORD()}$$ 
$$\textbf{RECORD('AUDIO')}$$
$$\textbf{GOTO\_BASE()}$$
$$\textbf{STOP\_RECORD()}$$ 

O controle de missão da camada Planejador traduz sequencialmente o plano nas
missões simples:

$$\textbf{GOTO(30)}$$
$$\textbf{RECORD('VIDEO')}$$
$$\textbf{DETECTING\_ANOMALIES('AUDIO')}$$
$$\textbf{GOTO(50)}$$
$$\textbf{STOP\_DETECTING\_ANOMALIES()}$$
$$\textbf{STOP\_RECORD()}$$ 
$$\textbf{GOTO(0)}$$
$$\textbf{STOP\_RECORD()}$$ 

Os status, motivo de interrupções, e possíveis erros ocorridos de cada missão
são fornecidos pela camada Executivo. O controle de missão tem acesso fácil a
essas informações graças ao estilo de comunicação publish-subscriber,
característica do \textit{middleware} ROS. Dessa forma, o controle de missão
subscreve o tópico de \textit{Warnings}, interpreta as mensagens, quando
necessário, e disponibiliza esta informação no espaço de logs da interface. 

O controle de missão está implementado, mas ainda não embarcado no robô. A
interface gráfica de usuário ainda não foi finalizada, mas esta pode ser
simulado por mensagens de ROS, durante os testes.

\subsubsection{Agendador}

O usuário pode armazenar o plano de missões no robô com data e hora. A
responsabilidade Agendador é verificar a hora agendada para a execução da
missão, executar a missão na hora correta, e, caso esta não seja bem sucedida e
o motivo do insucesso for contornável em tempo estimável, reagendar a missão.
Com o Agendador, o robô ganha uma rotina, o que é importante a DORIS, um robô de inspeção. 

\subsubsection{Cartógrafo}

Há diversas formas de armazenar mapas do mundo dentro do robô, como mapas
geométricos, núvens de pontos, simbólicos, analíticos e outros. Cada forma
apresenta vantagens e desvantagens, de forma que muitas vezes é necessário
armazenar vários mapas para otimizar seus usos nas diversas funções do
robô. No caso da DORIS, por exemplo, durante o planejamento de velocidades do
robô, o mapa geométrico 3D do ambiente não é a melhor opção, já que a DORIS se
movimenta em um espaço unidimensional (o trilho), e carregar e processar um
espaço 3D é muito custoso. A camada Planejador deve gerar um mapa
unidimensional, ou um mapa simbólico, para otimizar a função de planejamento de
velocidades. Além disso, a camada Planejador deve manter os mapas gerados
atualizados.

Por ser um robô de inspeção, DORIS possui diversos mapas do mundo:
\begin{enumerate}
  \item Frames de câmera de vídeo (matriz);
  \item Frames de câmera termográfica (matriz);
  \item Sonoro (analítico);
  \item Seções do trilho (matriz);
  \item Postes (ou outras características marcantes) do ambiente (núvem
  de pontos);
  \item Scans de laser (núvens de pontos);
  \item Equipamentos (matriz);
  \item Distâncias do trilho ao solo (analítico);
  \item Arquivo CAD do trilho (CAD);
\end{enumerate}

Os mapas utilizados para inspeção são 1, 2, 3 e 6, e foram gerados com os
sensores câmera fixa, câmera termográfica, microfones e laser, respectivamente.
O mapa 9 é obtido durante a fabricação do trilho e não é mais alterado. O mapa
4 foi gerado pelo CAD da fabricação do trilho, ou seja, a partir do mapa 9, e
será necessário para a locomoção do robô. Os mapas 5 e 8 são gerados a partir do
mapa 6 e são necessários para a localização do robô. O mapa 7 é inserido
manualmente pelo programador, sendo uma matriz que relaciona o equipamento às
suas coordenadas cartesianas.

A camada Planejador ainda não integra, nem faz a manutenção e atualização dos mapas, já que isso requer integração de todos os algoritmos de SLAM do robô,
o que foge do escopo desta dissertação. Entretanto, quando os algoritmos
SLAM forem implementados e testados, é importante que esta responsabilidade seja
finalizada na camada Planejador do robô.

\subsection{Implementação da camada Funcional}\label{camadafuncional}

A camada funcional foi a primeira implementada e exaustivamente testada na
DORIS. Como nas outras arquiteturas de três camadas previamente apresentadas, a camada Funcional é o nível mais baixo, conecta sensores a
atuadores, implementa controladores PID, e diversos outros algoritmos, por
exemplo para a localização do robô. Utiliza-se Ubuntu/Linux como sistema
operacional e ROS como RDE para a implementação do nível funcional, já que este
apresenta todas as vantagens descritas na subseção~\ref{ros}, e linguagem de
programação C++, a fim de se garantir maior eficiência computacional.

A camada funcional seguiu a recomendação dos desenvolvedores do ROS, sendo
estruturada de maneira semelhante à camada funcional do sistema CLARAty. Neste,
a camada funcional é uma interface com todo o sistema de hardware e suas
capacidades. É um software orientado a objeto, obtendo assim modularidade de
hardware, e uma estruturação apropriada para usar as propriedades de
herança, em software. A figura~\ref{claratyfunc} mostra a organização da camada
Funcional da arquitetura CLARAty.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/claratyfunc.jpg}
\caption{Organização da camada Funcional CLARAty}
\label{claratyfunc}
\end{figure}

Na DORIS, foi proposto o \textit{Robot Package Software}. Neste sistema,
\emph{Tools} (janelas gráficas) e \emph{Componentes} (unidades de comunicação e
processamento) são agrupados em \textit{Robot Package} (bibliotecas dinâmicas).
Os componentes que lidam com hardware rodam no computador embarcado do robô,
já os componentes que interagem com as \textit{tools} rodam no computador base.
Os diversos componentes, tanto do computador embarcado quanto da base, se
comunicam através de mensagens ROS, permitindo que a base controle o robô, na
função de teleoperação \cite{freitas2015embedded}. Os componentes da base não
fazem parte do escopo desta dissertação, já que não estão ligados à
autonomia do robô, mas apenas a uma fração do controle de missão, que diz
respeito à interface gráfica.

Dois \textit{Robot Packages} fazem parte da DORIS:
\textit{General Package} e \textit{DORIS Package}, derivado do primeiro. Outros
robôs desenvolvidos por GSCAR, como o ROV LUMA, possuem seus pacotes
específicos, derivados do \textit{General Package}. 

O \textit{General Package} contém os componentes e \textit{tools} gerais
relacionados a vídeo, áudio, tabela de dados, \textit{gamepad} (para controle
remoto de robôs), e configurações de dispositivos que podem ser usados em outros
robôs

O \textit{DORIS Package} é um pacote mais específico à DORIS e lida com
seus elementos de hardware e suas funcionalidades. Do ponto de vista de uma
arquitetura robótica, neste pacote foram implementados os \emph{comportamentos}
específicos da DORIS.  Os diversos componentes implementados para a DORIS
foram divididos em funcionalidades, neste trabalho, a fim de proporcionar melhor
entendimento.

Como já descrito na seção~\ref{doris}, os atuadores para locomoção e para o
manipulador da DORIS se comunicam via CAN-Bus, que provê velocidade e
transferência confiável dos dados \cite{corrigan2008introduction}. Esta
comunicação extra, exigiu a implementação do componente \emph{CANOpen}, que utiliza a biblioteca
SocketCAN disponivel em Linux. Um componente \emph{EPOS} é classe derivada de
\emph{CANOpen} e especifica este tipo de comunicação com o hardware EPOS
(driver) utilizado na DORIS, além de implementar outras caracterísiticas do
driver, como os dados dos encoders dos motores: posição (odometria), velocidade
e corrente.
Além disso, há a \emph{EPOSNodelet}, classe derivada de \emph{EPOS}, que implementa a comunicação ROS. A implementação dos
componentes respeita a sugestão do desenvolvedor do \textit{framework}, de forma
que sempre há a criação de uma classe padrão C++ e uma classe derivada dentro do
ambiente ROS, que usa os métodos do \textit{framework}.

Os componentes que executam o controle de locomoção do robô são:
\emph{Controller}, \emph{ControllerNodelet} (derivada de \emph{Controller}),
\emph{MotionController} (derivada de \emph{Controller}),
\emph{MotionControllerNodelet} (derivada de \emph{MotionController}),
\emph{PositionController} (derivada de \emph{Controller}) e
\emph{PositionControllerNodelet} (derivada de \emph{PositionController}). Os
componentes \emph{Controller} e \emph{ControllerNodelet} são classes genéricas de controle,
sendo necessária a implementação do controle para o robô específico,
componentes \emph{MotionController} e \emph{PositionController}.

Os quatro hardwares EPOS possuem uma malha de controle PD ou
PID para realizar o controle do robô por velocidade ou corrente, porém de
maneira independente para cada motor. A sincronia e ajustes dessas malhas de
controle são realizados no componente \emph{MotionController}. O
\textit{MotionControllerNodelet} se comunica por serviço de ROS
(\textit{service}) com o componente \emph{EPOSNodelet}, enviando os valores de
velocidade desejados para cada motor de maneira síncrona.
Por exemplo, observe que, em uma curva, devido à distância entre os dois gimbals
do robô e à distância entre as rodas dos gimbals, os motores devem possuir
velocidades diferentes. O \emph{MotionControllerNodelet} envia
\textit{set-points} de velocidade às EPOS e pode alterar os parâmetros de aceleração e
desaceleração. Além disso, este componente é responsável por receber entradas do
componente \emph{Joystick} e \emph{Interface}, que podem controlar o robô pela
base, ou \emph{MissionController}, o componente de missão autônoma. Há apenas
a prioridade do \emph{MissionController} sobre todos os outros controladores,
tal que, com exceção do \emph{MissionController}, o componente que irá
controlar será o primeiro que pedir o controle.

O componente \emph{PositionController} será futuramente integrado ao
\emph{MotionController}. Sua funcionalidade é realizar um controle de posição,
logo possui uma malha interna de controle, não disponível no hardware da EPOS, e
se comunica com o componente \emph{MotionController}, enviando
\textit{set-points} de velocidades. É um controle proporcional de posição com
saturação de velocidade.

O manipulador da DORIS utiliza mais quatro EPOS (quatro motores) e exigirá ainda
a implementação de um controle de força para sensoriamento de equipamentos ao
toque, a partir de um sensor de vibração. Componentes como \emph{ForceControl} e
\emph{InspectionVibration} ainda estão em desenvolvimento.
%TODO referencia marco

Ainda em fase de aperfeiçoamento, os componentes de localização
\emph{Localization} e \emph{LocalizationNodelet} recebem mensagens de ROS
(\textit{subscriber}) do componente \emph{EPOSNodelet}, os dados da odometria,
isto é, quanto cada roda girou. Dentro de \emph{Localization} é feita uma média
para estimar quanto o robô se locomoveu. Em implementação, está sendo feito um
sistema inteligente de localização com os dados dos sensores IMU e LaserScan. A
fusão de sensores permitirá estimar de maneira precisa a posição do robô. O
\emph{LocalizationNodelet} ainda envia mensagens (\emph{Publish}) para o
\emph{PositionController}, \emph{MotionController} e \emph{RVIZ}, um componente
de visualização para o usuário.

Os diversos componentes de sensores, no robô, são: \emph{AudioSender},
\emph{AudioSenderNodelet} (derivada de \emph{AudioSender}),
\emph{VideoSender}, \emph{VideoSenderNodelet} (derivada de
\emph{VideoSender}), \emph{VideoWebcamera} (derivada de
\emph{VideoSenderNodelet}), \emph{AxisVideo} (derivada de
\emph{VideoSenderNodelet}), \emph{LMS1xx}, \emph{IMU}, \emph{IMUNodelet} e
\emph{ColorDetector}.

O componente \textit{AudioSender} é um driver que faz a interface com os diversos
microfone disponíveis no robô. Comunica-se (\textit{publisher}) por mensagem de
ROS com o componente da base \textit{AudioReceiverNodelet} (\textit{subscriber})
para disponibilizar os dados ao usuário. Futuramente, irá se comunicar
(\textit{publisher}) com o \textit{InspectionAudioNodelet} (\textit{subscriber}),
um componente que compara o áudio da base de dados do robô e detecta anomalias através de um algoritmo de reconhecimento de padrões.

O componente \textit{VideoWebcamera} é um driver que faz a interface com as duas
câmeras webcams disponíveis no robô. Comunica-se
(\textit{publisher}) com o componente da base
\textit{VideoReceiverNodelet} (\textit{subscriber}) para disponibilizar os dados
ao usuário, e com o componente \textit{ColorDetection} (\textit{subscriber}), um
algoritmo que verifica a porcentagem de vermelho obtida em cada frame da
câmera. Futuramente, o componente \textit{ColorDetection} irá se comunicar
(\textit{publisher}) com o \textit{Localization} (\textit{subscriber}), já que a
informação de vermelho no trilho será utilizada para calibrar a
localização.

O componente \textit{LMS1xx} é um driver que faz a interface com o LaserScan,
sensor que realiza um escaneamento a laser do ambiente. Comunica-se
(\textit{publisher}) com o componente da base \textit{LaserReceiverNodelet}
(\textit{subscriber}) para disponibilizar os dados ao usuário. Futuramente, irá
também se comunicar com o \textit{PoleDetection} (\textit{subscriber}), que possui
um algoritmo para detecção de postes, e o \textit{Localization} (\textit{subscriber}), já que
este é mais um sensor que provê dados para o sistema de localização (altura do
robô).

O componente \textit{IMU} é um driver que faz a interface com a \textit{IMU}.
Ele envia uma lista de dados: velocidade, orientação, posição, pólos
magnéticos e outros. Futuramente, também irá se comunicar com o
\textit{Localization}.

O componente \textit{AxisVideo} é um driver que faz a interface com a câmera fixa
da AXIS. Comunica-se (\textit{publisher}) com o componente
da base de mesmo nome para disponibilizar os dados ao usuário. Futuramente, o
algoritmo de detecção de anomalias por vídeo será integrado ao sistema ROS,
logo um componente \textit{InspectionVideo} será \textit{subscriber} do mesmo
tópico. 

A figura~\ref{funcdoris} represente o esquema de comunicação entre os diversos
componentes e suas hierarquias.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/arqprop/funcional.pdf}
\caption{Camada Funcional da DORIS}
\label{funcdoris}
\end{figure}


\subsubsection{Planejamento de velocidades}\label{masterplanning}

A DORIS se locomove em um trilho (mapa unidimensional), logo não há a
necessidade de computação de um \textit{Motion Planning} complexo. Quando uma
missão do tipo \textbf{GOTO} é requisitada, apenas são calculadas as
velocidades de segurança e compensação das rodas do robô, não a trajetória, pois
só há uma trajetória possível, ou duas, caso o trilho seja circular. Apesar de o
\textit{Motion Planning} estar na camada Funcional, ele também é fundamental
para a autonomia do robô, portanto o autor desenvolveu sua implementação. 

O processo chamado \textit{MasterPlanning} é um \textit{thread} inicializado
junto ao robô e que subscreve ao tópico \textit{DORIS/Vehicle/Path\_Planning}
para obter os parâmetros de entrada e publica sua saída ao tópico
\textit{DORIS/Vehicle/Path\_Planning/Plan}. Suas entradas são: localização
atual do robô; localização objetivo; direção de movimento (1 ou -1 - sentido
natural ou sentido contrário); número de voltas desejado antes de chegar à
localização objetivo; e se o trilho é circular (verdadeiro ou falso). Sua saída
é uma matriz com $n$ linhas e três colunas: a primeira coluna representa a posição
do trilho onde ocorre troca de velocidade máxima; a segunda coluna é a
velocidade máxima; a terceira é o \textit{set-point} de posição.

A matriz de saída será utilizada pela tarefa
\textit{Motion\_Planning\_Position} da camada Executivo, a qual se comunica com
o processo da camada Funcional \textit{PositionController}. Portanto, no modo
autônomo, DORIS será controlada por posição, havendo a necessidade de
especificar velocidades máximas para cada trecho do trilho. O mapa do
trilho é uma matriz de duas colunas: a primeira coluna representa o tipo de
trecho do trilho (reta, transição reta-subida, transição reta-descida, subida,
descida, curva à direita, curva à esquerda); a segunda coluna se refere ao
comprimento do trecho. O robô pode acelerar nas retas, mas deve reduzir a
velocidade em curvas, onde há compensação de velocidades devido ao comprimento
do robô e à distância entre as rodas em um mesmo gimbal, e em subidas e
descidas, onde grandes velocidades produzirão muito esforço e desgaste nos
motores/engrenagens.

Durante uma missão do tipo \textit{GOTO}, a tarefa
\textit{Motion\_Planning\_Position}, após obter a localização do robô, envia um
pedido de planejamento de velocidades ao processo \textit{MasterPlanning}, em
uma mensagem com todas as entradas necessárias. \textit{MasterPlanning} tem
acesso ao mapa do trilho, disponibilizado pelo Cartógrafo,
e possui um dicionário de três possíveis velocidades máximas ($V_{max}$):
``fast'', ``normal'' e ``slow'', mapeadas em 0.6, 0.3 e 0.1 m/s respectivamente.

As velocidades máximas dos trechos do trilho são proporconais à $V_{max}$ e
escolhidas empiricamente: $V_{reto} = V_{max}$; $V_{reto/subida} = 0.7*V_{max}$;
$V_{reto/descida} = 0.7*V_{max}$; $V_{curva} = 0.85*V_{max}$; $V_{subida} =
0.5*V_{max}$; $V_{descida} = 0.5*V_{max}$. A fim de garantir que o robô chegue
em determinado trecho respeitando a velocidade máxima deste, o
\textit{MasterPlanning} calcula a posição de troca de velocidade máxima pela
equação de Torricelli: $v_{f}^2 = v_{0}^2+2a\Delta S$. $\Delta S$
representa a distância percorrida, ou seja, a posição de troca de velocidades
e $a$ é a aceleração/desaceleração máxima da EPOS ($a=0.11 m/s^2$). 


\subsection{Implementação da camada Executivo}\label{impexecutivo}

A camada Executivo elaborada para a DORIS usa SMACH (subseção~\ref{smach}) como
\textit{framework}, e implementa a técnica de função de coordenação competitiva
(subseção~\ref{reativa}), a arquitetura de subsunção, onde o módulo básico de
comportamento reativo é uma máquina de estados aumentada (\textit{AFSM}), como a
figura~\ref{afsm}. A camada Executivo é essencial para a
autonomia do robô, portanto também é o escopo da implementação do autor.

As subseções a seguir detalham a implementação da camada Executivo,
identificando como é realizada cada responsabilidade: Sequenciador,
Selecionador, Gerenciador de recursos, e Monitoramento da execução e
recuperação de erros (\textit{Execution monitoring and error recovery}). Como o
ambiente de desenvolvimento da camada Funcional é ROS, optou-se pela utilização
da camada Executivo SMACH \cite{bohren2010smach} por demonstrar resultados
positivos em diversas aplicações, e já ser integrada ao sistema ROS. Foram
adicionadas algumas funcionalidades à camada a fim de garantir todas as
responsabilidades de uma camada Executivo. A camada não executa
algoritmos de alto processamento, como a camada Funcional, logo foi escolhida a
linguagem Python para programação.

A figura~\ref{executivofig} mostra a arquitetura da camada Planejador,
destacando suas responsabilidades e suas interconexões entre camadas.

\begin{figure}[!ht]
\centering
\includegraphics[width=1\columnwidth]{figs/arqprop/executivo.pdf}
\caption{Arquitetura da camada Executivo.}
\label{executivofig}
\end{figure}


\subsubsection{Sequenciador e Selecionador}
SMACH é um \textit{framework} para projetar máquinas de estados hierárquicas
concorrentes. As máquinas de estados de SMACH possuem características bem
peculiares não encontradas em máquinas de estados formais, como a \textit{user
data}, comentada na subseção~\ref{smach}. O \textbf{Sequenciador} e
\textbf{Selecionador} desenvolvidos para a DORIS utilizarão as capacidades de
SMACH e as vantagens de ROS para a modelagem das tarefas do robô.

Como seres humanos, robôs deveriam possuir um conjunto de
processos que estão sempre em execução, e outros conjuntos de processos que só
entrarão em execução dependendo da missão a ser executada. Por exemplo,
em um ser humano, os processos vitais, como ``respirar'' e ``o bombear do
coração'', estão sempre em execução. Alguns podem ser postos em
espera por um tempo, como ``respirar'', e outros são incontroláveis, como ``o bombear
do coração''. 

\textbf{Definição}: \textbf{Processo reativo vital} é um processo que deve ser
executado sempre que o robô estiver em modo autônomo. É o tipo de processo vital
ao robô, garante robustez, proteção ou a sobrevivência ao sistema e aos seus
dispositivos.

Dependendo da missão a ser realizada, além das tarefas que a especificam, um
conjunto de processos paralelos começa a ser executado de maneira automática a fim de
garantir o sucesso da missão, ou como novas formas de proteção do
sistema aos novos perigos que a missão pode impor. Para o ser humano, em missões
como ``palestrar'', ``produzir um relatório'', e ``ir a um evento'', os
processos ``falar'', ``escrever'' e ``desviar de pessoas e objetos'' são
automáticos e executados somente durante a realização das missões. 

\textbf{Definição}: \textbf{Processo reativo específico} é um processo
iniciado paralelamente às tarefas da missão, logo quando esta começa a ser
executada. São processos específicos de uma determinada missão, e
inicializados automaticamente. Podem garantir
robustez, proteção, sobrevivência do sistema, ou melhorar a execução da missão.

Os \textbf{processos reativos vitais} e \textbf{processos reativos
específicos} podem interromper a execução de tarefas das missões temporaria ou
definitivamente. Por exemplo, uma falha no bombeamento do coração cancela
imediatamente qualquer missão em execução. Esta característica de supressão dos
\textbf{processos reativos} foi modelada pela função de coordenação competitiva,
subsunção. Desta forma, foi implementada uma classe, derivada de SMACH, para a
AFSM padrão de todas as tarefas. A classe também depende de ROS, e
foi idealizada para absorver a vantagem do estilo de comunicação
\textit{publish/subscriber}, tornando a modelagem das tarefas bastante modular.

O módulo básico que busca modelar a subsunção com novas funcionalidades,
chamado \textbf{SUPPRESSION\_STATE}, é um \textit{container} SMACH do tipo
\textit{concurrence} (concorrente), isto é, um \textit{container} composto por
dois \textit{containers} que são executados simultaneamente. Um dos
\textit{containers} concorrentes é o \textit{MAIN}, composto por tarefas
sequenciais que executam a missão. O outro \textit{container} concorrente é o
\textit{SUPPRESSION\_MAIN}, o qual aborta a missão (\textit{container}
\textit{MAIN}) caso receba uma mensagem ROS 'Abort' em tópico específico e, na
sequência, aborta processos dependentes, por exemplo, missões dependentes. 

\textbf{Exemplo do módulo básico}

\textbf{GOTO} é uma missão implementada como um \textit{container}
\textbf{SUPPRESSION\_STATE}, composto pelo \textit{container}
\textbf{MAIN\_GOTO}, o qual é uma sequência de tarefas; e pelo
\textit{container} \textbf{SUPPRESSION\_GOTO}, que aborta \textbf{MAIN\_GOTO}
quando uma mensagem ROS 'Abort' é enviada ao tópico \textit{DORIS/MCS/Goto}
(figura~\ref{supression}).

Como \textbf{SUPPRESSION\_STATE} é o módulo básico da
camada Executivo, todas as missões, tarefas e \textit{processos reativos} são
inicializados como \textit{containers} SMACH do tipo
$\textbf{SUPPRESSION\_STATE(name, sup\_msg, output\_keys, input\_keys,
to\_sup)}$. $name$ é o nome (ou \textit{tag}) da missão ou
tarefa e, consequentemente, seu tópico de supressão (tópico que subscreve
esperando mensagem para cancelamento) é \textit{DORIS/MCS/name}. $sup\_msg$ é a
mensagem que a tarefa espera para ser cancelada, onde o padrão é ``Abort''.
$output\_keys$ e $input\_keys$ são os \textit{user data} SMACH. E $to\_sup$ são
as missões simples que devem ser cancelados caso uma missão complexa seja
abortada, por exemplo, caso a missão complexa \textbf{INSPECTION} seja abortada,
ela deve cancelar as missões \textbf{GOTO} e \textbf{Detect}.

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/goto.png}
\caption{Exemplo do módulo básico para a missão simples \textbf{GOTO}.}
\label{supression}
\end{figure}

Desta forma, um \textbf{processo reativo vital ou específico} pode abortar uma
missão, enviando uma mensagem ROS \textit{'Abort'} ao tópico
\textit{'DORIS/MCS/MISSION'}. O módulo básico implementado torna a estrutura
da camada Executivo muito mais flexível, modular e estimula o paralelismo, sem
a preocupação de tarefas conflitantes, já que os conflitos são resolvidos pela
subsunção. A subsunção é mais flexível que um esquema de prioridades por IDs, já
que o acréscimo de um novo processo exije a alteração de toda uma tabela de
prioridades. Além disso, a modelagem do robô fica mais intuitiva e
correspondente à natureza.

O problema de \textit{situatedness} (subseção~\ref{brooks}) é resolvido pela
decomposição em \textit{processos reativos vitais},
\textit{processos reativos específicos} e pelas tarefas que compõem
sequencialmente a missão. Não são todos os comportamentos que estão
sempre em execução, mas apenas os essenciais (``vitais'') para o robô e aqueles
que possuem alguma relação com a missão (``específicos''). Essa responsabilidade
de classificar os processos e escolher qual entrará em ação é chamada de \textbf{Selecionador},
foi implementada na camada Executivo e resolve um grande problema de
arquiteturas de subsunção. A nível de implementação, as missões, quando são
inicializadas, executam os seus \textit{processos reativos específicos} e
cancela-os quando são abortadas ou finalizadas.

A responsabilidade \textbf{Sequenciador} é quebrar as missões do Planejador em
tarefas, que, no caso do SMACH, são sequências de máquinas de estados SMACH. O
programador deve, portanto, modelar a quebra de uma missão em tarefas
utilizando o \textit{framework} SMACH e adicionar a decomposição à base de
conhecimento da camada Executivo.


\paragraph{Processos reativos vitais na DORIS}

Os \textbf{processos reativos vitais} criados para a DORIS são:
\begin{itemize}
  \item \textbf{STATE\_OF\_CHARGE}: obtém os status das baterias se
  comunicando com o \textit{VSS} da camada Funcional. Caso a carga das
  baterias esteja inferior a $5\%$, o robô deve parar todos as missões e
  processos reativos. O processo envia mensagem 'Abort' aos tópicos de todas as
  missões: \textit{'DORIS/MCS/INSPECTION'}, \textit{'DORIS/MCS/PATROL'}, \textit{'DORIS/MCS/RECORD'},\textit{'DORIS/MCS/GOTO'}; e a alguns
  processos reativos: \textit{'DORIS/MCS/StateOfTempAndHum'}.
  \item \textbf{STATE\_OF\_TEMPERATURE\_AND\_HUMIDITY}: obtém as condições de
  temperatura e umidade externas se comunicando com o \textit{VSS}. Quando
  as condições estão fora do nível de operação do robô, este suspende as
  missões. O processo envia mensagem 'Abort' aos tópicos de todas as missões:
  \textit{'DORIS/MCS/INSPECTION'}, \textit{'DORIS/MCS/PATROL'},
  \textit{'DORIS/MCS/RECORD'}, \textit{'DORIS/MCS/GOTO'}, e outras.
\end{itemize}

\paragraph{Processos reativos específicos na DORIS}

Na DORIS, um \textbf{processo reativo específico} foi implementado para
a missão simples \textbf{GOTO}: 
\begin{itemize}
  \item \textbf{OBSTACLE\_DETECTION}: detecta a presença de obstáculos. Foram
  criados dois estados concorrentes SMACH, um faz a detecção
  por câmera fixa por um algoritmo de anomalias no trilho (figura~\ref{camera}),
 outro pelo sensor de consumo de corrente dos motores (comunicação com
 EPOSNodelet da camada Funcional, figura~\ref{epos}), o qual se muito elevado,
 representa choque com algum obstáculo (a mesma
 logica deste estado pode ser encontrado em \cite{christensen2011cost}).
 Caso um dos sensores detecte obstáculo, o estado seguinte do \textbf{OBSTACLE\_DETECTION} aborta a tarefa
  \textbf{MOTION\_POSITION\_CONTROL}, pertencente à missão \textbf{GOTO}
  (mensagem ROS 'Abort' ao tópico
  \textit{'DORIS/MCS/MOTION\_POSITION\_CONTROL'}), e controla a velocidade do
  robô para zero. A figura~\ref{mainoa} mostra o processo em alto nível. 
\end{itemize}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/camera.png}
\caption{Estado \textbf{CAMERA} do processo reativo específico
\textbf{OBSTACLE\_DETECTION}.}
\label{camera}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/epos.png}
\caption{Estado \textbf{EPOS} do processo reativo específico
\textbf{OBSTACLE\_DETECTION}.}
\label{epos}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainoa.png}
\caption{Estados do processo reativo específico \textbf{OBSTACLE\_DETECTION}.}
\label{mainoa}
\end{figure}

Outro processo reativo específico para a missão \textbf{GOTO} é o
\textbf{AVAILABLE\_ENERGY}, ainda não implementado. Este processo poderá
calcular a variação da energia consumida durante uma missão e inferir se há
energia suficiente para a conclusão. Caso não haja, a missão deve ser abortada.

\paragraph{Tarefas na DORIS}
As tarefas criadas para a DORIS são detalhadas sequencialmente, conforme a
missão simples:
\begin{itemize}
  \item \textbf{GOTO}: \textbf{Localization}, \textbf{PathPlanning},
  \textbf{Motion\_Control\_Position}. Figura~\ref{maingoto}.  
\begin{itemize}
  \item \textbf{Localization}: espera receber mensagem da camada Funcional com
  a localização e a probabilidade. Caso esta probabilidade seja menor que 50\%,
  o estado \textbf{Wander} é ativado. Figura~\ref{mainlocalization}
\begin{itemize}
  \item \textbf{Wander}: estado loop que recebe a localização do robô, posição e
  probabilidade. Caso a probabilidade seja menor que 50\%, o
  estado se comunica com o \textit{MotionControllerNodelet} e realiza controle de velocidade
  do robô a $0.1 m/s$, até que o robô consiga se localizar com maior precisão.
  Quando a probabilidade mínima é alcançada, o estado sai com ``sucesso''.
\end{itemize}  
  \item \textbf{PathPlanning}: comnunica-se com o \textit{MasterPlanning} da
  camada funcional para obter o plano de velocidades do robô, no trilho. Seu \textit{user data} é o plano de
  velocidades.
  \item \textbf{Motion\_Position\_Control}: comunica-se com o
  \textit{PositionControlNodelet} da camada Funcional para enviar o plano de
  velocidades. A tarefa fica em loop, obtendo localização do robô e enviando o
  plano de velocidade, conforme a mudança de localização.
  Figura~\ref{maincontrol}.
\end{itemize}
  \item \textbf{RECORD}: comunica-se com os a
  camada Funcional para gravação dos dados no SSD
  embarcado. Espera o comando de 'Abort', que será enviado pela
  missão \textbf{STOP\_RECORD}. Figura~\ref{mainrecord}.
  \item \textbf{STOP\_RECORD}: envia mensagem 'Abort' ao tópico
  \textit{'/DORIS/MCS/RECORD'}.
  \item \textbf{DETECT}: comunica-se com os algoritmos de inspeção da
  camada Funcional. Espera o comando de 'Abort', que será enviado pela
  missão \textbf{STOP\_DETECT}.
\end{itemize}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/main_goto.png}
\caption{Tarefas da missão simples \textbf{GOTO}.}
\label{maingoto}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainlocalization.png}
\caption{Estados da tarefa \textbf{Localization}.}
\label{mainlocalization}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainmotioncontrol.png}
\caption{Estados da tarefa \textbf{Motion\_Position\_Control}.}
\label{maincontrol}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=.7\columnwidth]{figs/mainrecord.png}
\caption{Estados da tarefa \textbf{RECORD\_TYPE}.}
\label{mainrecord}
\end{figure}


\subsubsection{Gerenciador de recursos}

A camada Executivo tem a responsabilidade de gerenciar os recursos do robô pelas
missões, isto é, compartilhar, estabelecer prioridades e verificar a
disponibilidade dos sensores e atuadores do robô aos processos em execução. 

O compartilhamento de sensores, dados e processamento de sensores estão
sempre disponíveis a todas funções e processos do robô, graças ao estilo de
comunicação \textit{publish/subscriber} do \textit{framework} ROS. Os atuadores,
no entando, só estão disponíveis a executar uma tarefa por vez. Por exemplo, o
manipulador da DORIS não tem condições de inspecionar dois equipamentos ao mesmo
tempo; um robô com um manipulador que serve bebidas não é capaz de buscar
três bebidas simultaneamente; um robô submarino com apenas uma câmera sob um
sistema \textit{Pan \& Tilt} (atuador) não pode compartilhar a câmera para navegação e
observação da cauda simultaneamente. 

ROS soluciona o problema de compartilhamento de sensores, e o
\textbf{Sequenciador}, junto com a subsunção, resolve o problema de prioridades.
As missões são sequenciais, não paralelas, logo não há perigo de compartilhamento de atuadores
entre missões. O conflito ocorre quando processos reativos, paralelos às
missões, necessitam do mesmo recurso da missão. O esquema de função de
coordenação competitiva é a solução para os conflitos.

Por fim, a disponibilidade de recursos é essencial para a execução das missões.
Caso seja dada uma tarefa de inspeção com manipulador, na DORIS, o robô não deve
executar todas as tarefas da missão e, ao fim, verificar que o sensor de
vibração não está disponível. Os \textbf{processos de
recursos disponíveis} são individuais para cada recurso e verificam se o sensor
está disponível. Caso o recurso não esteja disponível, a missão que o utiliza é
automaticamente abortada (subsunção).

\textbf{Definição}: \textbf{Processo reativo de recurso disponível} é  um
processo reativo que monitora o status de um recurso do robô (sensores e atuadores).
Este processo pode abortar missões. 

Um exemplo de \textbf{processo reativo de recurso disponível}, na DORIS, é o
\textit{EPOS\_RESOURCE}, o qual aborta a missão \textbf{GOTO} caso esta esteja
no plano de missão do robô, pois não há como o robô se locomover sem o
driver da EPOS.

Os \textbf{processos reativos de recursos disponíveis} são como os
\textbf{processos reativos vitais}, ou seja, estão sempre em execução, desde a inicialização do
modo autônomo do robô. 

\subsubsection{Monitoramento de tarefas e recuperação de
erros}\label{monitoamento}

O controle de missão da camada Planejador fornece ao usuário os status das
missões e os erros, junto com os motivos das falhas. Entretanto, ele apenas
interpreta e mostra os dados fornecidos pela camda Executivo, isto é, o
controle de missão possui um \textit{thread} nó de ROS subscritor do tópico
\textit{Warning} e \textit{loginfo}. A camda Executivo envia para este tópico os
status das missões que estão sendo executadas.

O SMACH possui um monitoramento de tarefas simplificado, de forma que todos os
estados publicam no tópico \textit{loginfo} os eventos ocorridos: transições de
estados, transições de \textit{containers}, \textit{outcomes} e \textit{user
data}. O \textit{Smach Viewer} (visualizador SMACH) e o
controle de missão subscrevem a este
tópico e, desta forma, é possível gerar um log detalhado ao usuário.

Além do uso do monitoramento simples do SMACH, foi desenvolvida uma classe
derivada para reportar acontecimentos de subsunção de processos, ou seja, quando
um \textit{processo reativo} aborta uma tarefa ou missão, o \textit{processo reativo} envia
automaticamente uma mensagem ao tópico \textit{Warning}, reportando o motivo do
cancelamento. Esta informação é a mais valiosa para o operador,
visto que é extremamente importante o usuário saber o motivo detalhado do
cancelamento de uma determinada missão. Por exemplo, pode haver diversos
motivos para o robô falhar a missão \textit{INSPECTION('VIDEO',30)}, e o
usuário, sem saber o motivo, pode tentar executar a missão diversas vezes
obtendo sempre uma falha ``misteriosa''. A um programador seria ainda necessário
o debug do código completamente, e mesmo somente nas tarefas que contém a missão
é muito trabalhoso. O monitoramento de tarefas exige, portanto, explicações
detalhadas da falha a fim de facilitar o uso do robô.

A recuperação de erros pode ser implementada no SMACH como novas tarefas da
missão. Como cada estado SMACH pode ter $n$ \textit{outcomes}, a falha de
execução de um processo poderia levar a um estado de recuperação. Um exemplo
disso é a implementação do \textbf{processo reativo específico}
\textbf{OBSTACLE\_DETECTION}, o qual cancela a tarefa
\textbf{MOTION\_POSITION\_CONTROL}. Em caso de cancelamento, a missão
\textbf{GOTO} não é abortada por inteiro, mas entra em uma tarefa de
recuperação, a qual busca uma nova trajetória para a DORIS (sentido contrário,
em caso de trilho circular).