\chapter{Arquitetura proposta}

O capítulo~\ref{bibliografia} apresentou os conceitos necessários para o
entendimento desta dissertação, mostrou a evolução das arquiteturas robóticas e
controles de missão, e as diversas aplicações em robôs modernos. A autonomia de
um robô depende, em grande parte, do desenvolvimento desta arquitetura robótica.

Neste capítulo, será apresentada uma implementação da arquitetura híbrida de
três camadas, utilizando o ambiente de desenvolvimento ROS, para um robô
móvel que executa tarefas de inspeção, a DORIS. Como definido no
capítulo~\ref{bibliografia}, a arquitetura robótica não é apenas uma
arquitetura de software, mas sim uma arquitetura que depende dos
componentes físicos do robô (hardware) e a sua aplicação. Dessa forma, faz-se
necessário apresentar o objeto de estudo desta dissertação.

\section{Robô DORIS}\label{doris}
DORIS é um robô desenvolvido pela COPPE/UFRJ, em colaboração com Petrobras e
Statoil, para aplicação \textit{offshore}: monitoramento e inspeção em
plataformas de petróleo. O robô é controlado de maneira autônoma ou teleoperado,
permitindo que o operador acompanhe o estado da missão, e monitore a informação
dos sensores. O robô apresenta as seguintes funcionalidades
\cite{carvalho2013doris}:

\begin{itemize}
  \item Detecção de anomalias por vídeo: uso de múltiplas câmeras (luz visível,
  infravermelho, fisheye e estéreo) para detectar anomalias, como objetos abandonados, fumaça,
  fogo, intrusos e vazamentos.
  \item Detecção de anomalias por áudio: microfones detectam áudios anômalos,
  como explosões, e realizam diagnóstico de mau funcionamento de máquinas, comparando os sons recebidos com
  assinaturas obtidas previamente.
  \item Detecção de anomalias por vibração: DORIS possui um manipulador com
  sensor de vibração em seu efetuador para inspecionar o funcionamento de máquinas, a partir de
  algoritmos com classificadores de falhas.
  \item Detecção de anomalias por sensor de gás: sensor de hidrocarboneto
  detecta o vazamento de gases.
  \item Mapeamento 3D do ambiente: DORIS é capaz de reconstruir um ambiente 3D a
  partir de câmeras e Laser.
  \item Detecção de anomalias por temperatura: DORIS possui um sensor de
  temperatura e umidade.
  \item Detecção de anomalias por câmera de infravermelho: uma câmera de
  infravermelho pode detectar pessoas, indicar a presença de intrusos ou
  indentificar incêncidos.
\end{itemize}

DORIS é um robô móvel que se locomove em um trilho pelo uso de dois gimbals, os
quais contêm atuadores e rodas. O robô foi desenvolvido dentro da filosofia
de modularidade, isto é, novos sensores podem ser integrados ao sistema, ou até
um novo módulo do robô pode ser adicionado, a fim de melhorar seu desempenho
dentro do escopo da aplicação de inspeção. Isso exige a
flexibilidade e modularidade do sistema mecânico, software e sistema
elétrico/eletrônico.

O sistema é alimentado por quatro baterias, composto por um computador
embarcado com processador de alto desempenho e memória, e um \textit{solid-state drive} para armazenamento. Possui
comunicações: Wireless IEEE 802.11n com a base (operador); \textit{Controller
Area Network} (CAN) entre computador embarcado e drivers dos atuadores; rede \textit{Local
Gigabit Ethernet} para os diversos componentes internos do robô; e rádio 2.4/5.0
GHz para emergência. Possui atuadores: quatro motores 200 W EC-4pole para
locomoção; e quatro motores para as juntas do mannipulador. Sensores:
câmera fixa; câmera térmica; câmera \textit{fisheye}; duas webcams; e uma
\textit{Inertial Measurement Unit} (IMU). Além disso, há um
sistema eletrônico de suporte de veículo, chamado \textit{Vehicle Support
System (VSS)} \cite{freitas2015embedded}, capaz de detectar falhas eletrônicas,
distribuir energia de maneira ótima entre os componentes e proteger o robô em
situações emergenciais.

O VSS possui funções que independem do software e da arquitetura robótica, são
considerados de alto risco e, portanto, não estão disponíveis para
programador e usuário. Em detalhes, as funções do VSS são:
\begin{itemize}
  \item Detecção de falhas: em dispositivos, pelo monitoramento de
  corrente/tensão; no módulo, pela verificação de temperatura/umidade;
  \item Proteção de dispositivos contra sobrecorrente graças a fusíveis;
  \item Distribuição ótima de energia e monitoramento de baterias;
  \item Botão de emergência para desligamento manual ou via rádio.
\end{itemize}

O trilho por onde o robô se desloca é construído a partir de tubos de
policloreto de polivinila (PVC) e possui seções retas, curvas ortogonais de
subida, descida, para a direita e para a esquerda. Os segmentos curvos são tubos
de 1 m dobrados $90^o$, resultando em curvaturas de aproximadamente 630 mm. Um
trilho para testes foi construído no Centro de Pesquisas e
Desenvolvimento da Petrobras (CENPES) e sua extensão é cerca de 140 m.

\section{A arquitetura robótica implementada}

Na seção~\ref{doris}, foi apresentado o robô DORIS e suas funcionalidades. Como
foi definido na seção~\ref{conceitos}, pela visão do autor, o conceito de
\emph{arquitetura robótica} não é equivalente apenas a uma arquitetura de
software, necessitando da avaliação do robô como um todo, isto é, seus
elementos de hardware e sua aplicação. Assim como o desenvolvedor do RDE ROS
\cite{quigley2009ros} evidencia que não há melhor RDE, já que todos apresentam
vantagens e desvantagens e o melhor depende de sua aplicação, também não há
melhor arquitetura robótica, pois esta depende dos hardwares do robô e também da
sua aplicação.

DORIS é um robô móvel com a funcionalidade de inspeção em um ambiente não muito
dinâmico, usando técnicas que exigem grande processamento de imagem (câmeras) e
outros sensores. O usuário final poderá, com o auxílio de uma interface,
programar as missões: inspeção até uma posição do trilho, inspeção de
equipamento, ir até uma posição do trilho, e ronda (inspeção global). Além
disso, o usuário pode tomar o controle manual do robô, e visualizar as
respostas dos sensores.
 
As funcionalidades de inspeção do robô exigem a construção e manutenção do
modelo do mundo, pois há constante comparação com a situação esperada e
possíveis anomalias. Também fica claro que não é só um modelo do mundo que se
faz necessário, mas a construção de modelos distintos para cada componente
de forma a otimizar as missões. Além disso, robôs \textit{offshore} exigem
grande robustez, por trabalharem em ambientes hostis, e que demandam ações rápidas em situações
emergenciais. As exigências de um controle de missão para modos
flexíveis de inspeção, a manutenção de modelos de mundo e a robustez
no controle do robô demandam uma arquitetura híbrida.

No capítulo~\ref{bibliografia}, foi explicitada algumas formas de arquitetura
híbrida, mas aquela com maior número de aplicações bem sucedidas é a arquitetura
híbrida de três camadas, utilizadas desde a aplicação do carro autônomo do
desafio DARPA (Stanley) até a aplicação de exploração do robô da NASA no
planeta Marte. 

Escolhida a arquitetura híbrida de três camadas como arquitetura robótica da
DORIS, faz-se ainda necessário explicitar a implementação de cada camada, isto
é, como e qual executará as funções descritas por Murphy: sequenciador,
gerenciador de recurso, cartógrafo, planejador de missão, e monitor de
desempenho. A arquitetura de três camadas é formada por: camada Funcional,
camada Executiva e camada Planejador, e como cada arquitetura de três camadas
apresenta suas peculiaridades, as camadas desenvolvidas para o robô DORIS são descritas nas
subseções adiante.


\subsection{Implementação da camada Funcional}

A camada funcional é a primeira implementada e exaustivamente testada no
robô DORIS. Como nas outras arquiteturas de três camadas previamente
apresentadas, a camada Funcional é o nível mais baixo, conecta sensores a
atuadores, implementa controladores PID, e diversos outros algoritmos, por
exemplo para a localização do robô. Utiliza-se Ubuntu/Linux como sistema
operacional e ROS como RDE para a implementação do nível funcional, já que este
apresenta todas as vantagens descritas na subseção~\ref{ros}, e linguagem de programação C++, a fim de
se garantir maior eficiência computacional.

A camada funcional seguiu a recomendação dos desenvolvedores do ROS, sendo
estruturado de maneira semelhante à camada funcional do sistema CLARAty. Neste,
a camada funcional é uma interface com todo o sistema de hardware e suas
capacidades. É um software orientado a objeto, obtendo assim modularidade de
hardware, e uma estruturação apropriada para usar as propriedades de
herança, em software. A figura~\ref{claratyfunc} mostra a organização da camada
Funcional da arquitetura CLARAty.

\begin{figure}[!ht]
\centering
\includegraphics[width=.5\columnwidth]{figs/claratyfunc.jpg}
\caption{Organização da camada Funcional CLARAty}
\label{claratyfunc}
\end{figure}

Foi proposto o \textit{Robot Package Software}. Neste sistema,
\emph{Tools} (janelas gráficas) e \emph{Componentes} (unidades de comunicação e
processamento) são agrupados em \textit{Robot Package} (bibliotecas dinâmicas).
Os componentes que lidam com hardware rodam no computador embarcado do robô,
já os componentes que interagem com as \textit{tools} rodam no computador base.
Os diversos componentes, tanto do computador embarcado quanto da base, se
comunicam através de mensagens ROS, permitindo que a base controle o robô, na
função de teleoperação \cite{freitas2015embedded}. Os componentes do robô são
o foco de estudos desta dissertação, já que os componentes da base não estão
diretamente ligados à autonomia do robô, mas apenas a uma fração do controle de
missão, que diz respeito à interface com o usuário e \textit{feedback} dos
planos ao usuário.

Dois \textit{Robot Packages} fazem parte no desenvolvimento do robô DORIS:
\textit{General Package} e \textit{DORIS Package}, derivado do primeiro. Outros
robôs desenvolvidos por GSCAR, como o ROV LUMA, possuem seus pacotes
específicos, derivados do \textit{General Package}. 

O \textit{General Package} contém os componentes e \textit{tools} gerais
relacionados a vídeo, áudio, tabela de dados, \textit{gamepad} (para controle
remoto de robôs), e configurações de dispositivos que podem ser usados em outros
robôs

O \textit{DORIS Package} é um pacote mais específico ao robô DORIS e lida com
seus elementos de hardware e suas funcionalidades. Do ponto de vista de uma
arquitetura robótica, neste pacote foram implementados os \emph{comportamentos}
específicos do robô DORIS.  Os diversos componentes implementados para o DORIS
foram divididos em funcionalidades, neste trabalho, a fim de proporcionar melhor
entendimento.

Como já descrito na seção~\ref{doris}, os atuadores para locomoção e para o
manipulador do DORIS se comunicam via CAN-Bus, que provê velocidade e
transferência confiável dos dados \cite{corrigan2008introduction}. Esta
comunicação extra, exigiu a implementação do componente \emph{CANOpen}, que utiliza a biblioteca
SocketCAN disponivel em Linux. Um componente \emph{EPOS} é classe derivada de
\emph{CANOpen} e especifica este tipo de comunicação com o hardware EPOS
(driver) utilizado no DORIS, além de implementar outras caracterísiticas do
driver, como os dados dos encoders dos motores: posição (odometria), velocidade
e corrente.
Além disso, há a \emph{EPOSNodelet}, classe derivada de \emph{EPOS}, que implementa a comunicação ROS. A implementação dos
componentes respeita a sugestão do desenvolvedor do \textit{framework}, de forma
que sempre há a criação de uma classe padrão C++ e uma classe derivada dentro do
ambiente ROS, que usa os métodos do \textit{framework}.

Os componentes que executam o controle de locomoção do robô são:
\emph{Controller}, \emph{ControllerNodelet} (derivada de \emph{Controller}),
\emph{MotionController} (derivada de \emph{Controller}),
\emph{MotionControllerNodelet} (derivada de \emph{MotionController}),
\emph{PositionController} (derivada de \emph{Controller}) e
\emph{PositionControllerNodelet} (derivada de \emph{PositionController}). Os
componentes \emph{Controller} e \emph{ControllerNodelet} (componente
\emph{Controller} com os recursos de ROS) são classes genéricas de controle,
sendo necessária a implementação do controle para o robô específico,
componentes \emph{MotionController} e \emph{PositionController}.

Os quatro hardwares EPOS possuem uma malha de controle PD ou
PID para realizar o controle do robô por velocidade ou corrente, porém de
maneira independente para cada motor. A sincronia e ajustes dessas malhas de
controle são realizados no componente \emph{MotionController}. Este componente
se comunica por serviço de ROS (\textit{service}) com o componente
\emph{EPOSNodelet}, enviando os valores de velocidade desejados para cada motor.
Por exemplo, observe que, em uma curva, devido à distância entre os dois gimbals
do robô e à distância entre as rodas dos gimbals, os motores devem possuir
velocidades diferentes. O \emph{MotionController} envia set-points de
velocidade às EPOS e pode alterar os parâmetros de aceleração e
desaceleração. Além disso, este componente é responsável por receber entradas do
componente \emph{Joystick} e \emph{Interface}, que podem controlar o robô pela
base, ou \emph{MissionController}, o componente de missão autônoma. Há apenas
a prioridade do \emph{MissionController} sobre todos os outros controladores,
tal que, com exceção do \emph{MissionController}, o componente que irá
controlar será o primeiro que pedir o controle.

O componente \emph{PositionController} será futuramente integrado ao
\emph{MotionController}. Sua funcionalidade é realizar um controle de posição,
logo possui uma malha interna de controle, não disponível no hardware da EPOS, e
se comunica com o componente \emph{MotionController}, enviando set-points de
velocidades. É um controle proporcional de posição com saturação de velocidade.

O manipulador da DORIS utiliza mais quatro EPOS (quatro motores) e exigirá ainda
a implementação de um controle de força para sensoriamento de equipamentos ao
toque, a partir de um sensor de vibração. Componentes como \emph{ForceControl} e
\emph{InspectionVibration} ainda estão em desenvolvimento em.
%TODO referencia marco

Ainda em fase de aperfeiçoamento, os componentes de localização
\emph{Localization} e \emph{LocalizationNodelet} recebem mensagens de ROS
(\textit{subscriber}) do componente \emph{EPOSNodelet}, os dados da odometria,
isto é, quanto cada roda girou. Dentro de \emph{Localization} é feita uma média
para estimar quanto o robô se locomoveu. Em implementação, está sendo feito um
sistema inteligente de localização com os dados dos sensores IMU e LaserScan. A
fusão de sensores permitirá estimar de maneira precisa a posição do robô. O
\emph{LocalizationNodelet} ainda envia mensagens (\emph{Publish}) para o
\emph{PositionController}, \emph{MotionController} e \emph{RVIZ}, um componente
de vizualização para o usuário.

Os diversos componentes de sensores, no robô, são: \emph{AudioSender},
\emph{AudioSenderNodelet} (derivada de \emph{AudioSender}),
\emph{VideoSender}, \emph{VideoSenderNodelet} (derivada de
\emph{VideoSender}), \emph{VideoWebcamera} (derivada de
\emph{VideoSenderNodelet}), \emph{AxisVideo} (derivada de
\emph{VideoSenderNodelet}), \emph{LMS1xx}, \emph{IMU}, \emph{IMUNodelet} e
\emph{ColorDetector}.

O componente \emph{AudioSender} é um driver que faz a interface com os diversos
microfone disponíveis no robô. Comunica-se (\textit{publisher}) por mensagem de
ROS com o componente da base \emph{AudioReceiverNodelet} (\textit{subscriber})
para disponibilizar os dados ao usuário. Futuramente, irá se comunicar
(\textit{publisher}) com o \emph{InspectionAudioNodelet} (\textit{subscriber}),
um componente que compara o áudio da base de dados do robô e detecta anomalias através de um algoritmo de reconhecimento de padrões.

O componente \emph{VideoWebcamera} é um driver que faz a interface com as duas
câmeras webcams disponíveis no robô. Comunica-se
(\textit{publisher}) com o componente da base
\emph{VideoReceiverNodelet} (\textit{subscriber}) para disponibilizar os dados
ao usuário, e com o componente \emph{ColorDetection} (\textit{subscriber}), um
algoritmo que verifica a porcentagem de vermelho obtida em cada frame da
câmera. Futuramente, o componente \emph{ColorDetection} irá se comunicar
(\textit{publisher}) com o \emph{Localization} (\textit{subscriber}), já que a
informação de vermelho no trilho será utilizada para calibrar a
localização.

O componente \emph{LMS1xx} é um driver que faz a interface com o LaserScan,
sensor que realiza um escaneamento a laser do ambiente. Comunica-se
(\textit{publisher}) com o componente da base \emph{LaserReceiverNodelet}
(\textit{subscriber}) para disponibilizar os dados ao usuário. Futuramente, irá
também se comunicar com o \emph{PoleDetection} (\textit{subscriber}), que possui
um algoritmo para detecção de postes, e o \emph{Localization} (\textit{subscriber}), já que
este é mais um sensor que provê dados para o sistema de localização (altura do
robô).

O componente \emph{IMU} é um driver que faz a interface com a IMU.
Ele envia uma lista de dados: velocidade, orientação, posição, pólos
magnéticos e outros. Futuramente, também irá se comunicar com o
\emph{Localization}.

O componente \emph{AxisVideo} é um driver que faz a interface com a câmera fixa
da AXIS. Comunica-se (\textit{publisher}) com o componente
da base de mesmo nome para disponibilizar os dados ao usuário. Futuramente, o
algoritmo de detecção de anomalias por vídeo será integrado ao sistema ROS,
logo um componente \emph{InspectionVideo} será \emph{subscriber} do mesmo
tópico.

A FIGURA represente o esquema de comunicação entre os diversos componentes e
suas hierarquias.

\subsection{Implementação da camada Executivo}
%TODO falar das prioridades
%TODO recursos compartilhados, como fica?
%TODO Referenciar DFKI tb
A camada Executivo elaborada para a DORIS usa SMACH, como linguagem da camada
Executivo, e implementadas técnicas da arquitetura de subsunção simplificada,
onde o módulo básico de comportamento será a máquina de estado aumentada (\emph{AFSM}) da figura~\ref{afsm} sem \textit{Reset}.
A camada Executivo é o foco da implementação do autor desta dissertação e, junto
com a camada Planejador, permite a autonomia do robô. 

As subseções a seguir detalham a implementação da camada Executivo,
identificando como é realizada cada responsabilidade: Sequenciador,
Selecionador, Gerenciador de recursos, e Monitoramento da execução e
recuperação de erros (\textit{Execution monitoring and error recovery}). Como
o ambiente de desenvolvimento da camada Funcional é ROS, optou-se pela
utilização da camada Executivo SMACH \cite{bohren2010smach}, por demonstrar
resultados positivos em diversas aplicações, e já ser integrada ao sistema ROS.
Foram adicionadas algumas funcionalidades à camada a fim de garantir todas as
responsabilidades de uma camada Executivo. A linguagem de programação utilizada
foi Python.

\subsubsection{Sequenciador}


\subsubsection{Gerenciador de recursos}


\subsubsection{Monitoramento de tarefas e recuperação de
erros}\label{monitoamento}
% The languages presented differ considerably in how
% they deal with execution monitoring and exception
% handling. ESL and TDL both provide explicit
% execution monitoring constructs and support exceptions
% that are thrown and then caught by registered
% handlers in a hierarchical fashion. This type of
% exception handling is similar to that used in C++, Java,
% and Lisp. ESL and TDL also support clean up
% procedures that can be invoked when tasks are
% terminated. RAPs and PLEXIL use return values to
% signal failure, and do not have hierarchical exception
% handling. PLEXIL, though, does support clean up
% procedures that are run when tasks fail. PRS has
% support for execution monitoring, but not exception
% handling. ESL and PRS support the notion of resources
% that can be shared. Both provide support for
% automatically preventing contention amongst tasks for
% the resources. In the other executive languages, this
% must be implemented separately (although there are
% plans to extend PLEXIL in this area).





\subsection{Camada planejador}
%TODO lembrar de mapa de equipamentos e quais precisam de manipulador
%TODO mapa de postes
%TODO mapa de distancias ao chao
%TODO mapa 3D
%TODO mapas analiticos
%TODO mapa das seções do trilho.
%TODO mapa audio
%TODO Mapa audio de anomalias
%TODO falar de SLAM
